<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (1.8.0_271) on Thu Dec 15 12:07:33 CST 2022 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Schedulers (reactor-3)</title>
<meta name="date" content="2022-12-15">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Schedulers (reactor-3)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":41,"i4":41,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9,"i22":9,"i23":9,"i24":9,"i25":9,"i26":9,"i27":9,"i28":9,"i29":9,"i30":9,"i31":9,"i32":9,"i33":9,"i34":9,"i35":9,"i36":9,"i37":9,"i38":9,"i39":9,"i40":9};
var tabs = {65535:["t0","所有方法"],1:["t1","静态方法"],8:["t4","具体方法"],32:["t6","已过时的方法"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/Schedulers.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><span class="typeNameLink">上一个类</span></a></li>
<li><a href="../../../reactor/core/scheduler/Schedulers.Factory.html" title="reactor.core.scheduler中的接口"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?reactor/core/scheduler/Schedulers.html" target="_top">框架</a></li>
<li><a href="Schedulers.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li><a href="#nested.class.summary">嵌套</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">reactor.core.scheduler</div>
<h2 title="类 Schedulers" class="title">类 Schedulers</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>reactor.core.scheduler.Schedulers</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public abstract class <span class="typeNameLabel">Schedulers</span>
extends java.lang.Object</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Schedulers.html" title="reactor.core.scheduler中的类"><code>Schedulers</code></a> provides various <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> flavors usable by <a href="../../../reactor/core/publisher/Flux.html#publishOn-reactor.core.scheduler.Scheduler-"><code>publishOn</code></a> or <a href="../../../reactor/core/publisher/Mono.html#subscribeOn-reactor.core.scheduler.Scheduler-"><code>subscribeOn</code></a> :
 <p>
 <ul>
     <li><a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel()</code></a>: Optimized for fast <code>Runnable</code> non-blocking executions </li>
     <li><a href="../../../reactor/core/scheduler/Schedulers.html#single--"><code>single()</code></a>: Optimized for low-latency <code>Runnable</code> one-off executions </li>
     <li><a href="../../../reactor/core/scheduler/Schedulers.html#boundedElastic--"><code>boundedElastic()</code></a>: Optimized for longer executions, an alternative for blocking tasks where the number of active tasks (and threads) is capped</li>
     <li><a href="../../../reactor/core/scheduler/Schedulers.html#immediate--"><code>immediate()</code></a>: to immediately run submitted <code>Runnable</code> instead of scheduling them (somewhat of a no-op or "null object" <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>)</li>
     <li><a href="../../../reactor/core/scheduler/Schedulers.html#fromExecutorService-java.util.concurrent.ExecutorService-"><code>fromExecutorService(ExecutorService)</code></a> to create new instances around <code>Executors</code> </li>
 </ul>
 <p>
 Factories prefixed with <code>new</code> (eg. <a href="../../../reactor/core/scheduler/Schedulers.html#newBoundedElastic-int-int-java.lang.String-"><code>newBoundedElastic(int, int, String)</code></a> return a new instance of their flavor of <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>,
 while other factories like <a href="../../../reactor/core/scheduler/Schedulers.html#boundedElastic--"><code>boundedElastic()</code></a> return a shared instance - which is the one used by operators requiring that flavor as their default Scheduler.
 All instances are returned in a <a href="../../../reactor/core/scheduler/Scheduler.html#init--"><code>initialized</code></a> state.</div>
<dl>
<dt><span class="simpleTagLabel">作者:</span></dt>
<dd>Stephane Maldini</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>嵌套类概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="嵌套类概要表, 列表嵌套类和解释">
<caption><span>嵌套类</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">类和说明</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static interface&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.Factory.html" title="reactor.core.scheduler中的接口">Schedulers.Factory</a></span></code>
<div class="block">Public factory hook to override Schedulers behavior globally</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.Snapshot.html" title="reactor.core.scheduler中的类">Schedulers.Snapshot</a></span></code>
<div class="block">It is also <a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口"><code>Disposable</code></a> in case you don't want to restore the live <a href="../../../reactor/core/scheduler/Schedulers.html" title="reactor.core.scheduler中的类"><code>Schedulers</code></a></div>
</td>
</tr>
</table>
</li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>字段概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="字段概要表, 列表字段和解释">
<caption><span>字段</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">字段和说明</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#DEFAULT_BOUNDED_ELASTIC_QUEUESIZE">DEFAULT_BOUNDED_ELASTIC_QUEUESIZE</a></span></code>
<div class="block">Default maximum number of enqueued tasks PER THREAD for the global <a href="../../../reactor/core/scheduler/Schedulers.html#boundedElastic--"><code>boundedElastic()</code></a> <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>,
 initialized by system property <code>reactor.schedulers.defaultBoundedElasticQueueSize</code> and falls back to
 a bound of 100 000 tasks per backing thread.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#DEFAULT_BOUNDED_ELASTIC_SIZE">DEFAULT_BOUNDED_ELASTIC_SIZE</a></span></code>
<div class="block">Default maximum size for the global <a href="../../../reactor/core/scheduler/Schedulers.html#boundedElastic--"><code>boundedElastic()</code></a> <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>, initialized
 by system property <code>reactor.schedulers.defaultBoundedElasticSize</code> and falls back to 10 x number
 of processors available to the runtime on init.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#DEFAULT_POOL_SIZE">DEFAULT_POOL_SIZE</a></span></code>
<div class="block">Default pool size, initialized by system property <code>reactor.schedulers.defaultPoolSize</code>
 and falls back to the number of processors available to the runtime on init.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>构造器概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="构造器概要表, 列表构造器和解释">
<caption><span>构造器</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">构造器和说明</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#Schedulers--">Schedulers</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>方法概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="方法概要表, 列表方法和解释">
<caption><span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">已过时的方法</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">方法和说明</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#addExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-">addExecutorServiceDecorator</a></span>(java.lang.String&nbsp;key,
                           java.util.function.BiFunction&lt;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>,java.util.concurrent.ScheduledExecutorService,java.util.concurrent.ScheduledExecutorService&gt;&nbsp;decorator)</code>
<div class="block">Set up an additional <code>ScheduledExecutorService</code> decorator for a given key
 only if that key is not already present.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#boundedElastic--">boundedElastic</a></span>()</code>
<div class="block">The common <em>boundedElastic</em> instance, a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates a bounded number of
 ExecutorService-based Workers, reusing them once the Workers have been shut down.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static java.util.concurrent.ScheduledExecutorService</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#decorateExecutorService-reactor.core.scheduler.Scheduler-java.util.concurrent.ScheduledExecutorService-">decorateExecutorService</a></span>(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;owner,
                       java.util.concurrent.ScheduledExecutorService&nbsp;original)</code>
<div class="block">This method is aimed at <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> implementors, enabling custom implementations
 that are backed by a <code>ScheduledExecutorService</code> to also have said executors
 decorated (ie. for instrumentation purposes).</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#disableMetrics--">disableMetrics</a></span>()</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">prefer using Micrometer#timedScheduler from the reactor-core-micrometer module. To be removed at the earliest in 3.6.0.</span></div>
</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#enableMetrics--">enableMetrics</a></span>()</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">prefer using Micrometer#timedScheduler from the reactor-core-micrometer module. To be removed at the earliest in 3.6.0.</span></div>
</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#fromExecutor-java.util.concurrent.Executor-">fromExecutor</a></span>(java.util.concurrent.Executor&nbsp;executor)</code>
<div class="block">Create a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> which uses a backing <code>Executor</code> to schedule
 Runnables for async operators.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#fromExecutor-java.util.concurrent.Executor-boolean-">fromExecutor</a></span>(java.util.concurrent.Executor&nbsp;executor,
            boolean&nbsp;trampoline)</code>
<div class="block">Create a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> which uses a backing <code>Executor</code> to schedule
 Runnables for async operators.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#fromExecutorService-java.util.concurrent.ExecutorService-">fromExecutorService</a></span>(java.util.concurrent.ExecutorService&nbsp;executorService)</code>
<div class="block">Create a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> which uses a backing <code>ExecutorService</code> to schedule
 Runnables for async operators.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#fromExecutorService-java.util.concurrent.ExecutorService-java.lang.String-">fromExecutorService</a></span>(java.util.concurrent.ExecutorService&nbsp;executorService,
                   java.lang.String&nbsp;executorName)</code>
<div class="block">Create a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> which uses a backing <code>ExecutorService</code> to schedule
 Runnables for async operators.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#immediate--">immediate</a></span>()</code>
<div class="block">Executes tasks immediately instead of scheduling them.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#isInNonBlockingThread--">isInNonBlockingThread</a></span>()</code>
<div class="block">Check if calling a Reactor blocking API in the current <code>Thread</code> is forbidden
 or not, by checking if the thread implements <a href="../../../reactor/core/scheduler/NonBlocking.html" title="reactor.core.scheduler中的接口"><code>NonBlocking</code></a> (in which case it is
 forbidden and this method returns <code>true</code>).</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#isNonBlockingThread-java.lang.Thread-">isNonBlockingThread</a></span>(java.lang.Thread&nbsp;t)</code>
<div class="block">Check if calling a Reactor blocking API in the given <code>Thread</code> is forbidden
 or not, by checking if the thread implements <a href="../../../reactor/core/scheduler/NonBlocking.html" title="reactor.core.scheduler中的接口"><code>NonBlocking</code></a> (in which case it is
 forbidden and this method returns <code>true</code>).</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#newBoundedElastic-int-int-java.lang.String-">newBoundedElastic</a></span>(int&nbsp;threadCap,
                 int&nbsp;queuedTaskCap,
                 java.lang.String&nbsp;name)</code>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates a bounded number of ExecutorService-based
 Workers, reusing them once the Workers have been shut down.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#newBoundedElastic-int-int-java.lang.String-int-">newBoundedElastic</a></span>(int&nbsp;threadCap,
                 int&nbsp;queuedTaskCap,
                 java.lang.String&nbsp;name,
                 int&nbsp;ttlSeconds)</code>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates a bounded number of ExecutorService-based
 Workers, reusing them once the Workers have been shut down.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#newBoundedElastic-int-int-java.lang.String-int-boolean-">newBoundedElastic</a></span>(int&nbsp;threadCap,
                 int&nbsp;queuedTaskCap,
                 java.lang.String&nbsp;name,
                 int&nbsp;ttlSeconds,
                 boolean&nbsp;daemon)</code>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates a bounded number of ExecutorService-based
 Workers, reusing them once the Workers have been shut down.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#newBoundedElastic-int-int-java.util.concurrent.ThreadFactory-int-">newBoundedElastic</a></span>(int&nbsp;threadCap,
                 int&nbsp;queuedTaskCap,
                 java.util.concurrent.ThreadFactory&nbsp;threadFactory,
                 int&nbsp;ttlSeconds)</code>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates a bounded number of ExecutorService-based
 Workers, reusing them once the Workers have been shut down.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#newParallel-int-java.util.concurrent.ThreadFactory-">newParallel</a></span>(int&nbsp;parallelism,
           java.util.concurrent.ThreadFactory&nbsp;threadFactory)</code>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded ExecutorService-based
 workers and is suited for parallel work.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#newParallel-java.lang.String-">newParallel</a></span>(java.lang.String&nbsp;name)</code>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded ExecutorService-based
 workers and is suited for parallel work.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#newParallel-java.lang.String-int-">newParallel</a></span>(java.lang.String&nbsp;name,
           int&nbsp;parallelism)</code>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded ExecutorService-based
 workers and is suited for parallel work.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#newParallel-java.lang.String-int-boolean-">newParallel</a></span>(java.lang.String&nbsp;name,
           int&nbsp;parallelism,
           boolean&nbsp;daemon)</code>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded ExecutorService-based
 workers and is suited for parallel work.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#newSingle-java.lang.String-">newSingle</a></span>(java.lang.String&nbsp;name)</code>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded ExecutorService-based worker.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#newSingle-java.lang.String-boolean-">newSingle</a></span>(java.lang.String&nbsp;name,
         boolean&nbsp;daemon)</code>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded ExecutorService-based worker.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#newSingle-java.util.concurrent.ThreadFactory-">newSingle</a></span>(java.util.concurrent.ThreadFactory&nbsp;threadFactory)</code>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded ExecutorService-based worker.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.util.function.BiConsumer-">onHandleError</a></span>(java.util.function.BiConsumer&lt;java.lang.Thread,? super java.lang.Throwable&gt;&nbsp;subHook)</code>
<div class="block">Define a hook anonymous part that is executed alongside keyed parts when a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> has
 <a href="../../../reactor/core/scheduler/Schedulers.html#handleError-java.lang.Throwable-"><code>handled an error</code></a>.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.lang.String-java.util.function.BiConsumer-">onHandleError</a></span>(java.lang.String&nbsp;key,
             java.util.function.BiConsumer&lt;java.lang.Thread,? super java.lang.Throwable&gt;&nbsp;subHook)</code>
<div class="block">Define a keyed hook part that is executed alongside other parts when a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> has
 <a href="../../../reactor/core/scheduler/Schedulers.html#handleError-java.lang.Throwable-"><code>handled an error</code></a>.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>static java.lang.Runnable</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#onSchedule-java.lang.Runnable-">onSchedule</a></span>(java.lang.Runnable&nbsp;runnable)</code>
<div class="block">Applies the hooks registered with <a href="../../../reactor/core/scheduler/Schedulers.html#onScheduleHook-java.lang.String-java.util.function.Function-"><code>onScheduleHook(String, Function)</code></a>.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#onScheduleHook-java.lang.String-java.util.function.Function-">onScheduleHook</a></span>(java.lang.String&nbsp;key,
              java.util.function.Function&lt;java.lang.Runnable,java.lang.Runnable&gt;&nbsp;decorator)</code>
<div class="block">Add or replace a named scheduling <code>decorator</code>.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#parallel--">parallel</a></span>()</code>
<div class="block">The common <em>parallel</em> instance, a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded
 ExecutorService-based workers and is suited for parallel work.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>static java.util.function.BiFunction&lt;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>,java.util.concurrent.ScheduledExecutorService,java.util.concurrent.ScheduledExecutorService&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#removeExecutorServiceDecorator-java.lang.String-">removeExecutorServiceDecorator</a></span>(java.lang.String&nbsp;key)</code>
<div class="block">Remove an existing <code>ScheduledExecutorService</code> decorator if it has been set up
 via <a href="../../../reactor/core/scheduler/Schedulers.html#addExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-"><code>addExecutorServiceDecorator(String, BiFunction)</code></a>.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#resetFactory--">resetFactory</a></span>()</code>
<div class="block">Re-apply default factory to <a href="../../../reactor/core/scheduler/Schedulers.html" title="reactor.core.scheduler中的类"><code>Schedulers</code></a></div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#resetFrom-reactor.core.scheduler.Schedulers.Snapshot-">resetFrom</a></span>(<a href="../../../reactor/core/scheduler/Schedulers.Snapshot.html" title="reactor.core.scheduler中的类">Schedulers.Snapshot</a>&nbsp;snapshot)</code>
<div class="block">Replace the current Factory and shared Schedulers with the ones saved in a
 previously <a href="../../../reactor/core/scheduler/Schedulers.html#setFactoryWithSnapshot-reactor.core.scheduler.Schedulers.Factory-"><code>captured</code></a> snapshot.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#resetOnHandleError--">resetOnHandleError</a></span>()</code>
<div class="block">Reset the <a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.util.function.BiConsumer-"><code>onHandleError(BiConsumer)</code></a> hook to the default no-op behavior, erasing
 all sub-hooks that might have individually added via <a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.lang.String-java.util.function.BiConsumer-"><code>onHandleError(String, BiConsumer)</code></a>
 or the whole hook set via <a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.util.function.BiConsumer-"><code>onHandleError(BiConsumer)</code></a>.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#resetOnHandleError-java.lang.String-">resetOnHandleError</a></span>(java.lang.String&nbsp;key)</code>
<div class="block">Reset a specific onHandleError hook part keyed to the provided <code>String</code>,
 removing that sub-hook if it has previously been defined via <a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.lang.String-java.util.function.BiConsumer-"><code>onHandleError(String, BiConsumer)</code></a>.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#resetOnScheduleHook-java.lang.String-">resetOnScheduleHook</a></span>(java.lang.String&nbsp;key)</code>
<div class="block">Reset a specific onScheduleHook <code>sub-hook</code> if it has been set up
 via <a href="../../../reactor/core/scheduler/Schedulers.html#onScheduleHook-java.lang.String-java.util.function.Function-"><code>onScheduleHook(String, Function)</code></a>.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#resetOnScheduleHooks--">resetOnScheduleHooks</a></span>()</code>
<div class="block">Remove all onScheduleHook <code>sub-hooks</code>.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#setExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-">setExecutorServiceDecorator</a></span>(java.lang.String&nbsp;key,
                           java.util.function.BiFunction&lt;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>,java.util.concurrent.ScheduledExecutorService,java.util.concurrent.ScheduledExecutorService&gt;&nbsp;decorator)</code>
<div class="block">Set up an additional <code>ScheduledExecutorService</code> decorator for a given key,
 even if that key is already present.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#setFactory-reactor.core.scheduler.Schedulers.Factory-">setFactory</a></span>(<a href="../../../reactor/core/scheduler/Schedulers.Factory.html" title="reactor.core.scheduler中的接口">Schedulers.Factory</a>&nbsp;factoryInstance)</code>
<div class="block">Replace <a href="../../../reactor/core/scheduler/Schedulers.html" title="reactor.core.scheduler中的类"><code>Schedulers</code></a> factories (<a href="../../../reactor/core/scheduler/Schedulers.html#newParallel-java.lang.String-"><code>newParallel</code></a>,
 <a href="../../../reactor/core/scheduler/Schedulers.html#newSingle-java.lang.String-"><code>newSingle</code></a> and <a href="../../../reactor/core/scheduler/Schedulers.html#newBoundedElastic-int-int-java.lang.String-"><code>newBoundedElastic</code></a>).</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Schedulers.Snapshot.html" title="reactor.core.scheduler中的类">Schedulers.Snapshot</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#setFactoryWithSnapshot-reactor.core.scheduler.Schedulers.Factory-">setFactoryWithSnapshot</a></span>(<a href="../../../reactor/core/scheduler/Schedulers.Factory.html" title="reactor.core.scheduler中的接口">Schedulers.Factory</a>&nbsp;newFactory)</code>
<div class="block">Replace <a href="../../../reactor/core/scheduler/Schedulers.html" title="reactor.core.scheduler中的类"><code>Schedulers</code></a> factories (<a href="../../../reactor/core/scheduler/Schedulers.html#newParallel-java.lang.String-"><code>newParallel</code></a>,
 <a href="../../../reactor/core/scheduler/Schedulers.html#newSingle-java.lang.String-"><code>newSingle</code></a> and <a href="../../../reactor/core/scheduler/Schedulers.html#newBoundedElastic-int-int-java.lang.String-"><code>newBoundedElastic</code></a>).</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#shutdownNow--">shutdownNow</a></span>()</code>
<div class="block">Clear any cached <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> and call dispose on them.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#single--">single</a></span>()</code>
<div class="block">普通单线程
 
 The common <em>single</em> instance, a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded ExecutorService-based
 worker.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/scheduler/Schedulers.html#single-reactor.core.scheduler.Scheduler-">single</a></span>(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;original)</code>
<div class="block">Wraps a single <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> from some other
 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> and provides <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a>
 services on top of it.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>从类继承的方法&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>字段详细资料</h3>
<a name="DEFAULT_POOL_SIZE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DEFAULT_POOL_SIZE</h4>
<pre>public static final&nbsp;int DEFAULT_POOL_SIZE</pre>
<div class="block">Default pool size, initialized by system property <code>reactor.schedulers.defaultPoolSize</code>
 and falls back to the number of processors available to the runtime on init.</div>
<dl>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>Runtime.availableProcessors()</code></dd>
</dl>
</li>
</ul>
<a name="DEFAULT_BOUNDED_ELASTIC_SIZE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DEFAULT_BOUNDED_ELASTIC_SIZE</h4>
<pre>public static final&nbsp;int DEFAULT_BOUNDED_ELASTIC_SIZE</pre>
<div class="block">Default maximum size for the global <a href="../../../reactor/core/scheduler/Schedulers.html#boundedElastic--"><code>boundedElastic()</code></a> <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>, initialized
 by system property <code>reactor.schedulers.defaultBoundedElasticSize</code> and falls back to 10 x number
 of processors available to the runtime on init.</div>
<dl>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><code>Runtime.availableProcessors()</code>, 
<a href="../../../reactor/core/scheduler/Schedulers.html#boundedElastic--"><code>boundedElastic()</code></a></dd>
</dl>
</li>
</ul>
<a name="DEFAULT_BOUNDED_ELASTIC_QUEUESIZE">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>DEFAULT_BOUNDED_ELASTIC_QUEUESIZE</h4>
<pre>public static final&nbsp;int DEFAULT_BOUNDED_ELASTIC_QUEUESIZE</pre>
<div class="block">Default maximum number of enqueued tasks PER THREAD for the global <a href="../../../reactor/core/scheduler/Schedulers.html#boundedElastic--"><code>boundedElastic()</code></a> <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>,
 initialized by system property <code>reactor.schedulers.defaultBoundedElasticQueueSize</code> and falls back to
 a bound of 100 000 tasks per backing thread.</div>
<dl>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/scheduler/Schedulers.html#boundedElastic--"><code>boundedElastic()</code></a></dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>构造器详细资料</h3>
<a name="Schedulers--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Schedulers</h4>
<pre>public&nbsp;Schedulers()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>方法详细资料</h3>
<a name="fromExecutor-java.util.concurrent.Executor-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromExecutor</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;fromExecutor(java.util.concurrent.Executor&nbsp;executor)</pre>
<div class="block">Create a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> which uses a backing <code>Executor</code> to schedule
 Runnables for async operators.

 <p>Tasks scheduled with workers of this Scheduler are not guaranteed to run in FIFO
 order and strictly non-concurrently.
 If FIFO order is desired, use trampoline parameter of <a href="../../../reactor/core/scheduler/Schedulers.html#fromExecutor-java.util.concurrent.Executor-boolean-"><code>fromExecutor(Executor, boolean)</code></a></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>executor</code> - an <code>Executor</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a></dd>
</dl>
</li>
</ul>
<a name="fromExecutor-java.util.concurrent.Executor-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromExecutor</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;fromExecutor(java.util.concurrent.Executor&nbsp;executor,
                                     boolean&nbsp;trampoline)</pre>
<div class="block">Create a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> which uses a backing <code>Executor</code> to schedule
 Runnables for async operators.

 Trampolining here means tasks submitted in a burst are queued by the Worker itself,
 which acts as a sole task from the perspective of the <code>ExecutorService</code>,
 so no reordering (but also no threading).</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>executor</code> - an <code>Executor</code></dd>
<dd><code>trampoline</code> - set to false if this <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> is used by "operators"
 that already conflate <code>Runnable</code> executions (publishOn, subscribeOn...)</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a></dd>
</dl>
</li>
</ul>
<a name="fromExecutorService-java.util.concurrent.ExecutorService-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromExecutorService</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;fromExecutorService(java.util.concurrent.ExecutorService&nbsp;executorService)</pre>
<div class="block">Create a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> which uses a backing <code>ExecutorService</code> to schedule
 Runnables for async operators.
 <p>
 Prefer using <a href="../../../reactor/core/scheduler/Schedulers.html#fromExecutorService-java.util.concurrent.ExecutorService-java.lang.String-"><code>fromExecutorService(ExecutorService, String)</code></a>,
 especially if you plan on using metrics as this gives the executor a meaningful identifier.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>executorService</code> - an <code>ExecutorService</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a></dd>
</dl>
</li>
</ul>
<a name="fromExecutorService-java.util.concurrent.ExecutorService-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromExecutorService</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;fromExecutorService(java.util.concurrent.ExecutorService&nbsp;executorService,
                                            java.lang.String&nbsp;executorName)</pre>
<div class="block">Create a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> which uses a backing <code>ExecutorService</code> to schedule
 Runnables for async operators.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>executorService</code> - an <code>ExecutorService</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a></dd>
</dl>
</li>
</ul>
<a name="boundedElastic--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boundedElastic</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;boundedElastic()</pre>
<div class="block">The common <em>boundedElastic</em> instance, a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates a bounded number of
 ExecutorService-based Workers, reusing them once the Workers have been shut down. The underlying daemon
 threads can be evicted if idle for more than <code>60</code> seconds.
 <p>
 The maximum number of created threads is bounded by a <code>cap</code> (by default
 ten times the number of available CPU cores, see <a href="../../../reactor/core/scheduler/Schedulers.html#DEFAULT_BOUNDED_ELASTIC_SIZE"><code>DEFAULT_BOUNDED_ELASTIC_SIZE</code></a>).
 The maximum number of task submissions that can be enqueued and deferred on each of these
 backing threads is bounded (by default 100K additional tasks, see
 <a href="../../../reactor/core/scheduler/Schedulers.html#DEFAULT_BOUNDED_ELASTIC_QUEUESIZE"><code>DEFAULT_BOUNDED_ELASTIC_QUEUESIZE</code></a>). Past that point, a <code>RejectedExecutionException</code>
 is thrown.
 <p>
 By order of preference, threads backing a new <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> are
 picked from the idle pool, created anew or reused from the busy pool. In the later case, a best effort
 attempt at picking the thread backing the least amount of workers is made.
 <p>
 Note that if a thread is backing a low amount of workers, but these workers submit a lot of pending tasks,
 a second worker could end up being backed by the same thread and see tasks rejected.
 The picking of the backing thread is also done once and for all at worker creation, so
 tasks could be delayed due to two workers sharing the same backing thread and submitting long-running tasks,
 despite another backing thread becoming idle in the meantime.
 <p>
 Only one instance of this common scheduler will be created on the first call and is cached. The same instance
 is returned on subsequent calls until it is disposed.
 <p>
 One cannot directly <a href="../../../reactor/core/scheduler/Scheduler.html#dispose--"><code>dispose</code></a> the common instances, as they are cached and shared
 between callers. They can however be all <a href="../../../reactor/core/scheduler/Schedulers.html#shutdownNow--"><code>shut down</code></a> together, or replaced by a
 <a href="../../../reactor/core/scheduler/Schedulers.html#setFactory-reactor.core.scheduler.Schedulers.Factory-"><code>change in Factory</code></a>.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the common <em>boundedElastic</em> instance, a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates workers with
 an upper bound to the number of backing threads and after that on the number of enqueued tasks, that reuses
 threads and evict idle ones</dd>
</dl>
</li>
</ul>
<a name="parallel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallel</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;parallel()</pre>
<div class="block">The common <em>parallel</em> instance, a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded
 ExecutorService-based workers and is suited for parallel work.
 <p>
 Only one instance of this common scheduler will be created on the first call and is cached. The same instance
 is returned on subsequent calls until it is disposed.
 <p>
 One cannot directly <a href="../../../reactor/core/scheduler/Scheduler.html#dispose--"><code>dispose</code></a> the common instances, as they are cached and shared
 between callers. They can however be all <a href="../../../reactor/core/scheduler/Schedulers.html#shutdownNow--"><code>shut down</code></a> together, or replaced by a
 <a href="../../../reactor/core/scheduler/Schedulers.html#setFactory-reactor.core.scheduler.Schedulers.Factory-"><code>change in Factory</code></a>.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the common <em>parallel</em> instance, a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded
 ExecutorService-based workers and is suited for parallel work</dd>
</dl>
</li>
</ul>
<a name="immediate--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>immediate</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;immediate()</pre>
<div class="block">Executes tasks immediately instead of scheduling them.
 <p>
 As a consequence tasks run on the thread that submitted them (eg. the
 thread on which an operator is currently processing its onNext/onComplete/onError signals).
 This <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> is typically used as a "null object" for APIs that require a
 Scheduler but one doesn't want to change threads.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a reusable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that executes tasks immediately instead of scheduling them</dd>
</dl>
</li>
</ul>
<a name="newBoundedElastic-int-int-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newBoundedElastic</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;newBoundedElastic(int&nbsp;threadCap,
                                          int&nbsp;queuedTaskCap,
                                          java.lang.String&nbsp;name)</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates a bounded number of ExecutorService-based
 Workers, reusing them once the Workers have been shut down. The underlying (user)
 threads can be evicted if idle for more than <code>60</code> seconds.
 <p>
 The maximum number of created threads is bounded by the provided <code>threadCap</code>.
 The maximum number of task submissions that can be enqueued and deferred on each of these
 backing threads is bounded by the provided <code>queuedTaskCap</code>. Past that point,
 a <code>RejectedExecutionException</code> is thrown.
 <p>
 By order of preference, threads backing a new <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> are
 picked from the idle pool, created anew or reused from the busy pool. In the later case, a best effort
 attempt at picking the thread backing the least amount of workers is made.
 <p>
 Note that if a thread is backing a low amount of workers, but these workers submit a lot of pending tasks,
 a second worker could end up being backed by the same thread and see tasks rejected.
 The picking of the backing thread is also done once and for all at worker creation, so
 tasks could be delayed due to two workers sharing the same backing thread and submitting long-running tasks,
 despite another backing thread becoming idle in the meantime.
 <p>
 Threads backing this scheduler are user threads, so they will prevent the JVM
 from exiting until their worker has been disposed AND they've been evicted by TTL, or the whole
 scheduler has been <a href="../../../reactor/core/scheduler/Scheduler.html#dispose--"><code>disposed</code></a>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>threadCap</code> - maximum number of underlying threads to create</dd>
<dd><code>queuedTaskCap</code> - maximum number of tasks to enqueue when no more threads can be created. Can be <code>Integer.MAX_VALUE</code> for unbounded enqueueing.</dd>
<dd><code>name</code> - Thread prefix</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates workers with an upper bound to
 the number of backing threads and after that on the number of enqueued tasks,
 that reuses threads and evict idle ones</dd>
</dl>
</li>
</ul>
<a name="newBoundedElastic-int-int-java.lang.String-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newBoundedElastic</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;newBoundedElastic(int&nbsp;threadCap,
                                          int&nbsp;queuedTaskCap,
                                          java.lang.String&nbsp;name,
                                          int&nbsp;ttlSeconds)</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates a bounded number of ExecutorService-based
 Workers, reusing them once the Workers have been shut down. The underlying (user)
 threads can be evicted if idle for more than the provided <code>ttlSeconds</code>.
 <p>
 The maximum number of created threads is bounded by the provided <code>threadCap</code>.
 The maximum number of task submissions that can be enqueued and deferred on each of these
 backing threads is bounded by the provided <code>queuedTaskCap</code>. Past that point,
 a <code>RejectedExecutionException</code> is thrown.
 <p>
 By order of preference, threads backing a new <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> are
 picked from the idle pool, created anew or reused from the busy pool. In the later case, a best effort
 attempt at picking the thread backing the least amount of workers is made.
 <p>
 Note that if a thread is backing a low amount of workers, but these workers submit a lot of pending tasks,
 a second worker could end up being backed by the same thread and see tasks rejected.
 The picking of the backing thread is also done once and for all at worker creation, so
 tasks could be delayed due to two workers sharing the same backing thread and submitting long-running tasks,
 despite another backing thread becoming idle in the meantime.
 <p>
 Threads backing this scheduler are user threads, so they will prevent the JVM
 from exiting until their worker has been disposed AND they've been evicted by TTL, or the whole
 scheduler has been <a href="../../../reactor/core/scheduler/Scheduler.html#dispose--"><code>disposed</code></a>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>threadCap</code> - maximum number of underlying threads to create</dd>
<dd><code>queuedTaskCap</code> - maximum number of tasks to enqueue when no more threads can be created. Can be <code>Integer.MAX_VALUE</code> for unbounded enqueueing.</dd>
<dd><code>name</code> - Thread prefix</dd>
<dd><code>ttlSeconds</code> - Time-to-live for an idle <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates workers with an upper bound to
 the number of backing threads and after that on the number of enqueued tasks,
 that reuses threads and evict idle ones</dd>
</dl>
</li>
</ul>
<a name="newBoundedElastic-int-int-java.lang.String-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newBoundedElastic</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;newBoundedElastic(int&nbsp;threadCap,
                                          int&nbsp;queuedTaskCap,
                                          java.lang.String&nbsp;name,
                                          int&nbsp;ttlSeconds,
                                          boolean&nbsp;daemon)</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates a bounded number of ExecutorService-based
 Workers, reusing them once the Workers have been shut down. The underlying (user or daemon)
 threads can be evicted if idle for more than the provided <code>ttlSeconds</code>.
 <p>
 The maximum number of created threads is bounded by the provided <code>threadCap</code>.
 The maximum number of task submissions that can be enqueued and deferred on each of these
 backing threads is bounded by the provided <code>queuedTaskCap</code>. Past that point,
 a <code>RejectedExecutionException</code> is thrown.
 <p>
 By order of preference, threads backing a new <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> are
 picked from the idle pool, created anew or reused from the busy pool. In the later case, a best effort
 attempt at picking the thread backing the least amount of workers is made.
 <p>
 Note that if a thread is backing a low amount of workers, but these workers submit a lot of pending tasks,
 a second worker could end up being backed by the same thread and see tasks rejected.
 The picking of the backing thread is also done once and for all at worker creation, so
 tasks could be delayed due to two workers sharing the same backing thread and submitting long-running tasks,
 despite another backing thread becoming idle in the meantime.
 <p>
 Depending on the <code>daemon</code> parameter, threads backing this scheduler can be
 user threads or daemon threads. Note that user threads will prevent the JVM from exiting until their
 worker has been disposed AND they've been evicted by TTL, or the whole scheduler has been
 <a href="../../../reactor/core/scheduler/Scheduler.html#dispose--"><code>disposed</code></a>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>threadCap</code> - maximum number of underlying threads to create</dd>
<dd><code>queuedTaskCap</code> - maximum number of tasks to enqueue when no more threads can be created. Can be <code>Integer.MAX_VALUE</code> for unbounded enqueueing.</dd>
<dd><code>name</code> - Thread prefix</dd>
<dd><code>ttlSeconds</code> - Time-to-live for an idle <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a></dd>
<dd><code>daemon</code> - are backing threads <code>daemon threads</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates workers with an upper bound to
 the number of backing threads and after that on the number of enqueued tasks,
 that reuses threads and evict idle ones</dd>
</dl>
</li>
</ul>
<a name="newBoundedElastic-int-int-java.util.concurrent.ThreadFactory-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newBoundedElastic</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;newBoundedElastic(int&nbsp;threadCap,
                                          int&nbsp;queuedTaskCap,
                                          java.util.concurrent.ThreadFactory&nbsp;threadFactory,
                                          int&nbsp;ttlSeconds)</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates a bounded number of ExecutorService-based
 Workers, reusing them once the Workers have been shut down. The underlying (user)
 threads can be evicted if idle for more than the provided <code>ttlSeconds</code>.
 <p>
 The maximum number of created threads is bounded by the provided <code>threadCap</code>.
 The maximum number of task submissions that can be enqueued and deferred on each of these
 backing threads is bounded by the provided <code>queuedTaskCap</code>. Past that point,
 a <code>RejectedExecutionException</code> is thrown.
 <p>
 By order of preference, threads backing a new <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> are
 picked from the idle pool, created anew or reused from the busy pool. In the later case, a best effort
 attempt at picking the thread backing the least amount of workers is made.
 <p>
 Note that if a thread is backing a low amount of workers, but these workers submit a lot of pending tasks,
 a second worker could end up being backed by the same thread and see tasks rejected.
 The picking of the backing thread is also done once and for all at worker creation, so
 tasks could be delayed due to two workers sharing the same backing thread and submitting long-running tasks,
 despite another backing thread becoming idle in the meantime.
 <p>
 Threads backing this scheduler are created by the provided <code>ThreadFactory</code>,
 which can decide whether to create user threads or daemon threads. Note that user threads
 will prevent the JVM from exiting until their worker has been disposed AND they've been evicted by TTL,
 or the whole scheduler has been <a href="../../../reactor/core/scheduler/Scheduler.html#dispose--"><code>disposed</code></a>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>threadCap</code> - maximum number of underlying threads to create</dd>
<dd><code>queuedTaskCap</code> - maximum number of tasks to enqueue when no more threads can be created. Can be <code>Integer.MAX_VALUE</code> for unbounded enqueueing.</dd>
<dd><code>threadFactory</code> - a <code>ThreadFactory</code> to use each thread initialization</dd>
<dd><code>ttlSeconds</code> - Time-to-live for an idle <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that dynamically creates workers with an upper bound to
 the number of backing threads and after that on the number of enqueued tasks,
 that reuses threads and evict idle ones</dd>
</dl>
</li>
</ul>
<a name="newParallel-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newParallel</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;newParallel(java.lang.String&nbsp;name)</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded ExecutorService-based
 workers and is suited for parallel work. This type of <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> detects and
 rejects usage of blocking Reactor APIs.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - Thread prefix</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded
 ExecutorService-based workers and is suited for parallel work</dd>
</dl>
</li>
</ul>
<a name="newParallel-java.lang.String-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newParallel</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;newParallel(java.lang.String&nbsp;name,
                                    int&nbsp;parallelism)</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded ExecutorService-based
 workers and is suited for parallel work. This type of <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> detects and
 rejects usage of blocking Reactor APIs.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - Thread prefix</dd>
<dd><code>parallelism</code> - Number of pooled workers.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded
 ExecutorService-based workers and is suited for parallel work</dd>
</dl>
</li>
</ul>
<a name="newParallel-java.lang.String-int-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newParallel</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;newParallel(java.lang.String&nbsp;name,
                                    int&nbsp;parallelism,
                                    boolean&nbsp;daemon)</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded ExecutorService-based
 workers and is suited for parallel work. This type of <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> detects and
 rejects usage of blocking Reactor APIs.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - Thread prefix</dd>
<dd><code>parallelism</code> - Number of pooled workers.</dd>
<dd><code>daemon</code> - false if the <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> requires an explicit <a href="../../../reactor/core/scheduler/Scheduler.html#dispose--"><code>Scheduler.dispose()</code></a> to exit the VM.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded
 ExecutorService-based workers and is suited for parallel work</dd>
</dl>
</li>
</ul>
<a name="newParallel-int-java.util.concurrent.ThreadFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newParallel</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;newParallel(int&nbsp;parallelism,
                                    java.util.concurrent.ThreadFactory&nbsp;threadFactory)</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded ExecutorService-based
 workers and is suited for parallel work.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>parallelism</code> - Number of pooled workers.</dd>
<dd><code>threadFactory</code> - a <code>ThreadFactory</code> to use for the fixed initialized
 number of <code>Thread</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a fixed pool of single-threaded
 ExecutorService-based workers and is suited for parallel work</dd>
</dl>
</li>
</ul>
<a name="newSingle-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newSingle</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;newSingle(java.lang.String&nbsp;name)</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded ExecutorService-based worker. This type of <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>
 detects and rejects usage of blocking Reactor APIs.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - Component and thread name prefix</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded ExecutorService-based
 worker</dd>
</dl>
</li>
</ul>
<a name="newSingle-java.lang.String-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newSingle</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;newSingle(java.lang.String&nbsp;name,
                                  boolean&nbsp;daemon)</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded ExecutorService-based worker. This type of <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>
 detects and rejects usage of blocking Reactor APIs.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - Component and thread name prefix</dd>
<dd><code>daemon</code> - false if the <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> requires an explicit <a href="../../../reactor/core/scheduler/Scheduler.html#dispose--"><code>Scheduler.dispose()</code></a> to exit the VM.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded ExecutorService-based
 worker</dd>
</dl>
</li>
</ul>
<a name="newSingle-java.util.concurrent.ThreadFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>newSingle</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;newSingle(java.util.concurrent.ThreadFactory&nbsp;threadFactory)</pre>
<div class="block"><a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded ExecutorService-based worker.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>threadFactory</code> - a <code>ThreadFactory</code> to use for the unique thread of the
 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded ExecutorService-based
 worker</dd>
</dl>
</li>
</ul>
<a name="onHandleError-java.util.function.BiConsumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onHandleError</h4>
<pre>public static&nbsp;void&nbsp;onHandleError(java.util.function.BiConsumer&lt;java.lang.Thread,? super java.lang.Throwable&gt;&nbsp;subHook)</pre>
<div class="block">Define a hook anonymous part that is executed alongside keyed parts when a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> has
 <a href="../../../reactor/core/scheduler/Schedulers.html#handleError-java.lang.Throwable-"><code>handled an error</code></a>. Note that it is executed after
 the error has been passed to the thread uncaughtErrorHandler, which is not the
 case when a fatal error occurs (see <a href="../../../reactor/core/Exceptions.html#throwIfJvmFatal-java.lang.Throwable-"><code>Exceptions.throwIfJvmFatal(Throwable)</code></a>).
 <p>
 This variant uses an internal private key, which allows the method to be additive with
 <a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.lang.String-java.util.function.BiConsumer-"><code>onHandleError(String, BiConsumer)</code></a>. Prefer adding and removing handler parts
 for keys that you own via <a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.lang.String-java.util.function.BiConsumer-"><code>onHandleError(String, BiConsumer)</code></a> nonetheless.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>subHook</code> - the new <code>BiConsumer</code> to set as the hook's anonymous part.</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.lang.String-java.util.function.BiConsumer-"><code>onHandleError(String, BiConsumer)</code></a></dd>
</dl>
</li>
</ul>
<a name="onHandleError-java.lang.String-java.util.function.BiConsumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onHandleError</h4>
<pre>public static&nbsp;void&nbsp;onHandleError(java.lang.String&nbsp;key,
                                 java.util.function.BiConsumer&lt;java.lang.Thread,? super java.lang.Throwable&gt;&nbsp;subHook)</pre>
<div class="block">Define a keyed hook part that is executed alongside other parts when a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> has
 <a href="../../../reactor/core/scheduler/Schedulers.html#handleError-java.lang.Throwable-"><code>handled an error</code></a>. Note that it is executed after
 the error has been passed to the thread uncaughtErrorHandler, which is not the
 case when a fatal error occurs (see <a href="../../../reactor/core/Exceptions.html#throwIfJvmFatal-java.lang.Throwable-"><code>Exceptions.throwIfJvmFatal(Throwable)</code></a>).
 <p>
 Calling this method twice with the same key replaces the old hook part
 of the same key. Calling this method twice with two different keys is otherwise additive.
 Note that <a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.util.function.BiConsumer-"><code>onHandleError(BiConsumer)</code></a> also defines an anonymous part which
 effectively uses a private internal key, making it also additive with this method.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>key</code> - the <code>String</code> key identifying the hook part to set/replace.</dd>
<dd><code>subHook</code> - the new hook part to set for the given key.</dd>
</dl>
</li>
</ul>
<a name="isInNonBlockingThread--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isInNonBlockingThread</h4>
<pre>public static&nbsp;boolean&nbsp;isInNonBlockingThread()</pre>
<div class="block">Check if calling a Reactor blocking API in the current <code>Thread</code> is forbidden
 or not, by checking if the thread implements <a href="../../../reactor/core/scheduler/NonBlocking.html" title="reactor.core.scheduler中的接口"><code>NonBlocking</code></a> (in which case it is
 forbidden and this method returns <code>true</code>).</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>true</code> if blocking is forbidden in this thread, <code>false</code> otherwise</dd>
</dl>
</li>
</ul>
<a name="isNonBlockingThread-java.lang.Thread-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isNonBlockingThread</h4>
<pre>public static&nbsp;boolean&nbsp;isNonBlockingThread(java.lang.Thread&nbsp;t)</pre>
<div class="block">Check if calling a Reactor blocking API in the given <code>Thread</code> is forbidden
 or not, by checking if the thread implements <a href="../../../reactor/core/scheduler/NonBlocking.html" title="reactor.core.scheduler中的接口"><code>NonBlocking</code></a> (in which case it is
 forbidden and this method returns <code>true</code>).</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd><code>true</code> if blocking is forbidden in that thread, <code>false</code> otherwise</dd>
</dl>
</li>
</ul>
<a name="enableMetrics--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enableMetrics</h4>
<pre>@Deprecated
public static&nbsp;void&nbsp;enableMetrics()</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">prefer using Micrometer#timedScheduler from the reactor-core-micrometer module. To be removed at the earliest in 3.6.0.</span></div>
<div class="block">If Micrometer is available, set-up a decorator that will instrument any
 <code>ExecutorService</code> that backs a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.
 No-op if Micrometer isn't available.

 <p>
 The <code>MeterRegistry</code> used by reactor can be configured via
 <a href="../../../reactor/util/Metrics.MicrometerConfiguration.html#useRegistry-io.micrometer.core.instrument.MeterRegistry-"><code>Metrics.MicrometerConfiguration.useRegistry(MeterRegistry)</code></a>
 prior to using this method, the default being
 <code>Metrics.globalRegistry</code>.
 </p></div>
</li>
</ul>
<a name="disableMetrics--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>disableMetrics</h4>
<pre>@Deprecated
public static&nbsp;void&nbsp;disableMetrics()</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">prefer using Micrometer#timedScheduler from the reactor-core-micrometer module. To be removed at the earliest in 3.6.0.</span></div>
<div class="block">If <a href="../../../reactor/core/scheduler/Schedulers.html#enableMetrics--"><code>enableMetrics()</code></a> has been previously called, removes the decorator.
 No-op if <a href="../../../reactor/core/scheduler/Schedulers.html#enableMetrics--"><code>enableMetrics()</code></a> hasn't been called.</div>
</li>
</ul>
<a name="resetFactory--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resetFactory</h4>
<pre>public static&nbsp;void&nbsp;resetFactory()</pre>
<div class="block">Re-apply default factory to <a href="../../../reactor/core/scheduler/Schedulers.html" title="reactor.core.scheduler中的类"><code>Schedulers</code></a></div>
</li>
</ul>
<a name="setFactoryWithSnapshot-reactor.core.scheduler.Schedulers.Factory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFactoryWithSnapshot</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Schedulers.Snapshot.html" title="reactor.core.scheduler中的类">Schedulers.Snapshot</a>&nbsp;setFactoryWithSnapshot(<a href="../../../reactor/core/scheduler/Schedulers.Factory.html" title="reactor.core.scheduler中的接口">Schedulers.Factory</a>&nbsp;newFactory)</pre>
<div class="block">Replace <a href="../../../reactor/core/scheduler/Schedulers.html" title="reactor.core.scheduler中的类"><code>Schedulers</code></a> factories (<a href="../../../reactor/core/scheduler/Schedulers.html#newParallel-java.lang.String-"><code>newParallel</code></a>,
 <a href="../../../reactor/core/scheduler/Schedulers.html#newSingle-java.lang.String-"><code>newSingle</code></a> and <a href="../../../reactor/core/scheduler/Schedulers.html#newBoundedElastic-int-int-java.lang.String-"><code>newBoundedElastic</code></a>).
 Unlike <a href="../../../reactor/core/scheduler/Schedulers.html#setFactory-reactor.core.scheduler.Schedulers.Factory-"><code>setFactory(Factory)</code></a>, doesn't shutdown previous Schedulers but
 capture them in a <a href="../../../reactor/core/scheduler/Schedulers.Snapshot.html" title="reactor.core.scheduler中的类"><code>Schedulers.Snapshot</code></a> that can be later restored via <a href="../../../reactor/core/scheduler/Schedulers.html#resetFrom-reactor.core.scheduler.Schedulers.Snapshot-"><code>resetFrom(Snapshot)</code></a>.
 <p>
 This method should be called safely and with caution, typically on app startup.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>newFactory</code> - an arbitrary <a href="../../../reactor/core/scheduler/Schedulers.Factory.html" title="reactor.core.scheduler中的接口"><code>Schedulers.Factory</code></a> instance</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/scheduler/Schedulers.Snapshot.html" title="reactor.core.scheduler中的类"><code>Schedulers.Snapshot</code></a> representing a restorable snapshot of <a href="../../../reactor/core/scheduler/Schedulers.html" title="reactor.core.scheduler中的类"><code>Schedulers</code></a></dd>
</dl>
</li>
</ul>
<a name="resetFrom-reactor.core.scheduler.Schedulers.Snapshot-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resetFrom</h4>
<pre>public static&nbsp;void&nbsp;resetFrom(<a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                             <a href="../../../reactor/core/scheduler/Schedulers.Snapshot.html" title="reactor.core.scheduler中的类">Schedulers.Snapshot</a>&nbsp;snapshot)</pre>
<div class="block">Replace the current Factory and shared Schedulers with the ones saved in a
 previously <a href="../../../reactor/core/scheduler/Schedulers.html#setFactoryWithSnapshot-reactor.core.scheduler.Schedulers.Factory-"><code>captured</code></a> snapshot.
 <p>
 Passing <code>null</code> re-applies the default factory.</div>
</li>
</ul>
<a name="resetOnHandleError--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resetOnHandleError</h4>
<pre>public static&nbsp;void&nbsp;resetOnHandleError()</pre>
<div class="block">Reset the <a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.util.function.BiConsumer-"><code>onHandleError(BiConsumer)</code></a> hook to the default no-op behavior, erasing
 all sub-hooks that might have individually added via <a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.lang.String-java.util.function.BiConsumer-"><code>onHandleError(String, BiConsumer)</code></a>
 or the whole hook set via <a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.util.function.BiConsumer-"><code>onHandleError(BiConsumer)</code></a>.</div>
<dl>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/scheduler/Schedulers.html#resetOnHandleError-java.lang.String-"><code>resetOnHandleError(String)</code></a></dd>
</dl>
</li>
</ul>
<a name="resetOnHandleError-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resetOnHandleError</h4>
<pre>public static&nbsp;void&nbsp;resetOnHandleError(java.lang.String&nbsp;key)</pre>
<div class="block">Reset a specific onHandleError hook part keyed to the provided <code>String</code>,
 removing that sub-hook if it has previously been defined via <a href="../../../reactor/core/scheduler/Schedulers.html#onHandleError-java.lang.String-java.util.function.BiConsumer-"><code>onHandleError(String, BiConsumer)</code></a>.</div>
</li>
</ul>
<a name="setFactory-reactor.core.scheduler.Schedulers.Factory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFactory</h4>
<pre>public static&nbsp;void&nbsp;setFactory(<a href="../../../reactor/core/scheduler/Schedulers.Factory.html" title="reactor.core.scheduler中的接口">Schedulers.Factory</a>&nbsp;factoryInstance)</pre>
<div class="block">Replace <a href="../../../reactor/core/scheduler/Schedulers.html" title="reactor.core.scheduler中的类"><code>Schedulers</code></a> factories (<a href="../../../reactor/core/scheduler/Schedulers.html#newParallel-java.lang.String-"><code>newParallel</code></a>,
 <a href="../../../reactor/core/scheduler/Schedulers.html#newSingle-java.lang.String-"><code>newSingle</code></a> and <a href="../../../reactor/core/scheduler/Schedulers.html#newBoundedElastic-int-int-java.lang.String-"><code>newBoundedElastic</code></a>).
 Also shutdown Schedulers from the cached factories (like <a href="../../../reactor/core/scheduler/Schedulers.html#single--"><code>single()</code></a>) in order to
 also use these replacements, re-creating the shared schedulers from the new factory
 upon next use.
 <p>
 This method should be called safely and with caution, typically on app startup.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>factoryInstance</code> - an arbitrary <a href="../../../reactor/core/scheduler/Schedulers.Factory.html" title="reactor.core.scheduler中的接口"><code>Schedulers.Factory</code></a> instance.</dd>
</dl>
</li>
</ul>
<a name="addExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addExecutorServiceDecorator</h4>
<pre>public static&nbsp;boolean&nbsp;addExecutorServiceDecorator(java.lang.String&nbsp;key,
                                                  java.util.function.BiFunction&lt;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>,java.util.concurrent.ScheduledExecutorService,java.util.concurrent.ScheduledExecutorService&gt;&nbsp;decorator)</pre>
<div class="block">Set up an additional <code>ScheduledExecutorService</code> decorator for a given key
 only if that key is not already present.
 <p>
 The decorator is a <code>BiFunction</code> taking the Scheduler and the backing
 <code>ScheduledExecutorService</code> as second argument. It returns the
 decorated <code>ScheduledExecutorService</code>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>key</code> - the key under which to set up the decorator</dd>
<dd><code>decorator</code> - the executor service decorator to add, if key not already present.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>true if the decorator was added, false if a decorator was already present
 for this key.</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/scheduler/Schedulers.html#setExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-"><code>setExecutorServiceDecorator(String, BiFunction)</code></a>, 
<a href="../../../reactor/core/scheduler/Schedulers.html#removeExecutorServiceDecorator-java.lang.String-"><code>removeExecutorServiceDecorator(String)</code></a>, 
<a href="../../../reactor/core/scheduler/Schedulers.html#onScheduleHook-java.lang.String-java.util.function.Function-"><code>onScheduleHook(String, Function)</code></a></dd>
</dl>
</li>
</ul>
<a name="setExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setExecutorServiceDecorator</h4>
<pre>public static&nbsp;void&nbsp;setExecutorServiceDecorator(java.lang.String&nbsp;key,
                                               java.util.function.BiFunction&lt;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>,java.util.concurrent.ScheduledExecutorService,java.util.concurrent.ScheduledExecutorService&gt;&nbsp;decorator)</pre>
<div class="block">Set up an additional <code>ScheduledExecutorService</code> decorator for a given key,
 even if that key is already present.
 <p>
 The decorator is a <code>BiFunction</code> taking the Scheduler and the backing
 <code>ScheduledExecutorService</code> as second argument. It returns the
 decorated <code>ScheduledExecutorService</code>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>key</code> - the key under which to set up the decorator</dd>
<dd><code>decorator</code> - the executor service decorator to add, if key not already present.</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/scheduler/Schedulers.html#addExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-"><code>addExecutorServiceDecorator(String, BiFunction)</code></a>, 
<a href="../../../reactor/core/scheduler/Schedulers.html#removeExecutorServiceDecorator-java.lang.String-"><code>removeExecutorServiceDecorator(String)</code></a>, 
<a href="../../../reactor/core/scheduler/Schedulers.html#onScheduleHook-java.lang.String-java.util.function.Function-"><code>onScheduleHook(String, Function)</code></a></dd>
</dl>
</li>
</ul>
<a name="removeExecutorServiceDecorator-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeExecutorServiceDecorator</h4>
<pre>public static&nbsp;java.util.function.BiFunction&lt;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>,java.util.concurrent.ScheduledExecutorService,java.util.concurrent.ScheduledExecutorService&gt;&nbsp;removeExecutorServiceDecorator(java.lang.String&nbsp;key)</pre>
<div class="block">Remove an existing <code>ScheduledExecutorService</code> decorator if it has been set up
 via <a href="../../../reactor/core/scheduler/Schedulers.html#addExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-"><code>addExecutorServiceDecorator(String, BiFunction)</code></a>.
 <p>
 In case the decorator implements <a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口"><code>Disposable</code></a>, it is also
 <a href="../../../reactor/core/Disposable.html#dispose--"><code>disposed</code></a>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>key</code> - the key for the executor service decorator to remove</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the removed decorator, or null if none was set for that key</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/scheduler/Schedulers.html#addExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-"><code>addExecutorServiceDecorator(String, BiFunction)</code></a>, 
<a href="../../../reactor/core/scheduler/Schedulers.html#setExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-"><code>setExecutorServiceDecorator(String, BiFunction)</code></a></dd>
</dl>
</li>
</ul>
<a name="decorateExecutorService-reactor.core.scheduler.Scheduler-java.util.concurrent.ScheduledExecutorService-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>decorateExecutorService</h4>
<pre>public static&nbsp;java.util.concurrent.ScheduledExecutorService&nbsp;decorateExecutorService(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;owner,
                                                                                    java.util.concurrent.ScheduledExecutorService&nbsp;original)</pre>
<div class="block">This method is aimed at <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> implementors, enabling custom implementations
 that are backed by a <code>ScheduledExecutorService</code> to also have said executors
 decorated (ie. for instrumentation purposes).
 <p>
 It <strong>applies</strong> the decorators added via
 <a href="../../../reactor/core/scheduler/Schedulers.html#addExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-"><code>addExecutorServiceDecorator(String, BiFunction)</code></a>, so it shouldn't be added
 as a decorator. Note also that decorators are not guaranteed to be idempotent, so
 this method should be called only once per executor.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>owner</code> - a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that owns the <code>ScheduledExecutorService</code></dd>
<dd><code>original</code> - the <code>ScheduledExecutorService</code> that the <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>
 wants to use originally</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the decorated <code>ScheduledExecutorService</code>, or the original if no decorator is set up</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/scheduler/Schedulers.html#addExecutorServiceDecorator-java.lang.String-java.util.function.BiFunction-"><code>addExecutorServiceDecorator(String, BiFunction)</code></a>, 
<a href="../../../reactor/core/scheduler/Schedulers.html#removeExecutorServiceDecorator-java.lang.String-"><code>removeExecutorServiceDecorator(String)</code></a></dd>
</dl>
</li>
</ul>
<a name="onScheduleHook-java.lang.String-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onScheduleHook</h4>
<pre>public static&nbsp;void&nbsp;onScheduleHook(java.lang.String&nbsp;key,
                                  java.util.function.Function&lt;java.lang.Runnable,java.lang.Runnable&gt;&nbsp;decorator)</pre>
<div class="block">Add or replace a named scheduling <code>decorator</code>. With subsequent calls
 to this method, the onScheduleHook hook can be a composite of several sub-hooks, each
 with a different key.
 <p>
 The sub-hook is a <code>Function</code> taking the scheduled <code>Runnable</code>.
 It returns the decorated <code>Runnable</code>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>key</code> - the key under which to set up the onScheduleHook sub-hook</dd>
<dd><code>decorator</code> - the <code>Runnable</code> decorator to add (or replace, if key is already present)</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/scheduler/Schedulers.html#resetOnScheduleHook-java.lang.String-"><code>resetOnScheduleHook(String)</code></a>, 
<a href="../../../reactor/core/scheduler/Schedulers.html#resetOnScheduleHooks--"><code>resetOnScheduleHooks()</code></a></dd>
</dl>
</li>
</ul>
<a name="resetOnScheduleHook-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resetOnScheduleHook</h4>
<pre>public static&nbsp;void&nbsp;resetOnScheduleHook(java.lang.String&nbsp;key)</pre>
<div class="block">Reset a specific onScheduleHook <code>sub-hook</code> if it has been set up
 via <a href="../../../reactor/core/scheduler/Schedulers.html#onScheduleHook-java.lang.String-java.util.function.Function-"><code>onScheduleHook(String, Function)</code></a>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>key</code> - the key for onScheduleHook sub-hook to remove</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/scheduler/Schedulers.html#onScheduleHook-java.lang.String-java.util.function.Function-"><code>onScheduleHook(String, Function)</code></a>, 
<a href="../../../reactor/core/scheduler/Schedulers.html#resetOnScheduleHooks--"><code>resetOnScheduleHooks()</code></a></dd>
</dl>
</li>
</ul>
<a name="resetOnScheduleHooks--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resetOnScheduleHooks</h4>
<pre>public static&nbsp;void&nbsp;resetOnScheduleHooks()</pre>
<div class="block">Remove all onScheduleHook <code>sub-hooks</code>.</div>
<dl>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/scheduler/Schedulers.html#onScheduleHook-java.lang.String-java.util.function.Function-"><code>onScheduleHook(String, Function)</code></a>, 
<a href="../../../reactor/core/scheduler/Schedulers.html#resetOnScheduleHook-java.lang.String-"><code>resetOnScheduleHook(String)</code></a></dd>
</dl>
</li>
</ul>
<a name="onSchedule-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onSchedule</h4>
<pre>public static&nbsp;java.lang.Runnable&nbsp;onSchedule(java.lang.Runnable&nbsp;runnable)</pre>
<div class="block">Applies the hooks registered with <a href="../../../reactor/core/scheduler/Schedulers.html#onScheduleHook-java.lang.String-java.util.function.Function-"><code>onScheduleHook(String, Function)</code></a>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>runnable</code> - a <code>Runnable</code> submitted to a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>decorated <code>Runnable</code> if any hook is registered, the original otherwise.</dd>
</dl>
</li>
</ul>
<a name="shutdownNow--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shutdownNow</h4>
<pre>public static&nbsp;void&nbsp;shutdownNow()</pre>
<div class="block">Clear any cached <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> and call dispose on them.</div>
</li>
</ul>
<a name="single--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>single</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;single()</pre>
<div class="block">普通单线程
 <p>
 The common <em>single</em> instance, a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded ExecutorService-based
 worker.
 <p>
 Only one instance of this common scheduler will be created on the first call and is cached. The same instance
 is returned on subsequent calls until it is disposed.
 <p>
 One cannot directly <a href="../../../reactor/core/scheduler/Scheduler.html#dispose--"><code>dispose</code></a> the common instances, as they are cached and shared
 between callers. They can however be all <a href="../../../reactor/core/scheduler/Schedulers.html#shutdownNow--"><code>shut down</code></a> together, or replaced by a
 <a href="../../../reactor/core/scheduler/Schedulers.html#setFactory-reactor.core.scheduler.Schedulers.Factory-"><code>change in Factory</code></a>.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the common <em>single</em> instance, a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> that hosts a single-threaded
 ExecutorService-based worker</dd>
</dl>
</li>
</ul>
<a name="single-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>single</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;single(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;original)</pre>
<div class="block">Wraps a single <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> from some other
 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> and provides <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a>
 services on top of it. Unlike with other factory methods in this class, the delegate
 is assumed to be <a href="../../../reactor/core/scheduler/Scheduler.html#init--"><code>initialized</code></a> and won't be implicitly
 initialized by this method.
 <p>
 Use the <a href="../../../reactor/core/scheduler/Scheduler.html#dispose--"><code>Scheduler.dispose()</code></a> to release the wrapped worker.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>original</code> - a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> to call upon to get the single <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a wrapping <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> consistently returning a same worker from a
 source <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/Schedulers.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><span class="typeNameLink">上一个类</span></a></li>
<li><a href="../../../reactor/core/scheduler/Schedulers.Factory.html" title="reactor.core.scheduler中的接口"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?reactor/core/scheduler/Schedulers.html" target="_top">框架</a></li>
<li><a href="Schedulers.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li><a href="#nested.class.summary">嵌套</a>&nbsp;|&nbsp;</li>
<li><a href="#field.summary">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li><a href="#field.detail">字段</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
