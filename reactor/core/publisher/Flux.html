<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (1.8.0_271) on Thu Dec 15 12:07:28 CST 2022 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Flux (reactor-3)</title>
<meta name="date" content="2022-12-15">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Flux (reactor-3)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":10,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":10,"i44":10,"i45":10,"i46":10,"i47":10,"i48":10,"i49":10,"i50":10,"i51":10,"i52":9,"i53":9,"i54":9,"i55":9,"i56":9,"i57":9,"i58":9,"i59":9,"i60":9,"i61":9,"i62":9,"i63":9,"i64":9,"i65":9,"i66":9,"i67":9,"i68":9,"i69":10,"i70":10,"i71":10,"i72":10,"i73":10,"i74":10,"i75":10,"i76":10,"i77":10,"i78":10,"i79":10,"i80":10,"i81":10,"i82":9,"i83":9,"i84":10,"i85":9,"i86":9,"i87":10,"i88":10,"i89":10,"i90":10,"i91":10,"i92":10,"i93":10,"i94":10,"i95":10,"i96":10,"i97":10,"i98":10,"i99":10,"i100":10,"i101":10,"i102":10,"i103":10,"i104":10,"i105":10,"i106":10,"i107":10,"i108":10,"i109":10,"i110":10,"i111":10,"i112":10,"i113":10,"i114":10,"i115":10,"i116":10,"i117":10,"i118":10,"i119":10,"i120":10,"i121":9,"i122":9,"i123":9,"i124":9,"i125":10,"i126":10,"i127":10,"i128":10,"i129":10,"i130":10,"i131":10,"i132":41,"i133":41,"i134":9,"i135":9,"i136":9,"i137":9,"i138":10,"i139":10,"i140":10,"i141":10,"i142":10,"i143":10,"i144":10,"i145":10,"i146":10,"i147":10,"i148":10,"i149":9,"i150":9,"i151":9,"i152":9,"i153":9,"i154":9,"i155":9,"i156":9,"i157":10,"i158":10,"i159":10,"i160":10,"i161":10,"i162":10,"i163":10,"i164":10,"i165":10,"i166":10,"i167":10,"i168":10,"i169":10,"i170":9,"i171":9,"i172":9,"i173":9,"i174":10,"i175":9,"i176":9,"i177":10,"i178":10,"i179":10,"i180":10,"i181":42,"i182":10,"i183":10,"i184":10,"i185":10,"i186":10,"i187":10,"i188":10,"i189":10,"i190":10,"i191":9,"i192":9,"i193":9,"i194":9,"i195":9,"i196":9,"i197":9,"i198":9,"i199":9,"i200":9,"i201":10,"i202":9,"i203":41,"i204":41,"i205":41,"i206":42,"i207":9,"i208":9,"i209":9,"i210":9,"i211":9,"i212":9,"i213":9,"i214":9,"i215":9,"i216":9,"i217":9,"i218":9,"i219":9,"i220":10,"i221":42,"i222":10,"i223":9,"i224":10,"i225":10,"i226":10,"i227":10,"i228":10,"i229":10,"i230":10,"i231":10,"i232":10,"i233":10,"i234":10,"i235":10,"i236":10,"i237":10,"i238":10,"i239":10,"i240":10,"i241":10,"i242":10,"i243":10,"i244":10,"i245":10,"i246":10,"i247":10,"i248":10,"i249":10,"i250":10,"i251":10,"i252":10,"i253":10,"i254":10,"i255":10,"i256":10,"i257":10,"i258":10,"i259":10,"i260":10,"i261":10,"i262":42,"i263":10,"i264":10,"i265":10,"i266":9,"i267":9,"i268":9,"i269":10,"i270":10,"i271":10,"i272":10,"i273":10,"i274":10,"i275":10,"i276":10,"i277":10,"i278":10,"i279":10,"i280":10,"i281":10,"i282":10,"i283":10,"i284":10,"i285":10,"i286":10,"i287":10,"i288":10,"i289":10,"i290":10,"i291":10,"i292":10,"i293":10,"i294":10,"i295":10,"i296":10,"i297":10,"i298":10,"i299":10,"i300":10,"i301":10,"i302":10,"i303":10,"i304":10,"i305":10,"i306":10,"i307":10,"i308":10,"i309":10,"i310":10,"i311":10,"i312":10,"i313":10,"i314":10,"i315":10,"i316":42,"i317":10,"i318":6,"i319":10,"i320":10,"i321":10,"i322":10,"i323":10,"i324":10,"i325":42,"i326":10,"i327":10,"i328":9,"i329":41,"i330":10,"i331":10,"i332":10,"i333":10,"i334":10,"i335":10,"i336":10,"i337":10,"i338":10,"i339":10,"i340":10,"i341":10,"i342":10,"i343":10,"i344":10,"i345":10,"i346":10,"i347":10,"i348":10,"i349":10,"i350":10,"i351":10,"i352":10,"i353":10,"i354":10,"i355":10,"i356":10,"i357":10,"i358":10,"i359":10,"i360":10,"i361":10,"i362":10,"i363":10,"i364":10,"i365":10,"i366":9,"i367":9,"i368":9,"i369":9,"i370":10,"i371":10,"i372":10,"i373":10,"i374":10,"i375":10,"i376":10,"i377":10,"i378":10,"i379":10,"i380":10,"i381":10,"i382":10,"i383":10,"i384":10,"i385":10,"i386":10,"i387":10,"i388":10,"i389":10,"i390":10,"i391":9,"i392":9,"i393":9,"i394":9,"i395":9,"i396":9,"i397":9,"i398":9,"i399":9,"i400":9,"i401":9,"i402":9,"i403":9,"i404":10,"i405":10,"i406":10,"i407":10,"i408":10,"i409":10};
var tabs = {65535:["t0","所有方法"],1:["t1","静态方法"],2:["t2","实例方法"],4:["t3","抽象方法"],8:["t4","具体方法"],32:["t6","已过时的方法"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/Flux.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../reactor/core/publisher/EmitterProcessor.html" title="reactor.core.publisher中的类"><span class="typeNameLink">上一个类</span></a></li>
<li><a href="../../../reactor/core/publisher/FluxArrayTest.html" title="reactor.core.publisher中的类"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?reactor/core/publisher/Flux.html" target="_top">框架</a></li>
<li><a href="Flux.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>嵌套&nbsp;|&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">reactor.core.publisher</div>
<h2 title="类 Flux" class="title">类 Flux&lt;T&gt;</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>reactor.core.publisher.Flux&lt;T&gt;</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the element type of this Reactive Streams <code>Publisher</code></dd>
</dl>
<dl>
<dt>所有已实现的接口:</dt>
<dd>org.reactivestreams.Publisher&lt;T&gt;, <a href="../../../reactor/core/CorePublisher.html" title="reactor.core中的接口">CorePublisher</a>&lt;T&gt;</dd>
</dl>
<dl>
<dt>直接已知子类:</dt>
<dd><a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>, <a href="../../../reactor/core/publisher/FluxOperator.html" title="reactor.core.publisher中的类">FluxOperator</a>, <a href="../../../reactor/core/publisher/FluxProcessor.html" title="reactor.core.publisher中的类">FluxProcessor</a>, <a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类">GroupedFlux</a></dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="typeNameLabel">Flux&lt;T&gt;</span>
extends java.lang.Object
implements <a href="../../../reactor/core/CorePublisher.html" title="reactor.core中的接口">CorePublisher</a>&lt;T&gt;</pre>
<div class="block">A Reactive Streams <code>Publisher</code> with rx operators that emits 0 to N elements, and then completes
 (successfully or with an error).
 <p>
 The recommended way to learn about the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> API and discover new operators is
 through the reference documentation, rather than through this javadoc (as opposed to
 learning more about individual operators). See the <a href="https://projectreactor.io/docs/core/release/reference/docs/index.html#which-operator">
 "which operator do I need?" appendix</a>.

 <p>
 <img class="marble" src="doc-files/marbles/flux.svg" alt="">

 <p>It is intended to be used in implementations and return types. Input parameters should keep using raw
 <code>Publisher</code> as much as possible.

 <p>If it is known that the underlying <code>Publisher</code> will emit 0 or 1 element, <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> should be used
 instead.

 <p>Note that using state in the <code>java.util.function</code> / lambdas used within Flux operators
 should be avoided, as these may be shared between several <code>Subscribers</code>.

 <p> <a href="../../../reactor/core/publisher/Flux.html#subscribe-reactor.core.CoreSubscriber-"><code>subscribe(CoreSubscriber)</code></a> is an internal extension to
 <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscribe(Subscriber)</code></a> used internally for <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> passing. User
 provided <code>Subscriber</code> may
 be passed to this "subscribe" extension but will loose the available
 per-subscribe <a href="../../../reactor/core/publisher/Hooks.html#onLastOperator-java.util.function.Function-"><code>Hooks.onLastOperator(java.util.function.Function&lt;? super org.reactivestreams.Publisher&lt;java.lang.Object&gt;, ? extends org.reactivestreams.Publisher&lt;java.lang.Object&gt;&gt;)</code></a>.</div>
<dl>
<dt><span class="simpleTagLabel">作者:</span></dt>
<dd>Sebastien Deleuze, Stephane Maldini, David Karnok, Simon Baslé</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>构造器概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="构造器概要表, 列表构造器和解释">
<caption><span>构造器</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">构造器和说明</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#Flux--">Flux</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>方法概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="方法概要表, 列表方法和解释">
<caption><span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">实例方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体方法</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">已过时的方法</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">方法和说明</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Boolean&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#all-java.util.function.Predicate-">all</a></span>(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate)</code>
<div class="block">如果此序列的所有值都与 <code>Predicate</code> 匹配，则发出单个布尔值 true.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Boolean&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#any-java.util.function.Predicate-">any</a></span>(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate)</code>
<div class="block">Emit a single boolean true if any of the values of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence match
 the predicate.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>&lt;P&gt;&nbsp;P</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#as-java.util.function.Function-">as</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,P&gt;&nbsp;transformer)</code>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a target type.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#blockFirst--">blockFirst</a></span>()</code>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and <strong>block indefinitely</strong>
 until the upstream signals its first value or completes.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#blockFirst-java.time.Duration-">blockFirst</a></span>(java.time.Duration&nbsp;timeout)</code>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and <strong>block</strong> until the upstream
 signals its first value, completes or a timeout expires.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#blockLast--">blockLast</a></span>()</code>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and <strong>block indefinitely</strong>
 until the upstream signals its last value or completes.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#blockLast-java.time.Duration-">blockLast</a></span>(java.time.Duration&nbsp;timeout)</code>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and <strong>block</strong> until the upstream
 signals its last value, completes or a timeout expires.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#buffer--">buffer</a></span>()</code>
<div class="block">Collect all incoming values into a single <code>List</code> buffer that will be emitted
 by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> once this Flux completes.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#buffer-java.time.Duration-">buffer</a></span>(java.time.Duration&nbsp;bufferingTimespan)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted by
 the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> every <code>bufferingTimespan</code>.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-">buffer</a></span>(java.time.Duration&nbsp;bufferingTimespan,
      java.time.Duration&nbsp;openBufferEvery)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers created at a given
 <code>openBufferEvery</code> period.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-reactor.core.scheduler.Scheduler-">buffer</a></span>(java.time.Duration&nbsp;bufferingTimespan,
      java.time.Duration&nbsp;openBufferEvery,
      <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers created at a given
 <code>openBufferEvery</code> period, as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#buffer-java.time.Duration-reactor.core.scheduler.Scheduler-">buffer</a></span>(java.time.Duration&nbsp;bufferingTimespan,
      <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted by
 the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> every <code>bufferingTimespan</code>, as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#buffer-int-">buffer</a></span>(int&nbsp;maxSize)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted
 by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given max size is reached or once this
 Flux completes.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#buffer-int-int-">buffer</a></span>(int&nbsp;maxSize,
      int&nbsp;skip)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted
 by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given max size is reached or once this
 Flux completes.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>&lt;C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#buffer-int-int-java.util.function.Supplier-">buffer</a></span>(int&nbsp;maxSize,
      int&nbsp;skip,
      java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</code>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers that
 will be emitted by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given max size is reached
 or once this Flux completes.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>&lt;C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#buffer-int-java.util.function.Supplier-">buffer</a></span>(int&nbsp;maxSize,
      java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</code>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers that
 will be emitted by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given max size is reached
 or once this Flux completes.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#buffer-org.reactivestreams.Publisher-">buffer</a></span>(org.reactivestreams.Publisher&lt;?&gt;&nbsp;other)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers, as delimited by the
 signals of a companion <code>Publisher</code> this operator will subscribe to.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>&lt;C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#buffer-org.reactivestreams.Publisher-java.util.function.Supplier-">buffer</a></span>(org.reactivestreams.Publisher&lt;?&gt;&nbsp;other,
      java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</code>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers, as
 delimited by the signals of a companion <code>Publisher</code> this operator will
 subscribe to.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferTimeout-int-java.time.Duration-">bufferTimeout</a></span>(int&nbsp;maxSize,
             java.time.Duration&nbsp;maxTime)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted
 by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the buffer reaches a maximum size OR the
 maxTime <code>Duration</code> elapses.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferTimeout-int-java.time.Duration-reactor.core.scheduler.Scheduler-">bufferTimeout</a></span>(int&nbsp;maxSize,
             java.time.Duration&nbsp;maxTime,
             <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted
 by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the buffer reaches a maximum size OR the
 maxTime <code>Duration</code> elapses, as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>&lt;C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferTimeout-int-java.time.Duration-reactor.core.scheduler.Scheduler-java.util.function.Supplier-">bufferTimeout</a></span>(int&nbsp;maxSize,
             java.time.Duration&nbsp;maxTime,
             <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer,
             java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</code>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers that
 will be emitted by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the buffer reaches a maximum
 size OR the maxTime <code>Duration</code> elapses, as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>&lt;C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferTimeout-int-java.time.Duration-java.util.function.Supplier-">bufferTimeout</a></span>(int&nbsp;maxSize,
             java.time.Duration&nbsp;maxTime,
             java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</code>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers that
 will be emitted by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the buffer reaches a maximum
 size OR the maxTime <code>Duration</code> elapses.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-">bufferUntil</a></span>(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted by
 the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given predicate returns true.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-boolean-">bufferUntil</a></span>(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate,
           boolean&nbsp;cutBefore)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted by
 the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given predicate returns true.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferUntilChanged--">bufferUntilChanged</a></span>()</code>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another) into multiple <code>List</code> buffers that will be emitted by the
 resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferUntilChanged-java.util.function.Function-">bufferUntilChanged</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector)</code>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another), as compared by a key extracted through the user provided <code>Function</code>, into multiple <code>List</code> buffers that will be emitted by the
 resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferUntilChanged-java.util.function.Function-java.util.function.BiPredicate-">bufferUntilChanged</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector,
                  java.util.function.BiPredicate&lt;? super V,? super V&gt;&nbsp;keyComparator)</code>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another), as compared by a key extracted through the user provided <code>Function</code> and compared using a supplied <code>BiPredicate</code>, into multiple
 <code>List</code> buffers that will be emitted by the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>&lt;U,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferWhen-org.reactivestreams.Publisher-java.util.function.Function-">bufferWhen</a></span>(org.reactivestreams.Publisher&lt;U&gt;&nbsp;bucketOpening,
          java.util.function.Function&lt;? super U,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;closeSelector)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers started each time an opening
 companion <code>Publisher</code> emits.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>&lt;U,V,C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Supplier-">bufferWhen</a></span>(org.reactivestreams.Publisher&lt;U&gt;&nbsp;bucketOpening,
          java.util.function.Function&lt;? super U,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;closeSelector,
          java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</code>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers started each time an opening
 companion <code>Publisher</code> emits.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#bufferWhile-java.util.function.Predicate-">bufferWhile</a></span>(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate)</code>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted by
 the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#cache--">cache</a></span>()</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#cache-java.time.Duration-">cache</a></span>(java.time.Duration&nbsp;ttl)</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further
 <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#cache-java.time.Duration-reactor.core.scheduler.Scheduler-">cache</a></span>(java.time.Duration&nbsp;ttl,
     <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further
 <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#cache-int-">cache</a></span>(int&nbsp;history)</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#cache-int-java.time.Duration-">cache</a></span>(int&nbsp;history,
     java.time.Duration&nbsp;ttl)</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further
 <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#cache-int-java.time.Duration-reactor.core.scheduler.Scheduler-">cache</a></span>(int&nbsp;history,
     java.time.Duration&nbsp;ttl,
     <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further
 <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#cancelOn-reactor.core.scheduler.Scheduler-">cancelOn</a></span>(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</code>
<div class="block">Prepare this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> so that subscribers will cancel from it on a
 specified
 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>&lt;E&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#cast-java.lang.Class-">cast</a></span>(java.lang.Class&lt;E&gt;&nbsp;clazz)</code>
<div class="block">Cast the current <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> produced type into a target produced type.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#checkpoint--">checkpoint</a></span>()</code>
<div class="block">Activate traceback (full assembly tracing) for this particular <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, in case of an error
 upstream of the checkpoint.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#checkpoint-java.lang.String-">checkpoint</a></span>(java.lang.String&nbsp;description)</code>
<div class="block">Activate traceback (assembly marker) for this particular <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by giving it a description that
 will be reflected in the assembly traceback in case of an error upstream of the
 checkpoint.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#checkpoint-java.lang.String-boolean-">checkpoint</a></span>(java.lang.String&nbsp;description,
          boolean&nbsp;forceStackTrace)</code>
<div class="block">Activate traceback (full assembly tracing or the lighter assembly marking depending on the
 <code>forceStackTrace</code> option).</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>&lt;R,A&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#collect-java.util.stream.Collector-">collect</a></span>(java.util.stream.Collector&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,A,? extends R&gt;&nbsp;collector)</code>
<div class="block">Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a container,
 by applying a Java 8 Stream API <code>Collector</code>
 The collected result will be emitted when this sequence completes, emitting
 the empty container if the sequence was empty.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>&lt;E&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;E&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-">collect</a></span>(java.util.function.Supplier&lt;E&gt;&nbsp;containerSupplier,
       java.util.function.BiConsumer&lt;E,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;collector)</code>
<div class="block">自定义收集
 
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a user-defined container,
 by applying a collector <code>BiConsumer</code> taking the container and each element.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#collectList--">collectList</a></span>()</code>
<div class="block">收集Flux发布的元素到List中
 
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a <code>List</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>List</code> if the sequence was empty.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>&lt;K&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#collectMap-java.util.function.Function-">collectMap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor)</code>
<div class="block">收集Flux发布的元素到Map中，自定义Key,Value为原值.允许<a href="../../../reactor/core/publisher/Flux.html#empty--"><code>empty()</code></a>
 
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hashed <code>Map</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>Map</code> if the sequence was empty.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,V&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#collectMap-java.util.function.Function-java.util.function.Function-">collectMap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor,
          java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueExtractor)</code>
<div class="block">Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hashed <code>Map</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>Map</code> if the sequence was empty.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,V&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#collectMap-java.util.function.Function-java.util.function.Function-java.util.function.Supplier-">collectMap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor,
          java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueExtractor,
          java.util.function.Supplier&lt;java.util.Map&lt;K,V&gt;&gt;&nbsp;mapSupplier)</code>
<div class="block">Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a user-defined <code>Map</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>Map</code> if the sequence was empty.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>&lt;K&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,java.util.Collection&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#collectMultimap-java.util.function.Function-">collectMultimap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor)</code>
<div class="block">分组，类似Java Stream 的 groupBy，兼容 <a href="../../../reactor/core/publisher/Flux.html#empty--"><code>empty()</code></a>
 
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a <code>multimap</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>multimap</code> if the sequence was empty.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#collectMultimap-java.util.function.Function-java.util.function.Function-">collectMultimap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor,
               java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueExtractor)</code>
<div class="block">Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a <code>multimap</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>multimap</code> if the sequence was empty.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#collectMultimap-java.util.function.Function-java.util.function.Function-java.util.function.Supplier-">collectMultimap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor,
               java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueExtractor,
               java.util.function.Supplier&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;&nbsp;mapSupplier)</code>
<div class="block">Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a user-defined <code>multimap</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>multimap</code> if the sequence was empty.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#collectSortedList--">collectSortedList</a></span>()</code>
<div class="block">收集元素到集合并正序排序
 
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until this sequence completes,
 and then sort them in natural order into a <code>List</code> that is emitted by the
 resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#collectSortedList-java.util.Comparator-">collectSortedList</a></span>(java.util.Comparator&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;comparator)</code>
<div class="block">收集元素到集合，自定义排序
 
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until this sequence completes,
 and then sort them using a <code>Comparator</code> into a <code>List</code> that is emitted
 by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code>static &lt;T,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#combineLatest-java.util.function.Function-int-org.reactivestreams.Publisher...-">combineLatest</a></span>(java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator,
             int&nbsp;prefetch,
             org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of the <code>Publisher</code> sources.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>static &lt;T,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#combineLatest-java.util.function.Function-org.reactivestreams.Publisher...-">combineLatest</a></span>(java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator,
             org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of the <code>Publisher</code> sources.</div>
</td>
</tr>
<tr id="i54" class="altColor">
<td class="colFirst"><code>static &lt;T,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#combineLatest-java.lang.Iterable-java.util.function.Function-">combineLatest</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
             java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</code>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each
 of the <code>Publisher</code> sources provided in an <code>Iterable</code>.</div>
</td>
</tr>
<tr id="i55" class="rowColor">
<td class="colFirst"><code>static &lt;T,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#combineLatest-java.lang.Iterable-int-java.util.function.Function-">combineLatest</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
             int&nbsp;prefetch,
             java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</code>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each
 of the <code>Publisher</code> sources provided in an <code>Iterable</code>.</div>
</td>
</tr>
<tr id="i56" class="altColor">
<td class="colFirst"><code>static &lt;T1,T2,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#combineLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.BiFunction-">combineLatest</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
             org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
             java.util.function.BiFunction&lt;? super T1,? super T2,? extends V&gt;&nbsp;combinator)</code>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of two <code>Publisher</code> sources.</div>
</td>
</tr>
<tr id="i57" class="rowColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,V&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#combineLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.Function-">combineLatest</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
             org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
             org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
             java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</code>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of three <code>Publisher</code> sources.</div>
</td>
</tr>
<tr id="i58" class="altColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,T4,V&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#combineLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.Function-">combineLatest</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
             org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
             org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
             org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
             java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</code>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of four <code>Publisher</code> sources.</div>
</td>
</tr>
<tr id="i59" class="rowColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,T4,T5,V&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#combineLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.Function-">combineLatest</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
             org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
             org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
             org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
             org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5,
             java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</code>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of five <code>Publisher</code> sources.</div>
</td>
</tr>
<tr id="i60" class="altColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,T4,T5,T6,V&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#combineLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.Function-">combineLatest</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
             org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
             org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
             org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
             org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5,
             org.reactivestreams.Publisher&lt;? extends T6&gt;&nbsp;source6,
             java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</code>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of six <code>Publisher</code> sources.</div>
</td>
</tr>
<tr id="i61" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concat-java.lang.Iterable-">concat</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources)</code>
<div class="block">Concatenate all sources provided in an <code>Iterable</code>, forwarding elements
 emitted by the sources downstream.</div>
</td>
</tr>
<tr id="i62" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher-">concat</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources)</code>
<div class="block">Concatenate all sources emitted as an onNext signal from a parent <code>Publisher</code>,
 forwarding elements emitted by the sources downstream.</div>
</td>
</tr>
<tr id="i63" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher-int-">concat</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
      int&nbsp;prefetch)</code>
<div class="block">Concatenate all sources emitted as an onNext signal from a parent <code>Publisher</code>,
 forwarding elements emitted by the sources downstream.</div>
</td>
</tr>
<tr id="i64" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher...-">concat</a></span>(org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Concatenate all sources provided as a vararg, forwarding elements emitted by the
 sources downstream.</div>
</td>
</tr>
<tr id="i65" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatDelayError-org.reactivestreams.Publisher-">concatDelayError</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources)</code>
<div class="block">Concatenate all sources emitted as an onNext signal from a parent <code>Publisher</code>,
 forwarding elements emitted by the sources downstream.</div>
</td>
</tr>
<tr id="i66" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatDelayError-org.reactivestreams.Publisher-boolean-int-">concatDelayError</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                boolean&nbsp;delayUntilEnd,
                int&nbsp;prefetch)</code>
<div class="block">Concatenate all sources emitted as an onNext signal from a parent <code>Publisher</code>,
 forwarding elements emitted by the sources downstream.</div>
</td>
</tr>
<tr id="i67" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatDelayError-org.reactivestreams.Publisher-int-">concatDelayError</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                int&nbsp;prefetch)</code>
<div class="block">Concatenate all sources emitted as an onNext signal from a parent <code>Publisher</code>,
 forwarding elements emitted by the sources downstream.</div>
</td>
</tr>
<tr id="i68" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatDelayError-org.reactivestreams.Publisher...-">concatDelayError</a></span>(org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Concatenate all sources provided as a vararg, forwarding elements emitted by the
 sources downstream.</div>
</td>
</tr>
<tr id="i69" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-">concatMap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, sequentially and
 preserving order using concatenation.</div>
</td>
</tr>
<tr id="i70" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-int-">concatMap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
         int&nbsp;prefetch)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, sequentially and
 preserving order using concatenation.</div>
</td>
</tr>
<tr id="i71" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatMapDelayError-java.util.function.Function-">concatMapDelayError</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, sequentially and
 preserving order using concatenation.</div>
</td>
</tr>
<tr id="i72" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatMapDelayError-java.util.function.Function-boolean-int-">concatMapDelayError</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
                   boolean&nbsp;delayUntilEnd,
                   int&nbsp;prefetch)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, sequentially and
 preserving order using concatenation.</div>
</td>
</tr>
<tr id="i73" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatMapDelayError-java.util.function.Function-int-">concatMapDelayError</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
                   int&nbsp;prefetch)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, sequentially and
 preserving order using concatenation.</div>
</td>
</tr>
<tr id="i74" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatMapIterable-java.util.function.Function-">concatMapIterable</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;mapper)</code>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <code>Iterable</code>, then flatten the elements from those by
 concatenating them into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i75" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatMapIterable-java.util.function.Function-int-">concatMapIterable</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;mapper,
                 int&nbsp;prefetch)</code>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <code>Iterable</code>, then flatten the emissions from those by
 concatenating them into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i76" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatWith-org.reactivestreams.Publisher-">concatWith</a></span>(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;other)</code>
<div class="block">Concatenate emissions of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the provided <code>Publisher</code> (no interleave).</div>
</td>
</tr>
<tr id="i77" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#concatWithValues-T...-">concatWithValues</a></span>(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>...&nbsp;values)</code>
<div class="block">Concatenates the values to the end of the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 
 <img class="marble" src="doc-files/marbles/concatWithValues.svg" alt=""></div>
</td>
</tr>
<tr id="i78" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#contextCapture--">contextCapture</a></span>()</code>
<div class="block">If <a href="https://github.com/micrometer-metrics/context-propagation">context-propagation library</a>
 is on the classpath, this is a convenience shortcut to capture thread local values during the
 subscription phase and put them in the <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> that is visible upstream of this operator.</div>
</td>
</tr>
<tr id="i79" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#contextWrite-reactor.util.context.ContextView-">contextWrite</a></span>(<a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口">ContextView</a>&nbsp;contextToAppend)</code>
<div class="block">Enrich the <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> visible from downstream for the benefit of upstream
 operators, by making all values from the provided <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a> visible on top
 of pairs from downstream.</div>
</td>
</tr>
<tr id="i80" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#contextWrite-java.util.function.Function-">contextWrite</a></span>(java.util.function.Function&lt;<a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口">Context</a>,<a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口">Context</a>&gt;&nbsp;contextModifier)</code>
<div class="block">Enrich the <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> visible from downstream for the benefit of upstream
 operators, by applying a <code>Function</code> to the downstream <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a>.</div>
</td>
</tr>
<tr id="i81" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#count--">count</a></span>()</code>
<div class="block">统计元素个数，当观察到 onComplete 时返回统计数
 
 Counts the number of values in this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i82" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#create-java.util.function.Consumer-">create</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口">FluxSink</a>&lt;T&gt;&gt;&nbsp;emitter)</code>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the capability of emitting multiple
 elements in a synchronous or asynchronous manner through the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> API.</div>
</td>
</tr>
<tr id="i83" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#create-java.util.function.Consumer-reactor.core.publisher.FluxSink.OverflowStrategy-">create</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口">FluxSink</a>&lt;T&gt;&gt;&nbsp;emitter,
      <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html" title="reactor.core.publisher中的枚举">FluxSink.OverflowStrategy</a>&nbsp;backpressure)</code>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the capability of emitting multiple
 elements in a synchronous or asynchronous manner through the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> API.</div>
</td>
</tr>
<tr id="i84" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#defaultIfEmpty-T-">defaultIfEmpty</a></span>(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;defaultV)</code>
<div class="block">Provide a default unique value if this sequence is completed without any data
 
 <img class="marble" src="doc-files/marbles/defaultIfEmpty.svg" alt=""></div>
</td>
</tr>
<tr id="i85" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-">defer</a></span>(java.util.function.Supplier&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;supplier)</code>
<div class="block">Lazily supply a <code>Publisher</code> every time a <code>Subscription</code> is made on the
 resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, so the actual source instantiation is deferred until each
 subscribe and the <code>Supplier</code> can create a subscriber-specific instance.</div>
</td>
</tr>
<tr id="i86" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#deferContextual-java.util.function.Function-">deferContextual</a></span>(java.util.function.Function&lt;<a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口">ContextView</a>,? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;contextualPublisherFactory)</code>
<div class="block">Lazily supply a <code>Publisher</code> every time a <code>Subscription</code> is made on the
 resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, so the actual source instantiation is deferred until each
 subscribe and the <code>Function</code> can create a subscriber-specific instance.</div>
</td>
</tr>
<tr id="i87" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#delayElements-java.time.Duration-">delayElements</a></span>(java.time.Duration&nbsp;delay)</code>
<div class="block">Delay each of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> elements (<code>Subscriber.onNext(T)</code> signals)
 by a given <code>Duration</code>.</div>
</td>
</tr>
<tr id="i88" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#delayElements-java.time.Duration-reactor.core.scheduler.Scheduler-">delayElements</a></span>(java.time.Duration&nbsp;delay,
             <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Delay each of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> elements (<code>Subscriber.onNext(T)</code> signals)
 by a given <code>Duration</code>.</div>
</td>
</tr>
<tr id="i89" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#delaySequence-java.time.Duration-">delaySequence</a></span>(java.time.Duration&nbsp;delay)</code>
<div class="block">Shift this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> forward in time by a given <code>Duration</code>.</div>
</td>
</tr>
<tr id="i90" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#delaySequence-java.time.Duration-reactor.core.scheduler.Scheduler-">delaySequence</a></span>(java.time.Duration&nbsp;delay,
             <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Shift this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> forward in time by a given <code>Duration</code>.</div>
</td>
</tr>
<tr id="i91" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#delaySubscription-java.time.Duration-">delaySubscription</a></span>(java.time.Duration&nbsp;delay)</code>
<div class="block">Delay the <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscription</code></a> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> source until the given
 period elapses.</div>
</td>
</tr>
<tr id="i92" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#delaySubscription-java.time.Duration-reactor.core.scheduler.Scheduler-">delaySubscription</a></span>(java.time.Duration&nbsp;delay,
                 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Delay the <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscription</code></a> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> source until the given
 period elapses, as measured on the user-provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i93" class="rowColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#delaySubscription-org.reactivestreams.Publisher-">delaySubscription</a></span>(org.reactivestreams.Publisher&lt;U&gt;&nbsp;subscriptionDelay)</code>
<div class="block">Delay the <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscription</code></a> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 source until another <code>Publisher</code> signals a value or completes.</div>
</td>
</tr>
<tr id="i94" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#delayUntil-java.util.function.Function-">delayUntil</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;triggerProvider)</code>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and generate a <code>Publisher</code> from each of this
 Flux elements, each acting as a trigger for relaying said element.</div>
</td>
</tr>
<tr id="i95" class="rowColor">
<td class="colFirst"><code>&lt;X&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;X&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#dematerialize--">dematerialize</a></span>()</code>
<div class="block">An operator working only if this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emits onNext, onError or onComplete <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a>
 instances, transforming these <a href="../../../reactor/core/publisher/Flux.html#materialize--"><code>materialized</code></a> signals into
 real signals on the <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i96" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#distinct--">distinct</a></span>()</code>
<div class="block">For each <code>Subscriber</code>, track elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that have been
 seen and filter out duplicates.</div>
</td>
</tr>
<tr id="i97" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#distinct-java.util.function.Function-">distinct</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector)</code>
<div class="block">For each <code>Subscriber</code>, track elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that have been
 seen and filter out duplicates, as compared by a key extracted through the user
 provided <code>Function</code>.</div>
</td>
</tr>
<tr id="i98" class="altColor">
<td class="colFirst"><code>&lt;V,C extends java.util.Collection&lt;? super V&gt;&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#distinct-java.util.function.Function-java.util.function.Supplier-">distinct</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector,
        java.util.function.Supplier&lt;C&gt;&nbsp;distinctCollectionSupplier)</code>
<div class="block">For each <code>Subscriber</code>, track elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that have been
 seen and filter out duplicates, as compared by a key extracted through the user
 provided <code>Function</code> and by the <code>add method</code>
 of the <code>Collection</code> supplied (typically a <code>Set</code>).</div>
</td>
</tr>
<tr id="i99" class="rowColor">
<td class="colFirst"><code>&lt;V,C&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#distinct-java.util.function.Function-java.util.function.Supplier-java.util.function.BiPredicate-java.util.function.Consumer-">distinct</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector,
        java.util.function.Supplier&lt;C&gt;&nbsp;distinctStoreSupplier,
        java.util.function.BiPredicate&lt;C,V&gt;&nbsp;distinctPredicate,
        java.util.function.Consumer&lt;C&gt;&nbsp;cleanup)</code>
<div class="block">For each <code>Subscriber</code>, track elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that have been
 seen and filter out duplicates, as compared by applying a <code>BiPredicate</code> on
 an arbitrary user-supplied <code>&lt;C&gt;</code> store and a key extracted through the user
 provided <code>Function</code>.</div>
</td>
</tr>
<tr id="i100" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#distinctUntilChanged--">distinctUntilChanged</a></span>()</code>
<div class="block">Filter out subsequent repetitions of an element (that is, if they arrive right after
 one another).</div>
</td>
</tr>
<tr id="i101" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#distinctUntilChanged-java.util.function.Function-">distinctUntilChanged</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector)</code>
<div class="block">Filter out subsequent repetitions of an element (that is, if they arrive right after
 one another), as compared by a key extracted through the user provided <code>Function</code>
 using equality.</div>
</td>
</tr>
<tr id="i102" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#distinctUntilChanged-java.util.function.Function-java.util.function.BiPredicate-">distinctUntilChanged</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector,
                    java.util.function.BiPredicate&lt;? super V,? super V&gt;&nbsp;keyComparator)</code>
<div class="block">Filter out subsequent repetitions of an element (that is, if they arrive right
 after one another), as compared by a key extracted through the user provided <code>Function</code> and then comparing keys with the supplied <code>BiPredicate</code>.</div>
</td>
</tr>
<tr id="i103" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doAfterTerminate-java.lang.Runnable-">doAfterTerminate</a></span>(java.lang.Runnable&nbsp;afterTerminate)</code>
<div class="block">Add behavior (side-effect) triggered after the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> terminates, either by completing downstream successfully or with an error.</div>
</td>
</tr>
<tr id="i104" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-">doFinally</a></span>(java.util.function.Consumer&lt;<a href="../../../reactor/core/publisher/SignalType.html" title="reactor.core.publisher中的枚举">SignalType</a>&gt;&nbsp;onFinally)</code>
<div class="block">Add behavior (side-effect) triggered <strong>after</strong> the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> terminates for any reason,
 including cancellation.</div>
</td>
</tr>
<tr id="i105" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doFirst-java.lang.Runnable-">doFirst</a></span>(java.lang.Runnable&nbsp;onFirst)</code>
<div class="block">Add behavior (side-effect) triggered <strong>before</strong> the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is
 <strong>subscribed to</strong>, which should be the first event after assembly time.</div>
</td>
</tr>
<tr id="i106" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doOnCancel-java.lang.Runnable-">doOnCancel</a></span>(java.lang.Runnable&nbsp;onCancel)</code>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is cancelled.</div>
</td>
</tr>
<tr id="i107" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doOnComplete-java.lang.Runnable-">doOnComplete</a></span>(java.lang.Runnable&nbsp;onComplete)</code>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes successfully.</div>
</td>
</tr>
<tr id="i108" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doOnDiscard-java.lang.Class-java.util.function.Consumer-">doOnDiscard</a></span>(java.lang.Class&lt;R&gt;&nbsp;type,
           java.util.function.Consumer&lt;? super R&gt;&nbsp;discardHook)</code>
<div class="block">Potentially modify the behavior of the <i>whole chain</i> of operators upstream of this one to
 conditionally clean up elements that get <i>discarded</i> by these operators.</div>
</td>
</tr>
<tr id="i109" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-">doOnEach</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口">Signal</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;signalConsumer)</code>
<div class="block">Add behavior (side-effects) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emits an item, fails with an error
 or completes successfully.</div>
</td>
</tr>
<tr id="i110" class="altColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doOnError-java.lang.Class-java.util.function.Consumer-">doOnError</a></span>(java.lang.Class&lt;E&gt;&nbsp;exceptionType,
         java.util.function.Consumer&lt;? super E&gt;&nbsp;onError)</code>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes with an error matching the given exception type.</div>
</td>
</tr>
<tr id="i111" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-">doOnError</a></span>(java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;onError)</code>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes with an error.</div>
</td>
</tr>
<tr id="i112" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doOnError-java.util.function.Predicate-java.util.function.Consumer-">doOnError</a></span>(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
         java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;onError)</code>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes with an error matching the given exception.</div>
</td>
</tr>
<tr id="i113" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-">doOnNext</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onNext)</code>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emits an item.</div>
</td>
</tr>
<tr id="i114" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doOnRequest-java.util.function.LongConsumer-">doOnRequest</a></span>(java.util.function.LongConsumer&nbsp;consumer)</code>
<div class="block">Add behavior (side-effect) triggering a <code>LongConsumer</code> when this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 receives any request.</div>
</td>
</tr>
<tr id="i115" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doOnSubscribe-java.util.function.Consumer-">doOnSubscribe</a></span>(java.util.function.Consumer&lt;? super org.reactivestreams.Subscription&gt;&nbsp;onSubscribe)</code>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is being subscribed,
 that is to say when a <code>Subscription</code> has been produced by the <code>Publisher</code>
 and is being passed to the <code>Subscriber.onSubscribe(Subscription)</code>.</div>
</td>
</tr>
<tr id="i116" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#doOnTerminate-java.lang.Runnable-">doOnTerminate</a></span>(java.lang.Runnable&nbsp;onTerminate)</code>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> terminates, either by
 completing successfully or failing with an error.</div>
</td>
</tr>
<tr id="i117" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;java.lang.Long,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#elapsed--">elapsed</a></span>()</code>
<div class="block">Map this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2&lt;Long, T&gt;</code></a>
 of timemillis and source data.</div>
</td>
</tr>
<tr id="i118" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;java.lang.Long,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#elapsed-reactor.core.scheduler.Scheduler-">elapsed</a></span>(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</code>
<div class="block">Map this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2&lt;Long, T&gt;</code></a>
 of timemillis and source data.</div>
</td>
</tr>
<tr id="i119" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#elementAt-int-">elementAt</a></span>(int&nbsp;index)</code>
<div class="block">丢弃操作，丢弃指定下标之前的元素并返回指定下标的元素
 
 Emit only the element at the given index position or <code>IndexOutOfBoundsException</code>
 if the sequence is shorter.</div>
</td>
</tr>
<tr id="i120" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#elementAt-int-T-">elementAt</a></span>(int&nbsp;index,
         <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;defaultValue)</code>
<div class="block">Emit only the element at the given index position or fall back to a
 default value if the sequence is shorter.</div>
</td>
</tr>
<tr id="i121" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#empty--">empty</a></span>()</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that completes without emitting any item.</div>
</td>
</tr>
<tr id="i122" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#error-java.util.function.Supplier-">error</a></span>(java.util.function.Supplier&lt;? extends java.lang.Throwable&gt;&nbsp;errorSupplier)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that terminates with an error immediately after being
 subscribed to.</div>
</td>
</tr>
<tr id="i123" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#error-java.lang.Throwable-">error</a></span>(java.lang.Throwable&nbsp;error)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that terminates with the specified error immediately after
 being subscribed to.</div>
</td>
</tr>
<tr id="i124" class="altColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#error-java.lang.Throwable-boolean-">error</a></span>(java.lang.Throwable&nbsp;throwable,
     boolean&nbsp;whenRequested)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that terminates with the specified error, either immediately
 after being subscribed to or after being first requested.</div>
</td>
</tr>
<tr id="i125" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#expand-java.util.function.Function-">expand</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;expander)</code>
<div class="block">Recursively expand elements into a graph and emit all the resulting element using
 a breadth-first traversal strategy.</div>
</td>
</tr>
<tr id="i126" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#expand-java.util.function.Function-int-">expand</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;expander,
      int&nbsp;capacityHint)</code>
<div class="block">Recursively expand elements into a graph and emit all the resulting element using
 a breadth-first traversal strategy.</div>
</td>
</tr>
<tr id="i127" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#expandDeep-java.util.function.Function-">expandDeep</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;expander)</code>
<div class="block">Recursively expand elements into a graph and emit all the resulting element,
 in a depth-first traversal order.</div>
</td>
</tr>
<tr id="i128" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#expandDeep-java.util.function.Function-int-">expandDeep</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;expander,
          int&nbsp;capacityHint)</code>
<div class="block">Recursively expand elements into a graph and emit all the resulting element,
 in a depth-first traversal order.</div>
</td>
</tr>
<tr id="i129" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#filter-java.util.function.Predicate-">filter</a></span>(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;p)</code>
<div class="block">Evaluate each source value against the given <code>Predicate</code>.</div>
</td>
</tr>
<tr id="i130" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#filterWhen-java.util.function.Function-">filterWhen</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;java.lang.Boolean&gt;&gt;&nbsp;asyncPredicate)</code>
<div class="block">Test each value emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously using a generated
 <code>Publisher&lt;Boolean&gt;</code> test.</div>
</td>
</tr>
<tr id="i131" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#filterWhen-java.util.function.Function-int-">filterWhen</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;java.lang.Boolean&gt;&gt;&nbsp;asyncPredicate,
          int&nbsp;bufferSize)</code>
<div class="block">Test each value emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously using a generated
 <code>Publisher&lt;Boolean&gt;</code> test.</div>
</td>
</tr>
<tr id="i132" class="altColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#first-java.lang.Iterable-">first</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources)</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../reactor/core/publisher/Flux.html#firstWithSignal-java.lang.Iterable-"><code>firstWithSignal(Iterable)</code></a>. To be removed in reactor 3.5.</span></div>
</div>
</td>
</tr>
<tr id="i133" class="rowColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#first-org.reactivestreams.Publisher...-">first</a></span>(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../reactor/core/publisher/Flux.html#firstWithSignal-org.reactivestreams.Publisher...-"><code>firstWithSignal(Publisher[])</code></a>. To be removed in reactor 3.5.</span></div>
</div>
</td>
</tr>
<tr id="i134" class="altColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#firstWithSignal-java.lang.Iterable-">firstWithSignal</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources)</code>
<div class="block">Pick the first <code>Publisher</code> to emit any signal (onNext/onError/onComplete) and
 replay all signals from that <code>Publisher</code>, effectively behaving like the
 fastest of these competing sources.</div>
</td>
</tr>
<tr id="i135" class="rowColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#firstWithSignal-org.reactivestreams.Publisher...-">firstWithSignal</a></span>(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block">Pick the first <code>Publisher</code> to emit any signal (onNext/onError/onComplete) and
 replay all signals from that <code>Publisher</code>, effectively behaving like the
 fastest of these competing sources.</div>
</td>
</tr>
<tr id="i136" class="altColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#firstWithValue-java.lang.Iterable-">firstWithValue</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources)</code>
<div class="block">Pick the first <code>Publisher</code> to emit any value and replay all values
 from that <code>Publisher</code>, effectively behaving like the source that first
 emits an <code>onNext</code>.</div>
</td>
</tr>
<tr id="i137" class="rowColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#firstWithValue-org.reactivestreams.Publisher-org.reactivestreams.Publisher...-">firstWithValue</a></span>(org.reactivestreams.Publisher&lt;? extends I&gt;&nbsp;first,
              org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;others)</code>
<div class="block">Pick the first <code>Publisher</code> to emit any value and replay all values
 from that <code>Publisher</code>, effectively behaving like the source that first
 emits an <code>onNext</code>.</div>
</td>
</tr>
<tr id="i138" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-">flatMap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapper)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> through merging,
 which allow them to interleave.</div>
</td>
</tr>
<tr id="i139" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-java.util.function.Function-java.util.function.Supplier-">flatMap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapperOnNext,
       java.util.function.Function&lt;? super java.lang.Throwable,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapperOnError,
       java.util.function.Supplier&lt;? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapperOnComplete)</code>
<div class="block">Transform the signals emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> through merging,
 which allow them to interleave.</div>
</td>
</tr>
<tr id="i140" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-int-">flatMap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
       int&nbsp;concurrency)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> through merging,
 which allow them to interleave.</div>
</td>
</tr>
<tr id="i141" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-int-int-">flatMap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
       int&nbsp;concurrency,
       int&nbsp;prefetch)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> through merging,
 which allow them to interleave.</div>
</td>
</tr>
<tr id="i142" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#flatMapDelayError-java.util.function.Function-int-int-">flatMapDelayError</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
                 int&nbsp;concurrency,
                 int&nbsp;prefetch)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> through merging,
 which allow them to interleave.</div>
</td>
</tr>
<tr id="i143" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#flatMapIterable-java.util.function.Function-">flatMapIterable</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;mapper)</code>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <code>Iterable</code>, then flatten the elements from those by
 merging them into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i144" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#flatMapIterable-java.util.function.Function-int-">flatMapIterable</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;mapper,
               int&nbsp;prefetch)</code>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <code>Iterable</code>, then flatten the emissions from those by
 merging them into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i145" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-">flatMapSequential</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapper)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, but merge them in
 the order of their source element.</div>
</td>
</tr>
<tr id="i146" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-int-">flatMapSequential</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapper,
                 int&nbsp;maxConcurrency)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, but merge them in
 the order of their source element.</div>
</td>
</tr>
<tr id="i147" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-int-int-">flatMapSequential</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapper,
                 int&nbsp;maxConcurrency,
                 int&nbsp;prefetch)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, but merge them in
 the order of their source element.</div>
</td>
</tr>
<tr id="i148" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#flatMapSequentialDelayError-java.util.function.Function-int-int-">flatMapSequentialDelayError</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapper,
                           int&nbsp;maxConcurrency,
                           int&nbsp;prefetch)</code>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, but merge them in
 the order of their source element.</div>
</td>
</tr>
<tr id="i149" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#from-org.reactivestreams.Publisher-">from</a></span>(org.reactivestreams.Publisher&lt;? extends T&gt;&nbsp;source)</code>
<div class="block">Decorate the specified <code>Publisher</code> with the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> API.</div>
</td>
</tr>
<tr id="i150" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#fromArray-T:A-">fromArray</a></span>(T[]&nbsp;array)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits the items contained in the provided array.</div>
</td>
</tr>
<tr id="i151" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#fromIterable-java.lang.Iterable-">fromIterable</a></span>(java.lang.Iterable&lt;? extends T&gt;&nbsp;it)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits the items contained in the provided <code>Iterable</code>.</div>
</td>
</tr>
<tr id="i152" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#fromStream-java.util.stream.Stream-">fromStream</a></span>(java.util.stream.Stream&lt;? extends T&gt;&nbsp;s)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits the items contained in the provided <code>Stream</code>.</div>
</td>
</tr>
<tr id="i153" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#fromStream-java.util.function.Supplier-">fromStream</a></span>(java.util.function.Supplier&lt;java.util.stream.Stream&lt;? extends T&gt;&gt;&nbsp;streamSupplier)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits the items contained in a <code>Stream</code> created by
 the provided <code>Supplier</code> for each subscription.</div>
</td>
</tr>
<tr id="i154" class="altColor">
<td class="colFirst"><code>static &lt;T,S&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#generate-java.util.concurrent.Callable-java.util.function.BiFunction-">generate</a></span>(java.util.concurrent.Callable&lt;S&gt;&nbsp;stateSupplier,
        java.util.function.BiFunction&lt;S,<a href="../../../reactor/core/publisher/SynchronousSink.html" title="reactor.core.publisher中的接口">SynchronousSink</a>&lt;T&gt;,S&gt;&nbsp;generator)</code>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by generating signals one-by-one via a
 consumer callback and some state.</div>
</td>
</tr>
<tr id="i155" class="rowColor">
<td class="colFirst"><code>static &lt;T,S&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#generate-java.util.concurrent.Callable-java.util.function.BiFunction-java.util.function.Consumer-">generate</a></span>(java.util.concurrent.Callable&lt;S&gt;&nbsp;stateSupplier,
        java.util.function.BiFunction&lt;S,<a href="../../../reactor/core/publisher/SynchronousSink.html" title="reactor.core.publisher中的接口">SynchronousSink</a>&lt;T&gt;,S&gt;&nbsp;generator,
        java.util.function.Consumer&lt;? super S&gt;&nbsp;stateConsumer)</code>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by generating signals one-by-one via a
 consumer callback and some state, with a final cleanup callback.</div>
</td>
</tr>
<tr id="i156" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#generate-java.util.function.Consumer-">generate</a></span>(java.util.function.Consumer&lt;<a href="../../../reactor/core/publisher/SynchronousSink.html" title="reactor.core.publisher中的接口">SynchronousSink</a>&lt;T&gt;&gt;&nbsp;generator)</code>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by generating signals one-by-one via a
 consumer callback.</div>
</td>
</tr>
<tr id="i157" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#getPrefetch--">getPrefetch</a></span>()</code>
<div class="block">The prefetch configuration of the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></div>
</td>
</tr>
<tr id="i158" class="altColor">
<td class="colFirst"><code>&lt;K&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类">GroupedFlux</a>&lt;K,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#groupBy-java.util.function.Function-">groupBy</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyMapper)</code>
<div class="block">Divide this sequence into dynamically created <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> (or groups) for each
 unique key, as produced by the provided keyMapper <code>Function</code>.</div>
</td>
</tr>
<tr id="i159" class="rowColor">
<td class="colFirst"><code>&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类">GroupedFlux</a>&lt;K,V&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#groupBy-java.util.function.Function-java.util.function.Function-">groupBy</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyMapper,
       java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueMapper)</code>
<div class="block">Divide this sequence into dynamically created <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> (or groups) for each
 unique key, as produced by the provided keyMapper <code>Function</code>.</div>
</td>
</tr>
<tr id="i160" class="altColor">
<td class="colFirst"><code>&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类">GroupedFlux</a>&lt;K,V&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#groupBy-java.util.function.Function-java.util.function.Function-int-">groupBy</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyMapper,
       java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueMapper,
       int&nbsp;prefetch)</code>
<div class="block">Divide this sequence into dynamically created <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> (or groups) for each
 unique key, as produced by the provided keyMapper <code>Function</code>.</div>
</td>
</tr>
<tr id="i161" class="rowColor">
<td class="colFirst"><code>&lt;K&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类">GroupedFlux</a>&lt;K,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#groupBy-java.util.function.Function-int-">groupBy</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyMapper,
       int&nbsp;prefetch)</code>
<div class="block">Divide this sequence into dynamically created <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> (or groups) for each
 unique key, as produced by the provided keyMapper <code>Function</code>.</div>
</td>
</tr>
<tr id="i162" class="altColor">
<td class="colFirst"><code>&lt;TRight,TLeftEnd,TRightEnd,R&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#groupJoin-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-">groupJoin</a></span>(org.reactivestreams.Publisher&lt;? extends TRight&gt;&nbsp;other,
         java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;TLeftEnd&gt;&gt;&nbsp;leftEnd,
         java.util.function.Function&lt;? super TRight,? extends org.reactivestreams.Publisher&lt;TRightEnd&gt;&gt;&nbsp;rightEnd,
         java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;TRight&gt;,? extends R&gt;&nbsp;resultSelector)</code>
<div class="block">Map values from two Publishers into time windows and emit combination of values
 in case their windows overlap.</div>
</td>
</tr>
<tr id="i163" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#handle-java.util.function.BiConsumer-">handle</a></span>(java.util.function.BiConsumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,<a href="../../../reactor/core/publisher/SynchronousSink.html" title="reactor.core.publisher中的接口">SynchronousSink</a>&lt;R&gt;&gt;&nbsp;handler)</code>
<div class="block">Handle the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by calling a biconsumer with the
 output sink for each onNext.</div>
</td>
</tr>
<tr id="i164" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Boolean&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#hasElement-T-">hasElement</a></span>(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;value)</code>
<div class="block">Emit a single boolean true if any of the elements of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence is
 equal to the provided value.</div>
</td>
</tr>
<tr id="i165" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Boolean&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#hasElements--">hasElements</a></span>()</code>
<div class="block">Emit a single boolean true if this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence has at least one element.</div>
</td>
</tr>
<tr id="i166" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#hide--">hide</a></span>()</code>
<div class="block">Hides the identities of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> instance.</div>
</td>
</tr>
<tr id="i167" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#ignoreElements--">ignoreElements</a></span>()</code>
<div class="block">Ignores onNext signals (dropping them) and only propagate termination events.</div>
</td>
</tr>
<tr id="i168" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;java.lang.Long,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#index--">index</a></span>()</code>
<div class="block">Keep information about the order in which source values were received by
 indexing them with a 0-based incrementing long, returning a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 of <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2<(index, value)></code></a>.</div>
</td>
</tr>
<tr id="i169" class="rowColor">
<td class="colFirst"><code>&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#index-java.util.function.BiFunction-">index</a></span>(java.util.function.BiFunction&lt;? super java.lang.Long,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends I&gt;&nbsp;indexMapper)</code>
<div class="block">Keep information about the order in which source values were received by
 indexing them internally with a 0-based incrementing long then combining this
 information with the source value into a <code>I</code> using the provided <code>BiFunction</code>,
 returning a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux&lt;I&gt;</code></a>.</div>
</td>
</tr>
<tr id="i170" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#interval-java.time.Duration-">interval</a></span>(java.time.Duration&nbsp;period)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits long values starting with 0 and incrementing at
 specified time intervals on the global timer.</div>
</td>
</tr>
<tr id="i171" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#interval-java.time.Duration-java.time.Duration-">interval</a></span>(java.time.Duration&nbsp;delay,
        java.time.Duration&nbsp;period)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits long values starting with 0 and incrementing at
 specified time intervals, after an initial delay, on the global timer.</div>
</td>
</tr>
<tr id="i172" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#interval-java.time.Duration-java.time.Duration-reactor.core.scheduler.Scheduler-">interval</a></span>(java.time.Duration&nbsp;delay,
        java.time.Duration&nbsp;period,
        <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits long values starting with 0 and incrementing at
 specified time intervals, after an initial delay, on the specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i173" class="rowColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Long&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#interval-java.time.Duration-reactor.core.scheduler.Scheduler-">interval</a></span>(java.time.Duration&nbsp;period,
        <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits long values starting with 0 and incrementing at
 specified time intervals, on the specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i174" class="altColor">
<td class="colFirst"><code>&lt;TRight,TLeftEnd,TRightEnd,R&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#join-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-">join</a></span>(org.reactivestreams.Publisher&lt;? extends TRight&gt;&nbsp;other,
    java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;TLeftEnd&gt;&gt;&nbsp;leftEnd,
    java.util.function.Function&lt;? super TRight,? extends org.reactivestreams.Publisher&lt;TRightEnd&gt;&gt;&nbsp;rightEnd,
    java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super TRight,? extends R&gt;&nbsp;resultSelector)</code>
<div class="block">Combine values from two Publishers in case their windows overlap.</div>
</td>
</tr>
<tr id="i175" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#just-T...-">just</a></span>(T...&nbsp;data)</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits the provided elements and then completes.</div>
</td>
</tr>
<tr id="i176" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#just-T-">just</a></span>(T&nbsp;data)</code>
<div class="block">Create a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will only emit a single element then onComplete.</div>
</td>
</tr>
<tr id="i177" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#last--">last</a></span>()</code>
<div class="block">获取序列最后一个元素，如果序列为空抛出 <code>NoSuchElementException</code>
 
 Emit the last element observed before complete signal as a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>, or emit
 <code>NoSuchElementException</code> error if the source was empty.</div>
</td>
</tr>
<tr id="i178" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#last-T-">last</a></span>(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;defaultValue)</code>
<div class="block">Emit the last element observed before complete signal as a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>, or emit
 the <code>defaultValue</code> if the source was empty.</div>
</td>
</tr>
<tr id="i179" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#limitRate-int-">limitRate</a></span>(int&nbsp;prefetchRate)</code>
<div class="block">Ensure that backpressure signals from downstream subscribers are split into batches
 capped at the provided <code>prefetchRate</code> when propagated upstream, effectively
 rate limiting the upstream <code>Publisher</code>.</div>
</td>
</tr>
<tr id="i180" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#limitRate-int-int-">limitRate</a></span>(int&nbsp;highTide,
         int&nbsp;lowTide)</code>
<div class="block">Ensure that backpressure signals from downstream subscribers are split into batches
 capped at the provided <code>highTide</code> first, then replenishing at the provided
 <code>lowTide</code>, effectively rate limiting the upstream <code>Publisher</code>.</div>
</td>
</tr>
<tr id="i181" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#limitRequest-long-">limitRequest</a></span>(long&nbsp;n)</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">replace with <a href="../../../reactor/core/publisher/Flux.html#take-long-boolean-"><code>take(n, true)</code></a> in 3.4.x, then <a href="../../../reactor/core/publisher/Flux.html#take-long-"><code>take(long)</code></a> in 3.5.0.
 To be removed in 3.6.0 at the earliest. See https://github.com/reactor/reactor-core/issues/2339</span></div>
</div>
</td>
</tr>
<tr id="i182" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#log--">log</a></span>()</code>
<div class="block">Observe all Reactive Streams signals and trace them using <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a> support.</div>
</td>
</tr>
<tr id="i183" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#log-reactor.util.Logger-">log</a></span>(<a href="../../../reactor/util/Logger.html" title="reactor.util中的接口">Logger</a>&nbsp;logger)</code>
<div class="block">Observe Reactive Streams signals matching the passed filter <code>options</code> and
 trace them using a specific user-provided <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a>, at <code>Level.INFO</code> level.</div>
</td>
</tr>
<tr id="i184" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#log-reactor.util.Logger-java.util.logging.Level-boolean-reactor.core.publisher.SignalType...-">log</a></span>(<a href="../../../reactor/util/Logger.html" title="reactor.util中的接口">Logger</a>&nbsp;logger,
   java.util.logging.Level&nbsp;level,
   boolean&nbsp;showOperatorLine,
   <a href="../../../reactor/core/publisher/SignalType.html" title="reactor.core.publisher中的枚举">SignalType</a>...&nbsp;options)</code>
<div class="block">Observe Reactive Streams signals matching the passed filter <code>options</code> and
 trace them using a specific user-provided <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a>, at the given <code>Level</code>.</div>
</td>
</tr>
<tr id="i185" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#log-java.lang.String-">log</a></span>(java.lang.String&nbsp;category)</code>
<div class="block">Observe all Reactive Streams signals and trace them using <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a> support.</div>
</td>
</tr>
<tr id="i186" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#log-java.lang.String-java.util.logging.Level-boolean-reactor.core.publisher.SignalType...-">log</a></span>(java.lang.String&nbsp;category,
   java.util.logging.Level&nbsp;level,
   boolean&nbsp;showOperatorLine,
   <a href="../../../reactor/core/publisher/SignalType.html" title="reactor.core.publisher中的枚举">SignalType</a>...&nbsp;options)</code>
<div class="block">Observe Reactive Streams signals matching the passed filter <code>options</code> and
 trace them using <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a> support.</div>
</td>
</tr>
<tr id="i187" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#log-java.lang.String-java.util.logging.Level-reactor.core.publisher.SignalType...-">log</a></span>(java.lang.String&nbsp;category,
   java.util.logging.Level&nbsp;level,
   <a href="../../../reactor/core/publisher/SignalType.html" title="reactor.core.publisher中的枚举">SignalType</a>...&nbsp;options)</code>
<div class="block">Observe Reactive Streams signals matching the passed filter <code>options</code> and
 trace them using <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a> support.</div>
</td>
</tr>
<tr id="i188" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#map-java.util.function.Function-">map</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;mapper)</code>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by applying a synchronous function
 to each item.</div>
</td>
</tr>
<tr id="i189" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mapNotNull-java.util.function.Function-">mapNotNull</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;mapper)</code>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by applying a synchronous function
 to each item, which may produce <code>null</code> values.</div>
</td>
</tr>
<tr id="i190" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口">Signal</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#materialize--">materialize</a></span>()</code>
<div class="block">Transform incoming onNext, onError and onComplete signals into <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a> instances,
 materializing these signals.</div>
</td>
</tr>
<tr id="i191" class="rowColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#merge-int-org.reactivestreams.Publisher...-">merge</a></span>(int&nbsp;prefetch,
     org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block">Merge data from <code>Publisher</code> sequences contained in an array / vararg
 into an interleaved merged sequence.</div>
</td>
</tr>
<tr id="i192" class="altColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#merge-java.lang.Iterable-">merge</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources)</code>
<div class="block">Merge data from <code>Publisher</code> sequences contained in an <code>Iterable</code>
 into an interleaved merged sequence.</div>
</td>
</tr>
<tr id="i193" class="rowColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#merge-org.reactivestreams.Publisher...-">merge</a></span>(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block">Merge data from <code>Publisher</code> sequences contained in an array / vararg
 into an interleaved merged sequence.</div>
</td>
</tr>
<tr id="i194" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#merge-org.reactivestreams.Publisher-">merge</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;source)</code>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an interleaved merged sequence.</div>
</td>
</tr>
<tr id="i195" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#merge-org.reactivestreams.Publisher-int-">merge</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;source,
     int&nbsp;concurrency)</code>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an interleaved merged sequence.</div>
</td>
</tr>
<tr id="i196" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#merge-org.reactivestreams.Publisher-int-int-">merge</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;source,
     int&nbsp;concurrency,
     int&nbsp;prefetch)</code>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an interleaved merged sequence.</div>
</td>
</tr>
<tr id="i197" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeComparing-java.util.Comparator-org.reactivestreams.Publisher...-">mergeComparing</a></span>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
              org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>).</div>
</td>
</tr>
<tr id="i198" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeComparing-int-java.util.Comparator-org.reactivestreams.Publisher...-">mergeComparing</a></span>(int&nbsp;prefetch,
              java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
              org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>).</div>
</td>
</tr>
<tr id="i199" class="rowColor">
<td class="colFirst"><code>static &lt;I extends java.lang.Comparable&lt;? super I&gt;&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeComparing-org.reactivestreams.Publisher...-">mergeComparing</a></span>(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by their natural order).</div>
</td>
</tr>
<tr id="i200" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeComparingDelayError-int-java.util.Comparator-org.reactivestreams.Publisher...-">mergeComparingDelayError</a></span>(int&nbsp;prefetch,
                        java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                        org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>).</div>
</td>
</tr>
<tr id="i201" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeComparingWith-org.reactivestreams.Publisher-java.util.Comparator-">mergeComparingWith</a></span>(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;other,
                  java.util.Comparator&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;otherComparator)</code>
<div class="block">Merge data from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and a <code>Publisher</code> into a reordered merge
 sequence, by picking the smallest value from each sequence as defined by a provided
 <code>Comparator</code>.</div>
</td>
</tr>
<tr id="i202" class="altColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeDelayError-int-org.reactivestreams.Publisher...-">mergeDelayError</a></span>(int&nbsp;prefetch,
               org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block">Merge data from <code>Publisher</code> sequences contained in an array / vararg
 into an interleaved merged sequence.</div>
</td>
</tr>
<tr id="i203" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeOrdered-java.util.Comparator-org.reactivestreams.Publisher...-">mergeOrdered</a></span>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
            org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">Use <a href="../../../reactor/core/publisher/Flux.html#mergeComparingDelayError-int-java.util.Comparator-org.reactivestreams.Publisher...-"><code>mergeComparingDelayError(int, Comparator, Publisher[])</code></a> instead
 (as <a href="../../../reactor/core/publisher/Flux.html#mergeComparing-org.reactivestreams.Publisher...-"><code>mergeComparing(Publisher[])</code></a> don't have this operator's delayError behavior).
 To be removed in 3.6.0 at the earliest.</span></div>
</div>
</td>
</tr>
<tr id="i204" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeOrdered-int-java.util.Comparator-org.reactivestreams.Publisher...-">mergeOrdered</a></span>(int&nbsp;prefetch,
            java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
            org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">Use <a href="../../../reactor/core/publisher/Flux.html#mergeComparingDelayError-int-java.util.Comparator-org.reactivestreams.Publisher...-"><code>mergeComparingDelayError(int, Comparator, Publisher[])</code></a> instead
 (as <a href="../../../reactor/core/publisher/Flux.html#mergeComparing-org.reactivestreams.Publisher...-"><code>mergeComparing(Publisher[])</code></a> don't have this operator's delayError behavior).
 To be removed in 3.6.0 at the earliest.</span></div>
</div>
</td>
</tr>
<tr id="i205" class="rowColor">
<td class="colFirst"><code>static &lt;I extends java.lang.Comparable&lt;? super I&gt;&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeOrdered-org.reactivestreams.Publisher...-">mergeOrdered</a></span>(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">Use <a href="../../../reactor/core/publisher/Flux.html#mergeComparingDelayError-int-java.util.Comparator-org.reactivestreams.Publisher...-"><code>mergeComparingDelayError(int, Comparator, Publisher[])</code></a> instead
 (as <a href="../../../reactor/core/publisher/Flux.html#mergeComparing-org.reactivestreams.Publisher...-"><code>mergeComparing(Publisher[])</code></a> don't have this operator's delayError behavior).
 To be removed in 3.6.0 at the earliest.</span></div>
</div>
</td>
</tr>
<tr id="i206" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeOrderedWith-org.reactivestreams.Publisher-java.util.Comparator-">mergeOrderedWith</a></span>(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;other,
                java.util.Comparator&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;otherComparator)</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">Use <a href="../../../reactor/core/publisher/Flux.html#mergeComparingWith-org.reactivestreams.Publisher-java.util.Comparator-"><code>mergeComparingWith(Publisher, Comparator)</code></a> instead
 (with the caveat that it defaults to NOT delaying errors, unlike this operator).
 To be removed in 3.6.0 at the earliest.</span></div>
</div>
</td>
</tr>
<tr id="i207" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergePriority-java.util.Comparator-org.reactivestreams.Publisher...-">mergePriority</a></span>(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
             org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>) <strong>as they arrive</strong>.</div>
</td>
</tr>
<tr id="i208" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergePriority-int-java.util.Comparator-org.reactivestreams.Publisher...-">mergePriority</a></span>(int&nbsp;prefetch,
             java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
             org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>) <strong>as they arrive</strong>.</div>
</td>
</tr>
<tr id="i209" class="rowColor">
<td class="colFirst"><code>static &lt;I extends java.lang.Comparable&lt;? super I&gt;&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergePriority-org.reactivestreams.Publisher...-">mergePriority</a></span>(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by their natural order) <strong>as they arrive</strong>.</div>
</td>
</tr>
<tr id="i210" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergePriorityDelayError-int-java.util.Comparator-org.reactivestreams.Publisher...-">mergePriorityDelayError</a></span>(int&nbsp;prefetch,
                       java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                       org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</code>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>) <strong>as they arrive</strong>.</div>
</td>
</tr>
<tr id="i211" class="rowColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeSequential-int-org.reactivestreams.Publisher...-">mergeSequential</a></span>(int&nbsp;prefetch,
               org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an array/vararg
 into an ordered merged sequence.</div>
</td>
</tr>
<tr id="i212" class="altColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeSequential-java.lang.Iterable-">mergeSequential</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources)</code>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an <code>Iterable</code>
 into an ordered merged sequence.</div>
</td>
</tr>
<tr id="i213" class="rowColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeSequential-java.lang.Iterable-int-int-">mergeSequential</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources,
               int&nbsp;maxConcurrency,
               int&nbsp;prefetch)</code>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an <code>Iterable</code>
 into an ordered merged sequence.</div>
</td>
</tr>
<tr id="i214" class="altColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeSequential-org.reactivestreams.Publisher...-">mergeSequential</a></span>(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an array/vararg
 into an ordered merged sequence.</div>
</td>
</tr>
<tr id="i215" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeSequential-org.reactivestreams.Publisher-">mergeSequential</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources)</code>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an ordered merged sequence.</div>
</td>
</tr>
<tr id="i216" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeSequential-org.reactivestreams.Publisher-int-int-">mergeSequential</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
               int&nbsp;maxConcurrency,
               int&nbsp;prefetch)</code>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an ordered merged sequence.</div>
</td>
</tr>
<tr id="i217" class="rowColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeSequentialDelayError-int-org.reactivestreams.Publisher...-">mergeSequentialDelayError</a></span>(int&nbsp;prefetch,
                         org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an array/vararg
 into an ordered merged sequence.</div>
</td>
</tr>
<tr id="i218" class="altColor">
<td class="colFirst"><code>static &lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeSequentialDelayError-java.lang.Iterable-int-int-">mergeSequentialDelayError</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources,
                         int&nbsp;maxConcurrency,
                         int&nbsp;prefetch)</code>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an <code>Iterable</code>
 into an ordered merged sequence.</div>
</td>
</tr>
<tr id="i219" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeSequentialDelayError-org.reactivestreams.Publisher-int-int-">mergeSequentialDelayError</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                         int&nbsp;maxConcurrency,
                         int&nbsp;prefetch)</code>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an ordered merged sequence.</div>
</td>
</tr>
<tr id="i220" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#mergeWith-org.reactivestreams.Publisher-">mergeWith</a></span>(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;other)</code>
<div class="block">Merge data from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and a <code>Publisher</code> into an interleaved merged
 sequence.</div>
</td>
</tr>
<tr id="i221" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#metrics--">metrics</a></span>()</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">Prefer using the <a href="../../../reactor/core/publisher/Flux.html#tap-reactor.core.observability.SignalListenerFactory-"><code>tap(SignalListenerFactory)</code></a> with the <a href="../../../reactor/core/observability/SignalListenerFactory.html" title="reactor.core.observability中的接口"><code>SignalListenerFactory</code></a> provided by
 the new reactor-core-micrometer module. To be removed in 3.6.0 at the earliest.</span></div>
</div>
</td>
</tr>
<tr id="i222" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#name-java.lang.String-">name</a></span>(java.lang.String&nbsp;name)</code>
<div class="block">Give a name to this sequence, which can be retrieved using <a href="../../../reactor/core/Scannable.html#name--"><code>Scannable.name()</code></a>
 as long as this is the first reachable <a href="../../../reactor/core/Scannable.html#parents--"><code>Scannable.parents()</code></a>.</div>
</td>
</tr>
<tr id="i223" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#never--">never</a></span>()</code>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will never signal any data, error or completion signal.</div>
</td>
</tr>
<tr id="i224" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#next--">next</a></span>()</code>
<div class="block">仅将Flux发出的第一个元素发布到新的Mono中。</div>
</td>
</tr>
<tr id="i225" class="rowColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;U&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#ofType-java.lang.Class-">ofType</a></span>(java.lang.Class&lt;U&gt;&nbsp;clazz)</code>
<div class="block">Evaluate each accepted value against the given <code>Class</code> type.</div>
</td>
</tr>
<tr id="i226" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onBackpressureBuffer--">onBackpressureBuffer</a></span>()</code>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park the
 observed elements if not enough demand is requested downstream.</div>
</td>
</tr>
<tr id="i227" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onBackpressureBuffer-java.time.Duration-int-java.util.function.Consumer-">onBackpressureBuffer</a></span>(java.time.Duration&nbsp;ttl,
                    int&nbsp;maxSize,
                    java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBufferEviction)</code>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park the observed
 elements if not enough demand is requested downstream, within a <code>maxSize</code>
 limit and for a maximum <code>Duration</code> of <code>ttl</code> (as measured on the
 <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel Scheduler</code></a>).</div>
</td>
</tr>
<tr id="i228" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onBackpressureBuffer-java.time.Duration-int-java.util.function.Consumer-reactor.core.scheduler.Scheduler-">onBackpressureBuffer</a></span>(java.time.Duration&nbsp;ttl,
                    int&nbsp;maxSize,
                    java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBufferEviction,
                    <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</code>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park the observed
 elements if not enough demand is requested downstream, within a <code>maxSize</code>
 limit and for a maximum <code>Duration</code> of <code>ttl</code> (as measured on the provided
 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>).</div>
</td>
</tr>
<tr id="i229" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onBackpressureBuffer-int-">onBackpressureBuffer</a></span>(int&nbsp;maxSize)</code>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park up to
 <code>maxSize</code> elements when not enough demand is requested downstream.</div>
</td>
</tr>
<tr id="i230" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onBackpressureBuffer-int-reactor.core.publisher.BufferOverflowStrategy-">onBackpressureBuffer</a></span>(int&nbsp;maxSize,
                    <a href="../../../reactor/core/publisher/BufferOverflowStrategy.html" title="reactor.core.publisher中的枚举">BufferOverflowStrategy</a>&nbsp;bufferOverflowStrategy)</code>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park the observed
 elements if not enough demand is requested downstream, within a <code>maxSize</code>
 limit.</div>
</td>
</tr>
<tr id="i231" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onBackpressureBuffer-int-java.util.function.Consumer-">onBackpressureBuffer</a></span>(int&nbsp;maxSize,
                    java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onOverflow)</code>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park up to
 <code>maxSize</code> elements when not enough demand is requested downstream.</div>
</td>
</tr>
<tr id="i232" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onBackpressureBuffer-int-java.util.function.Consumer-reactor.core.publisher.BufferOverflowStrategy-">onBackpressureBuffer</a></span>(int&nbsp;maxSize,
                    java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBufferOverflow,
                    <a href="../../../reactor/core/publisher/BufferOverflowStrategy.html" title="reactor.core.publisher中的枚举">BufferOverflowStrategy</a>&nbsp;bufferOverflowStrategy)</code>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park the observed
 elements if not enough demand is requested downstream, within a <code>maxSize</code>
 limit.</div>
</td>
</tr>
<tr id="i233" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onBackpressureDrop--">onBackpressureDrop</a></span>()</code>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or drop
 the observed elements if not enough demand is requested downstream.</div>
</td>
</tr>
<tr id="i234" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onBackpressureDrop-java.util.function.Consumer-">onBackpressureDrop</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onDropped)</code>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or drop and
 notify dropping <code>Consumer</code> with the observed elements if not enough demand
 is requested downstream.</div>
</td>
</tr>
<tr id="i235" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onBackpressureError--">onBackpressureError</a></span>()</code>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or emit onError
 fom <a href="../../../reactor/core/Exceptions.html#failWithOverflow--"><code>Exceptions.failWithOverflow()</code></a> if not enough demand is requested
 downstream.</div>
</td>
</tr>
<tr id="i236" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onBackpressureLatest--">onBackpressureLatest</a></span>()</code>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or only keep
 the most recent observed item if not enough demand is requested downstream.</div>
</td>
</tr>
<tr id="i237" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorComplete--">onErrorComplete</a></span>()</code>
<div class="block">Simply complete the sequence by replacing an <code>onError signal</code>
 with an <code>onComplete signal</code>.</div>
</td>
</tr>
<tr id="i238" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorComplete-java.lang.Class-">onErrorComplete</a></span>(java.lang.Class&lt;? extends java.lang.Throwable&gt;&nbsp;type)</code>
<div class="block">Simply complete the sequence by replacing an <code>onError signal</code>
 with an <code>onComplete signal</code> if the error matches the given
 <code>Class</code>.</div>
</td>
</tr>
<tr id="i239" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorComplete-java.util.function.Predicate-">onErrorComplete</a></span>(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate)</code>
<div class="block">Simply complete the sequence by replacing an <code>onError signal</code>
 with an <code>onComplete signal</code> if the error matches the given
 <code>Predicate</code>.</div>
</td>
</tr>
<tr id="i240" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-">onErrorContinue</a></span>(java.util.function.BiConsumer&lt;java.lang.Throwable,java.lang.Object&gt;&nbsp;errorConsumer)</code>
<div class="block">Let compatible operators <strong>upstream</strong> recover from errors by dropping the
 incriminating element from the sequence and continuing with subsequent elements.</div>
</td>
</tr>
<tr id="i241" class="rowColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.lang.Class-java.util.function.BiConsumer-">onErrorContinue</a></span>(java.lang.Class&lt;E&gt;&nbsp;type,
               java.util.function.BiConsumer&lt;java.lang.Throwable,java.lang.Object&gt;&nbsp;errorConsumer)</code>
<div class="block">Let compatible operators <strong>upstream</strong> recover from errors by dropping the
 incriminating element from the sequence and continuing with subsequent elements.</div>
</td>
</tr>
<tr id="i242" class="altColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.Predicate-java.util.function.BiConsumer-">onErrorContinue</a></span>(java.util.function.Predicate&lt;E&gt;&nbsp;errorPredicate,
               java.util.function.BiConsumer&lt;java.lang.Throwable,java.lang.Object&gt;&nbsp;errorConsumer)</code>
<div class="block">Let compatible operators <strong>upstream</strong> recover from errors by dropping the
 incriminating element from the sequence and continuing with subsequent elements.</div>
</td>
</tr>
<tr id="i243" class="rowColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorMap-java.lang.Class-java.util.function.Function-">onErrorMap</a></span>(java.lang.Class&lt;E&gt;&nbsp;type,
          java.util.function.Function&lt;? super E,? extends java.lang.Throwable&gt;&nbsp;mapper)</code>
<div class="block">Transform an error emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by synchronously applying a function
 to it if the error matches the given type.</div>
</td>
</tr>
<tr id="i244" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorMap-java.util.function.Function-">onErrorMap</a></span>(java.util.function.Function&lt;? super java.lang.Throwable,? extends java.lang.Throwable&gt;&nbsp;mapper)</code>
<div class="block">Transform any error emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by synchronously applying a function to it.</div>
</td>
</tr>
<tr id="i245" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorMap-java.util.function.Predicate-java.util.function.Function-">onErrorMap</a></span>(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
          java.util.function.Function&lt;? super java.lang.Throwable,? extends java.lang.Throwable&gt;&nbsp;mapper)</code>
<div class="block">Transform an error emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by synchronously applying a function
 to it if the error matches the given predicate.</div>
</td>
</tr>
<tr id="i246" class="altColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-">onErrorResume</a></span>(java.lang.Class&lt;E&gt;&nbsp;type,
             java.util.function.Function&lt;? super E,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;fallback)</code>
<div class="block">Subscribe to a fallback publisher when an error matching the given type
 occurs, using a function to choose the fallback depending on the error.</div>
</td>
</tr>
<tr id="i247" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorResume-java.util.function.Function-">onErrorResume</a></span>(java.util.function.Function&lt;? super java.lang.Throwable,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;fallback)</code>
<div class="block">Subscribe to a returned fallback publisher when any error occurs, using a function to
 choose the fallback depending on the error.</div>
</td>
</tr>
<tr id="i248" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorResume-java.util.function.Predicate-java.util.function.Function-">onErrorResume</a></span>(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
             java.util.function.Function&lt;? super java.lang.Throwable,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;fallback)</code>
<div class="block">Subscribe to a fallback publisher when an error matching a given predicate
 occurs.</div>
</td>
</tr>
<tr id="i249" class="rowColor">
<td class="colFirst"><code>&lt;E extends java.lang.Throwable&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-">onErrorReturn</a></span>(java.lang.Class&lt;E&gt;&nbsp;type,
             <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;fallbackValue)</code>
<div class="block">Simply emit a captured fallback value when an error of the specified type is
 observed on this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i250" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorReturn-java.util.function.Predicate-T-">onErrorReturn</a></span>(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
             <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;fallbackValue)</code>
<div class="block">Simply emit a captured fallback value when an error matching the given predicate is
 observed on this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i251" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorReturn-T-">onErrorReturn</a></span>(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;fallbackValue)</code>
<div class="block">Simply emit a captured fallback value when any error is observed on this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i252" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onErrorStop--">onErrorStop</a></span>()</code>
<div class="block">If an <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>onErrorContinue(BiConsumer)</code></a> variant has been used downstream, reverts
 to the default 'STOP' mode where errors are terminal events upstream.</div>
</td>
</tr>
<tr id="i253" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#onTerminateDetach--">onTerminateDetach</a></span>()</code>
<div class="block">Detaches both the child <code>Subscriber</code> and the <code>Subscription</code> on
 termination or cancellation.</div>
</td>
</tr>
<tr id="i254" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#or-org.reactivestreams.Publisher-">or</a></span>(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;other)</code>
<div class="block">Pick the first <code>Publisher</code> between this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and another publisher
 to emit any signal (onNext/onError/onComplete) and replay all signals from that
 <code>Publisher</code>, effectively behaving like the fastest of these competing sources.</div>
</td>
</tr>
<tr id="i255" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/ParallelFlux.html" title="reactor.core.publisher中的类">ParallelFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#parallel--">parallel</a></span>()</code>
<div class="block">Prepare this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by dividing data on a number of 'rails' matching the
 number of CPU cores, in a round-robin fashion.</div>
</td>
</tr>
<tr id="i256" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/ParallelFlux.html" title="reactor.core.publisher中的类">ParallelFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#parallel-int-">parallel</a></span>(int&nbsp;parallelism)</code>
<div class="block">Prepare this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by dividing data on a number of 'rails' matching the
 provided <code>parallelism</code> parameter, in a round-robin fashion.</div>
</td>
</tr>
<tr id="i257" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/ParallelFlux.html" title="reactor.core.publisher中的类">ParallelFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#parallel-int-int-">parallel</a></span>(int&nbsp;parallelism,
        int&nbsp;prefetch)</code>
<div class="block">Prepare this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by dividing data on a number of 'rails' matching the
 provided <code>parallelism</code> parameter, in a round-robin fashion and using a
 custom prefetch amount and queue for dealing with the source <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>'s values.</div>
</td>
</tr>
<tr id="i258" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#publish--">publish</a></span>()</code>
<div class="block">Prepare a <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a> which shares this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence and
 dispatches values to subscribers in a backpressure-aware manner.</div>
</td>
</tr>
<tr id="i259" class="rowColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#publish-java.util.function.Function-">publish</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;transform)</code>
<div class="block">Shares a sequence for the duration of a function that may transform it and
 consume it as many times as necessary without causing multiple subscriptions
 to the upstream.</div>
</td>
</tr>
<tr id="i260" class="altColor">
<td class="colFirst"><code>&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#publish-java.util.function.Function-int-">publish</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;transform,
       int&nbsp;prefetch)</code>
<div class="block">Shares a sequence for the duration of a function that may transform it and
 consume it as many times as necessary without causing multiple subscriptions
 to the upstream.</div>
</td>
</tr>
<tr id="i261" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#publish-int-">publish</a></span>(int&nbsp;prefetch)</code>
<div class="block">Prepare a <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a> which shares this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence and
 dispatches values to subscribers in a backpressure-aware manner.</div>
</td>
</tr>
<tr id="i262" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#publishNext--">publishNext</a></span>()</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">use <a href="../../../reactor/core/publisher/Flux.html#shareNext--"><code>shareNext()</code></a> instead, or use `publish().next()` if you need
 to `<a href="../../../reactor/core/publisher/ConnectableFlux.html#connect--"><code>connect()</code></a>. To be removed in 3.5.0</span></div>
</div>
</td>
</tr>
<tr id="i263" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#publishOn-reactor.core.scheduler.Scheduler-">publishOn</a></span>(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</code>
<div class="block">Run onNext, onComplete and onError on a supplied <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>
 <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Worker</code></a>.</div>
</td>
</tr>
<tr id="i264" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#publishOn-reactor.core.scheduler.Scheduler-boolean-int-">publishOn</a></span>(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler,
         boolean&nbsp;delayError,
         int&nbsp;prefetch)</code>
<div class="block">Run onNext, onComplete and onError on a supplied <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>
 <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a>.</div>
</td>
</tr>
<tr id="i265" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#publishOn-reactor.core.scheduler.Scheduler-int-">publishOn</a></span>(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler,
         int&nbsp;prefetch)</code>
<div class="block">Run onNext, onComplete and onError on a supplied <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>
 <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a>.</div>
</td>
</tr>
<tr id="i266" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#push-java.util.function.Consumer-">push</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口">FluxSink</a>&lt;T&gt;&gt;&nbsp;emitter)</code>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the capability of emitting multiple
 elements from a single-threaded producer through the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> API.</div>
</td>
</tr>
<tr id="i267" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#push-java.util.function.Consumer-reactor.core.publisher.FluxSink.OverflowStrategy-">push</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口">FluxSink</a>&lt;T&gt;&gt;&nbsp;emitter,
    <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html" title="reactor.core.publisher中的枚举">FluxSink.OverflowStrategy</a>&nbsp;backpressure)</code>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the capability of emitting multiple
 elements from a single-threaded producer through the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> API.</div>
</td>
</tr>
<tr id="i268" class="altColor">
<td class="colFirst"><code>static <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Integer&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#range-int-int-">range</a></span>(int&nbsp;start,
     int&nbsp;count)</code>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will only emit a sequence of <code>count</code> incrementing integers,
 starting from <code>start</code>.</div>
</td>
</tr>
<tr id="i269" class="rowColor">
<td class="colFirst"><code>&lt;A&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;A&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#reduce-A-java.util.function.BiFunction-">reduce</a></span>(A&nbsp;initial,
      java.util.function.BiFunction&lt;A,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,A&gt;&nbsp;accumulator)</code>
<div class="block">Reduce the values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into a single object matching the
 type of a seed value.</div>
</td>
</tr>
<tr id="i270" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#reduce-java.util.function.BiFunction-">reduce</a></span>(java.util.function.BiFunction&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;aggregator)</code>
<div class="block">将一个 <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> 规约为一个 <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>
 
 Reduce the values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into a single object of the same
 type than the emitted items.</div>
</td>
</tr>
<tr id="i271" class="rowColor">
<td class="colFirst"><code>&lt;A&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;A&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#reduceWith-java.util.function.Supplier-java.util.function.BiFunction-">reduceWith</a></span>(java.util.function.Supplier&lt;A&gt;&nbsp;initial,
          java.util.function.BiFunction&lt;A,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,A&gt;&nbsp;accumulator)</code>
<div class="block">Reduce the values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into a single object matching the
 type of a lazily supplied seed value.</div>
</td>
</tr>
<tr id="i272" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#repeat--">repeat</a></span>()</code>
<div class="block">Repeatedly and indefinitely subscribe to the source upon completion of the
 previous subscription.</div>
</td>
</tr>
<tr id="i273" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#repeat-java.util.function.BooleanSupplier-">repeat</a></span>(java.util.function.BooleanSupplier&nbsp;predicate)</code>
<div class="block">Repeatedly subscribe to the source if the predicate returns true after completion of the previous subscription.</div>
</td>
</tr>
<tr id="i274" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#repeat-long-">repeat</a></span>(long&nbsp;numRepeat)</code>
<div class="block">Repeatedly subscribe to the source <code>numRepeat</code> times.</div>
</td>
</tr>
<tr id="i275" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#repeat-long-java.util.function.BooleanSupplier-">repeat</a></span>(long&nbsp;numRepeat,
      java.util.function.BooleanSupplier&nbsp;predicate)</code>
<div class="block">Repeatedly subscribe to the source if the predicate returns true after completion of the previous
 subscription.</div>
</td>
</tr>
<tr id="i276" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#repeatWhen-java.util.function.Function-">repeatWhen</a></span>(java.util.function.Function&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Long&gt;,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;repeatFactory)</code>
<div class="block">Repeatedly subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> when a companion sequence emits elements in
 response to the flux completion signal.</div>
</td>
</tr>
<tr id="i277" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#replay--">replay</a></span>()</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i278" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#replay-java.time.Duration-">replay</a></span>(java.time.Duration&nbsp;ttl)</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a connectable hot source and cache last emitted signals
 for further <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i279" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#replay-java.time.Duration-reactor.core.scheduler.Scheduler-">replay</a></span>(java.time.Duration&nbsp;ttl,
      <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a connectable hot source and cache last emitted signals
 for further <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i280" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#replay-int-">replay</a></span>(int&nbsp;history)</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a connectable hot source and cache last emitted
 signals for further <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i281" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#replay-int-java.time.Duration-">replay</a></span>(int&nbsp;history,
      java.time.Duration&nbsp;ttl)</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a connectable hot source and cache last emitted signals
 for further <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i282" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#replay-int-java.time.Duration-reactor.core.scheduler.Scheduler-">replay</a></span>(int&nbsp;history,
      java.time.Duration&nbsp;ttl,
      <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a connectable hot source and cache last emitted signals
 for further <code>Subscriber</code>.</div>
</td>
</tr>
<tr id="i283" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#retry--">retry</a></span>()</code>
<div class="block">Re-subscribes to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence if it signals any error, indefinitely.</div>
</td>
</tr>
<tr id="i284" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#retry-long-">retry</a></span>(long&nbsp;numRetries)</code>
<div class="block">Re-subscribes to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence if it signals any error, for a fixed
 number of times.</div>
</td>
</tr>
<tr id="i285" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-">retryWhen</a></span>(<a href="../../../reactor/util/retry/Retry.html" title="reactor.util.retry中的类">Retry</a>&nbsp;retrySpec)</code>
<div class="block">Retries this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> in response to signals emitted by a companion <code>Publisher</code>.</div>
</td>
</tr>
<tr id="i286" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#sample-java.time.Duration-">sample</a></span>(java.time.Duration&nbsp;timespan)</code>
<div class="block">Sample this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by periodically emitting an item corresponding to that
 <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> latest emitted value within the periodical time window.</div>
</td>
</tr>
<tr id="i287" class="rowColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#sample-org.reactivestreams.Publisher-">sample</a></span>(org.reactivestreams.Publisher&lt;U&gt;&nbsp;sampler)</code>
<div class="block">Sample this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by emitting an item corresponding to that <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 latest emitted value whenever a companion sampler <code>Publisher</code> signals a value.</div>
</td>
</tr>
<tr id="i288" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#sampleFirst-java.time.Duration-">sampleFirst</a></span>(java.time.Duration&nbsp;timespan)</code>
<div class="block">Repeatedly take a value from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> then skip the values that follow
 within a given duration.</div>
</td>
</tr>
<tr id="i289" class="rowColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#sampleFirst-java.util.function.Function-">sampleFirst</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;U&gt;&gt;&nbsp;samplerFactory)</code>
<div class="block">Repeatedly take a value from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> then skip the values that follow
 before the next signal from a companion sampler <code>Publisher</code>.</div>
</td>
</tr>
<tr id="i290" class="altColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#sampleTimeout-java.util.function.Function-">sampleTimeout</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;U&gt;&gt;&nbsp;throttlerFactory)</code>
<div class="block">Emit the latest value from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> only if there were no new values emitted
 during the window defined by a companion <code>Publisher</code> derived from that particular
 value.</div>
</td>
</tr>
<tr id="i291" class="rowColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#sampleTimeout-java.util.function.Function-int-">sampleTimeout</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;U&gt;&gt;&nbsp;throttlerFactory,
             int&nbsp;maxConcurrency)</code>
<div class="block">Emit the latest value from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> only if there were no new values emitted
 during the window defined by a companion <code>Publisher</code> derived from that particular
 value.</div>
</td>
</tr>
<tr id="i292" class="altColor">
<td class="colFirst"><code>&lt;A&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;A&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#scan-A-java.util.function.BiFunction-">scan</a></span>(A&nbsp;initial,
    java.util.function.BiFunction&lt;A,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,A&gt;&nbsp;accumulator)</code>
<div class="block">Reduce this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> values with an accumulator <code>BiFunction</code> and
 also emit the intermediate results of this function.</div>
</td>
</tr>
<tr id="i293" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#scan-java.util.function.BiFunction-">scan</a></span>(java.util.function.BiFunction&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;accumulator)</code>
<div class="block">Reduce this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> values with an accumulator <code>BiFunction</code> and
 also emit the intermediate results of this function.</div>
</td>
</tr>
<tr id="i294" class="altColor">
<td class="colFirst"><code>&lt;A&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;A&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#scanWith-java.util.function.Supplier-java.util.function.BiFunction-">scanWith</a></span>(java.util.function.Supplier&lt;A&gt;&nbsp;initial,
        java.util.function.BiFunction&lt;A,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,A&gt;&nbsp;accumulator)</code>
<div class="block">Reduce this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> values with the help of an accumulator <code>BiFunction</code>
 and also emits the intermediate results.</div>
</td>
</tr>
<tr id="i295" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#share--">share</a></span>()</code>
<div class="block">Returns a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that multicasts (shares) the original <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i296" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#shareNext--">shareNext</a></span>()</code>
<div class="block">Prepare a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> which shares this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence and dispatches the
 first observed item to subscribers.</div>
</td>
</tr>
<tr id="i297" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#single--">single</a></span>()</code>
<div class="block">Expect and emit a single item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> source or signal
 <code>NoSuchElementException</code> for an empty source, or
 <code>IndexOutOfBoundsException</code> for a source with more than one element.</div>
</td>
</tr>
<tr id="i298" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#single-T-">single</a></span>(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;defaultValue)</code>
<div class="block">Expect and emit a single item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> source and emit a default
 value for an empty source, but signal an <code>IndexOutOfBoundsException</code> for a
 source with more than one element.</div>
</td>
</tr>
<tr id="i299" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#singleOrEmpty--">singleOrEmpty</a></span>()</code>
<div class="block">Expect and emit a single item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> source, and accept an empty
 source but signal an <code>IndexOutOfBoundsException</code> for a source with more than
 one element.</div>
</td>
</tr>
<tr id="i300" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#skip-java.time.Duration-">skip</a></span>(java.time.Duration&nbsp;timespan)</code>
<div class="block">Skip elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitted within the specified initial duration.</div>
</td>
</tr>
<tr id="i301" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#skip-java.time.Duration-reactor.core.scheduler.Scheduler-">skip</a></span>(java.time.Duration&nbsp;timespan,
    <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Skip elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitted within the specified initial duration,
 as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i302" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#skip-long-">skip</a></span>(long&nbsp;skipped)</code>
<div class="block">Skip the specified number of elements from the beginning of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> then
 emit the remaining elements.</div>
</td>
</tr>
<tr id="i303" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#skipLast-int-">skipLast</a></span>(int&nbsp;n)</code>
<div class="block">Skip a specified number of elements at the end of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence.</div>
</td>
</tr>
<tr id="i304" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#skipUntil-java.util.function.Predicate-">skipUntil</a></span>(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;untilPredicate)</code>
<div class="block">Skips values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until a <code>Predicate</code> returns true for the
 value.</div>
</td>
</tr>
<tr id="i305" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#skipUntilOther-org.reactivestreams.Publisher-">skipUntilOther</a></span>(org.reactivestreams.Publisher&lt;?&gt;&nbsp;other)</code>
<div class="block">Skip values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until a specified <code>Publisher</code> signals
 an onNext or onComplete.</div>
</td>
</tr>
<tr id="i306" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#skipWhile-java.util.function.Predicate-">skipWhile</a></span>(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;skipPredicate)</code>
<div class="block">Skips values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> while a <code>Predicate</code> returns true for the value.</div>
</td>
</tr>
<tr id="i307" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#sort--">sort</a></span>()</code>
<div class="block">Sort elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by collecting and sorting them in the background
 then emitting the sorted sequence once this sequence completes.</div>
</td>
</tr>
<tr id="i308" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#sort-java.util.Comparator-">sort</a></span>(java.util.Comparator&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;sortFunction)</code>
<div class="block">Sort elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> using a <code>Comparator</code> function, by
 collecting and sorting elements in the background then emitting the sorted sequence
 once this sequence completes.</div>
</td>
</tr>
<tr id="i309" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#startWith-java.lang.Iterable-">startWith</a></span>(java.lang.Iterable&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;iterable)</code>
<div class="block">Prepend the given <code>Iterable</code> before this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence.</div>
</td>
</tr>
<tr id="i310" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#startWith-org.reactivestreams.Publisher-">startWith</a></span>(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;publisher)</code>
<div class="block">Prepend the given <code>Publisher</code> sequence to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence.</div>
</td>
</tr>
<tr id="i311" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#startWith-T...-">startWith</a></span>(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>...&nbsp;values)</code>
<div class="block">Prepend the given values before this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence.</div>
</td>
</tr>
<tr id="i312" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#subscribe--">subscribe</a></span>()</code>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and request unbounded demand.</div>
</td>
</tr>
<tr id="i313" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#subscribe-java.util.function.Consumer-">subscribe</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;consumer)</code>
<div class="block">Subscribe a <code>Consumer</code> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will consume all the
 elements in the  sequence.</div>
</td>
</tr>
<tr id="i314" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#subscribe-java.util.function.Consumer-java.util.function.Consumer-">subscribe</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;consumer,
         java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;errorConsumer)</code>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with a <code>Consumer</code> that will consume all the
 elements in the sequence, as well as a <code>Consumer</code> that will handle errors.</div>
</td>
</tr>
<tr id="i315" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#subscribe-java.util.function.Consumer-java.util.function.Consumer-java.lang.Runnable-">subscribe</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;consumer,
         java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;errorConsumer,
         java.lang.Runnable&nbsp;completeConsumer)</code>
<div class="block">Subscribe <code>Consumer</code> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will respectively consume all the
 elements in the sequence, handle errors and react to completion.</div>
</td>
</tr>
<tr id="i316" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#subscribe-java.util.function.Consumer-java.util.function.Consumer-java.lang.Runnable-java.util.function.Consumer-">subscribe</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;consumer,
         java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;errorConsumer,
         java.lang.Runnable&nbsp;completeConsumer,
         java.util.function.Consumer&lt;? super org.reactivestreams.Subscription&gt;&nbsp;subscriptionConsumer)</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">Because users tend to forget to <code>request</code> the subsciption. If
 the behavior is really needed, consider using <a href="../../../reactor/core/publisher/Flux.html#subscribeWith-E-"><code>subscribeWith(Subscriber)</code></a>. To be removed in 3.5.</span></div>
</div>
</td>
</tr>
<tr id="i317" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#subscribe-java.util.function.Consumer-java.util.function.Consumer-java.lang.Runnable-reactor.util.context.Context-">subscribe</a></span>(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;consumer,
         java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;errorConsumer,
         java.lang.Runnable&nbsp;completeConsumer,
         <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口">Context</a>&nbsp;initialContext)</code>
<div class="block">Subscribe <code>Consumer</code> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will respectively consume all the
 elements in the sequence, handle errors and react to completion.</div>
</td>
</tr>
<tr id="i318" class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#subscribe-reactor.core.CoreSubscriber-">subscribe</a></span>(<a href="../../../reactor/core/CoreSubscriber.html" title="reactor.core中的接口">CoreSubscriber</a>&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;actual)</code>
<div class="block">An internal <code>Publisher.subscribe(Subscriber)</code> that will bypass
 <a href="../../../reactor/core/publisher/Hooks.html#onLastOperator-java.util.function.Function-"><code>Hooks.onLastOperator(Function)</code></a> pointcut.</div>
</td>
</tr>
<tr id="i319" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-">subscribe</a></span>(org.reactivestreams.Subscriber&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;actual)</code>&nbsp;</td>
</tr>
<tr id="i320" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#subscribeOn-reactor.core.scheduler.Scheduler-">subscribeOn</a></span>(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</code>
<div class="block">Run subscribe, onSubscribe and request on a specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>'s <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a>.</div>
</td>
</tr>
<tr id="i321" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#subscribeOn-reactor.core.scheduler.Scheduler-boolean-">subscribeOn</a></span>(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler,
           boolean&nbsp;requestOnSeparateThread)</code>
<div class="block">Run subscribe and onSubscribe on a specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>'s <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a>.</div>
</td>
</tr>
<tr id="i322" class="altColor">
<td class="colFirst"><code>&lt;E extends org.reactivestreams.Subscriber&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;<br>E</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#subscribeWith-E-">subscribeWith</a></span>(E&nbsp;subscriber)</code>
<div class="block">Subscribe a provided instance of a subclass of <code>Subscriber</code> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 and return said instance for further chaining calls.</div>
</td>
</tr>
<tr id="i323" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#switchIfEmpty-org.reactivestreams.Publisher-">switchIfEmpty</a></span>(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;alternate)</code>
<div class="block">Switch to an alternative <code>Publisher</code> if this sequence is completed without any data.</div>
</td>
</tr>
<tr id="i324" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#switchMap-java.util.function.Function-">switchMap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;fn)</code>
<div class="block">Switch to a new <code>Publisher</code> generated via a <code>Function</code> whenever
 this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> produces an item.</div>
</td>
</tr>
<tr id="i325" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#switchMap-java.util.function.Function-int-">switchMap</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;fn,
         int&nbsp;prefetch)</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">to be removed in 3.6.0 at the earliest. In 3.5.0, you should replace
 calls with prefetch=0 with calls to switchMap(fn), as the default behavior of the
 single-parameter variant will then change to prefetch=0.</span></div>
</div>
</td>
</tr>
<tr id="i326" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#switchOnFirst-java.util.function.BiFunction-">switchOnFirst</a></span>(java.util.function.BiFunction&lt;<a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口">Signal</a>&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;transformer)</code>
<div class="block">Transform the current <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> once it emits its first element, making a
 conditional transformation possible.</div>
</td>
</tr>
<tr id="i327" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#switchOnFirst-java.util.function.BiFunction-boolean-">switchOnFirst</a></span>(java.util.function.BiFunction&lt;<a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口">Signal</a>&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;transformer,
             boolean&nbsp;cancelSourceOnComplete)</code>
<div class="block">Transform the current <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> once it emits its first element, making a
 conditional transformation possible.</div>
</td>
</tr>
<tr id="i328" class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#switchOnNext-org.reactivestreams.Publisher-">switchOnNext</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;mergedPublishers)</code>
<div class="block">Creates a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that mirrors the most recently emitted <code>Publisher</code>,
 forwarding its data until a new <code>Publisher</code> comes in the source.</div>
</td>
</tr>
<tr id="i329" class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#switchOnNext-org.reactivestreams.Publisher-int-">switchOnNext</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;mergedPublishers,
            int&nbsp;prefetch)</code>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;
<div class="block"><span class="deprecationComment">to be removed in 3.6.0 at the earliest. In 3.5.0, you should replace
 calls with prefetch=0 with calls to switchOnNext(mergedPublishers), as the default
 behavior of the single-parameter variant will then change to prefetch=0.</span></div>
</div>
</td>
</tr>
<tr id="i330" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#tag-java.lang.String-java.lang.String-">tag</a></span>(java.lang.String&nbsp;key,
   java.lang.String&nbsp;value)</code>
<div class="block">Tag this flux with a key/value pair.</div>
</td>
</tr>
<tr id="i331" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#take-java.time.Duration-">take</a></span>(java.time.Duration&nbsp;timespan)</code>
<div class="block">Relay values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until the specified <code>Duration</code> elapses.</div>
</td>
</tr>
<tr id="i332" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#take-java.time.Duration-reactor.core.scheduler.Scheduler-">take</a></span>(java.time.Duration&nbsp;timespan,
    <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Relay values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until the specified <code>Duration</code> elapses,
 as measured on the specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i333" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#take-long-">take</a></span>(long&nbsp;n)</code>
<div class="block">Take only the first N values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, if available.</div>
</td>
</tr>
<tr id="i334" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#take-long-boolean-">take</a></span>(long&nbsp;n,
    boolean&nbsp;limitRequest)</code>
<div class="block">Take only the first N values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, if available.</div>
</td>
</tr>
<tr id="i335" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#takeLast-int-">takeLast</a></span>(int&nbsp;n)</code>
<div class="block">Emit the last N values this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitted before its completion.</div>
</td>
</tr>
<tr id="i336" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#takeUntil-java.util.function.Predicate-">takeUntil</a></span>(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate)</code>
<div class="block">Relay values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until the given <code>Predicate</code> matches.</div>
</td>
</tr>
<tr id="i337" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#takeUntilOther-org.reactivestreams.Publisher-">takeUntilOther</a></span>(org.reactivestreams.Publisher&lt;?&gt;&nbsp;other)</code>
<div class="block">Relay values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until the given <code>Publisher</code> emits.</div>
</td>
</tr>
<tr id="i338" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#takeWhile-java.util.function.Predicate-">takeWhile</a></span>(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;continuePredicate)</code>
<div class="block">Relay values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> while a predicate returns TRUE
 for the values (checked before each value is delivered).</div>
</td>
</tr>
<tr id="i339" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#tap-java.util.function.Function-">tap</a></span>(java.util.function.Function&lt;<a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口">ContextView</a>,<a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口">SignalListener</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;listenerGenerator)</code>
<div class="block">Tap into Reactive Streams signals emitted or received by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and notify a stateful per-<code>Subscriber</code>
 <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a>.</div>
</td>
</tr>
<tr id="i340" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#tap-reactor.core.observability.SignalListenerFactory-">tap</a></span>(<a href="../../../reactor/core/observability/SignalListenerFactory.html" title="reactor.core.observability中的接口">SignalListenerFactory</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,?&gt;&nbsp;listenerFactory)</code>
<div class="block">Tap into Reactive Streams signals emitted or received by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and notify a stateful per-<code>Subscriber</code>
 <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> created by the provided <a href="../../../reactor/core/observability/SignalListenerFactory.html" title="reactor.core.observability中的接口"><code>SignalListenerFactory</code></a>.</div>
</td>
</tr>
<tr id="i341" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#tap-java.util.function.Supplier-">tap</a></span>(java.util.function.Supplier&lt;<a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口">SignalListener</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;simpleListenerGenerator)</code>
<div class="block">Tap into Reactive Streams signals emitted or received by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and notify a stateful per-<code>Subscriber</code>
 <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a>.</div>
</td>
</tr>
<tr id="i342" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Void&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#then--">then</a></span>()</code>
<div class="block">Return a <code>Mono&lt;Void&gt;</code> that completes when this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes.</div>
</td>
</tr>
<tr id="i343" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#then-reactor.core.publisher.Mono-">then</a></span>(<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;V&gt;&nbsp;other)</code>
<div class="block">Let this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> complete then play signals from a provided <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>.</div>
</td>
</tr>
<tr id="i344" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Void&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#thenEmpty-org.reactivestreams.Publisher-">thenEmpty</a></span>(org.reactivestreams.Publisher&lt;java.lang.Void&gt;&nbsp;other)</code>
<div class="block">Return a <code>Mono&lt;Void&gt;</code> that waits for this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> to complete then
 for a supplied <code>Publisher&lt;Void&gt;</code> to also complete.</div>
</td>
</tr>
<tr id="i345" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#thenMany-org.reactivestreams.Publisher-">thenMany</a></span>(org.reactivestreams.Publisher&lt;V&gt;&nbsp;other)</code>
<div class="block">Let this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> complete then play another <code>Publisher</code>.</div>
</td>
</tr>
<tr id="i346" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Timed.html" title="reactor.core.publisher中的接口">Timed</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#timed--">timed</a></span>()</code>
<div class="block">Times <code>Subscriber.onNext(Object)</code> events, encapsulated into a <a href="../../../reactor/core/publisher/Timed.html" title="reactor.core.publisher中的接口"><code>Timed</code></a> object
 that lets downstream consumer look at various time information gathered with nanosecond
 resolution using the default clock (<a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>Schedulers.parallel()</code></a>):
 
     <a href="../../../reactor/core/publisher/Timed.html#elapsed--"><code>Timed.elapsed()</code></a>: the time in nanoseconds since last event, as a <code>Duration</code>.</div>
</td>
</tr>
<tr id="i347" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Timed.html" title="reactor.core.publisher中的接口">Timed</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#timed-reactor.core.scheduler.Scheduler-">timed</a></span>(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;clock)</code>
<div class="block">Times <code>Subscriber.onNext(Object)</code> events, encapsulated into a <a href="../../../reactor/core/publisher/Timed.html" title="reactor.core.publisher中的接口"><code>Timed</code></a> object
 that lets downstream consumer look at various time information gathered with nanosecond
 resolution using the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> as a clock:
 
     <a href="../../../reactor/core/publisher/Timed.html#elapsed--"><code>Timed.elapsed()</code></a>: the time in nanoseconds since last event, as a <code>Duration</code>.</div>
</td>
</tr>
<tr id="i348" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#timeout-java.time.Duration-">timeout</a></span>(java.time.Duration&nbsp;timeout)</code>
<div class="block">Propagate a <code>TimeoutException</code> as soon as no item is emitted within the
 given <code>Duration</code> from the previous emission (or the subscription for the first item).</div>
</td>
</tr>
<tr id="i349" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#timeout-java.time.Duration-org.reactivestreams.Publisher-">timeout</a></span>(java.time.Duration&nbsp;timeout,
       org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;fallback)</code>
<div class="block">Switch to a fallback <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> as soon as no item is emitted within the
 given <code>Duration</code> from the previous emission (or the subscription for the first item).</div>
</td>
</tr>
<tr id="i350" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#timeout-java.time.Duration-org.reactivestreams.Publisher-reactor.core.scheduler.Scheduler-">timeout</a></span>(java.time.Duration&nbsp;timeout,
       org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;fallback,
       <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Switch to a fallback <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> as soon as no item is emitted within the
 given <code>Duration</code> from the previous emission (or the subscription for the
 first item), as measured on the specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i351" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#timeout-java.time.Duration-reactor.core.scheduler.Scheduler-">timeout</a></span>(java.time.Duration&nbsp;timeout,
       <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Propagate a <code>TimeoutException</code> as soon as no item is emitted within the
 given <code>Duration</code> from the previous emission (or the subscription for the first
 item), as measured by the specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.</div>
</td>
</tr>
<tr id="i352" class="altColor">
<td class="colFirst"><code>&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#timeout-org.reactivestreams.Publisher-">timeout</a></span>(org.reactivestreams.Publisher&lt;U&gt;&nbsp;firstTimeout)</code>
<div class="block">Signal a <code>TimeoutException</code> in case the first item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> has
 not been emitted before the given <code>Publisher</code> emits.</div>
</td>
</tr>
<tr id="i353" class="rowColor">
<td class="colFirst"><code>&lt;U,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#timeout-org.reactivestreams.Publisher-java.util.function.Function-">timeout</a></span>(org.reactivestreams.Publisher&lt;U&gt;&nbsp;firstTimeout,
       java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;nextTimeoutFactory)</code>
<div class="block">Signal a <code>TimeoutException</code> in case the first item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> has
 not been emitted before the <code>firstTimeout</code> <code>Publisher</code> emits, and whenever
 each subsequent elements is not emitted before a <code>Publisher</code> generated from
 the latest element signals.</div>
</td>
</tr>
<tr id="i354" class="altColor">
<td class="colFirst"><code>&lt;U,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#timeout-org.reactivestreams.Publisher-java.util.function.Function-org.reactivestreams.Publisher-">timeout</a></span>(org.reactivestreams.Publisher&lt;U&gt;&nbsp;firstTimeout,
       java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;nextTimeoutFactory,
       org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;fallback)</code>
<div class="block">Switch to a fallback <code>Publisher</code> in case the first item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> has
 not been emitted before the <code>firstTimeout</code> <code>Publisher</code> emits, and whenever
 each subsequent elements is not emitted before a <code>Publisher</code> generated from
 the latest element signals.</div>
</td>
</tr>
<tr id="i355" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;java.lang.Long,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#timestamp--">timestamp</a></span>()</code>
<div class="block">Emit a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a> pair of T1 the current clock time in
 millis (as a <code>Long</code> measured by the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel</code></a>
 Scheduler) and T2 the emitted data (as a <code>T</code>), for each item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i356" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;java.lang.Long,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#timestamp-reactor.core.scheduler.Scheduler-">timestamp</a></span>(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</code>
<div class="block">Emit a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a> pair of T1 the current clock time in
 millis (as a <code>Long</code> measured by the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>) and T2
 the emitted data (as a <code>T</code>), for each item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i357" class="rowColor">
<td class="colFirst"><code>java.lang.Iterable&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#toIterable--">toIterable</a></span>()</code>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a lazy <code>Iterable</code> blocking on
 <code>Iterator.next()</code> calls.</div>
</td>
</tr>
<tr id="i358" class="altColor">
<td class="colFirst"><code>java.lang.Iterable&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#toIterable-int-">toIterable</a></span>(int&nbsp;batchSize)</code>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a lazy <code>Iterable</code> blocking on
 <code>Iterator.next()</code> calls.</div>
</td>
</tr>
<tr id="i359" class="rowColor">
<td class="colFirst"><code>java.lang.Iterable&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#toIterable-int-java.util.function.Supplier-">toIterable</a></span>(int&nbsp;batchSize,
          java.util.function.Supplier&lt;java.util.Queue&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;queueProvider)</code>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a lazy <code>Iterable</code> blocking on
 <code>Iterator.next()</code> calls.</div>
</td>
</tr>
<tr id="i360" class="altColor">
<td class="colFirst"><code>java.util.stream.Stream&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#toStream--">toStream</a></span>()</code>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a lazy <code>Stream</code> blocking for each source
 <code>onNext</code> call.</div>
</td>
</tr>
<tr id="i361" class="rowColor">
<td class="colFirst"><code>java.util.stream.Stream&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#toStream-int-">toStream</a></span>(int&nbsp;batchSize)</code>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a lazy <code>Stream</code> blocking for each source
 <code>onNext</code> call.</div>
</td>
</tr>
<tr id="i362" class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#toString--">toString</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i363" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#transform-java.util.function.Function-">transform</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;transformer)</code>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> in order to generate a target <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
</td>
</tr>
<tr id="i364" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#transformDeferred-java.util.function.Function-">transformDeferred</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;transformer)</code>
<div class="block">Defer the transformation of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> in order to generate a target <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> type.</div>
</td>
</tr>
<tr id="i365" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#transformDeferredContextual-java.util.function.BiFunction-">transformDeferredContextual</a></span>(java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,? super <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口">ContextView</a>,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;transformer)</code>
<div class="block">Defer the given transformation to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> in order to generate a
 target <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> type.</div>
</td>
</tr>
<tr id="i366" class="altColor">
<td class="colFirst"><code>static &lt;T,D&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">using</a></span>(java.util.concurrent.Callable&lt;? extends D&gt;&nbsp;resourceSupplier,
     java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sourceSupplier,
     java.util.function.Consumer&lt;? super D&gt;&nbsp;resourceCleanup)</code>
<div class="block">Uses a resource, generated by a supplier for each individual Subscriber, while streaming the values from a
 Publisher derived from the same resource and makes sure the resource is released if the sequence terminates or
 the Subscriber cancels.</div>
</td>
</tr>
<tr id="i367" class="rowColor">
<td class="colFirst"><code>static &lt;T,D&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-boolean-">using</a></span>(java.util.concurrent.Callable&lt;? extends D&gt;&nbsp;resourceSupplier,
     java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sourceSupplier,
     java.util.function.Consumer&lt;? super D&gt;&nbsp;resourceCleanup,
     boolean&nbsp;eager)</code>
<div class="block">Uses a resource, generated by a supplier for each individual Subscriber, while streaming the values from a
 Publisher derived from the same resource and makes sure the resource is released if the sequence terminates or
 the Subscriber cancels.</div>
</td>
</tr>
<tr id="i368" class="altColor">
<td class="colFirst"><code>static &lt;T,D&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-">usingWhen</a></span>(org.reactivestreams.Publisher&lt;D&gt;&nbsp;resourceSupplier,
         java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;resourceClosure,
         java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;asyncCleanup)</code>
<div class="block">Uses a resource, generated by a <code>Publisher</code> for each individual <code>Subscriber</code>,
 while streaming the values from a <code>Publisher</code> derived from the same resource.</div>
</td>
</tr>
<tr id="i369" class="rowColor">
<td class="colFirst"><code>static &lt;T,D&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-java.util.function.Function-">usingWhen</a></span>(org.reactivestreams.Publisher&lt;D&gt;&nbsp;resourceSupplier,
         java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;resourceClosure,
         java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;asyncComplete,
         java.util.function.BiFunction&lt;? super D,? super java.lang.Throwable,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;asyncError,
         java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;asyncCancel)</code>
<div class="block">Uses a resource, generated by a <code>Publisher</code> for each individual <code>Subscriber</code>,
 while streaming the values from a <code>Publisher</code> derived from the same resource.</div>
</td>
</tr>
<tr id="i370" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#window-java.time.Duration-">window</a></span>(java.time.Duration&nbsp;windowingTimespan)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into continuous, non-overlapping windows that open
 for a <code>windowingTimespan</code> <code>Duration</code> (as measured on the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel</code></a>
 Scheduler).</div>
</td>
</tr>
<tr id="i371" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#window-java.time.Duration-java.time.Duration-">window</a></span>(java.time.Duration&nbsp;windowingTimespan,
      java.time.Duration&nbsp;openWindowEvery)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows that open
 for a given <code>windowingTimespan</code> <code>Duration</code>, after which it closes with onComplete.</div>
</td>
</tr>
<tr id="i372" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#window-java.time.Duration-java.time.Duration-reactor.core.scheduler.Scheduler-">window</a></span>(java.time.Duration&nbsp;windowingTimespan,
      java.time.Duration&nbsp;openWindowEvery,
      <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows that open
 for a given <code>windowingTimespan</code> <code>Duration</code>, after which it closes with onComplete.</div>
</td>
</tr>
<tr id="i373" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#window-java.time.Duration-reactor.core.scheduler.Scheduler-">window</a></span>(java.time.Duration&nbsp;windowingTimespan,
      <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into continuous, non-overlapping windows that open
 for a <code>windowingTimespan</code> <code>Duration</code> (as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>).</div>
</td>
</tr>
<tr id="i374" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#window-int-">window</a></span>(int&nbsp;maxSize)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows containing
 <code>maxSize</code> elements (or less for the final window) and starting from the first item.</div>
</td>
</tr>
<tr id="i375" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#window-int-int-">window</a></span>(int&nbsp;maxSize,
      int&nbsp;skip)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows of size
 <code>maxSize</code>, that each open every <code>skip</code> elements in the source.</div>
</td>
</tr>
<tr id="i376" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#window-org.reactivestreams.Publisher-">window</a></span>(org.reactivestreams.Publisher&lt;?&gt;&nbsp;boundary)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into continuous, non-overlapping windows
 where the window boundary is signalled by another <code>Publisher</code>

 
 <img class="marble" src="doc-files/marbles/windowWithBoundary.svg" alt="">

 
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source.</div>
</td>
</tr>
<tr id="i377" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowTimeout-int-java.time.Duration-">windowTimeout</a></span>(int&nbsp;maxSize,
             java.time.Duration&nbsp;maxTime)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows containing
 <code>maxSize</code> elements (or less for the final window) and starting from the first item.</div>
</td>
</tr>
<tr id="i378" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowTimeout-int-java.time.Duration-boolean-">windowTimeout</a></span>(int&nbsp;maxSize,
             java.time.Duration&nbsp;maxTime,
             boolean&nbsp;fairBackpressure)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows containing
 <code>maxSize</code> elements (or less for the final window) and starting from the first item.</div>
</td>
</tr>
<tr id="i379" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowTimeout-int-java.time.Duration-reactor.core.scheduler.Scheduler-">windowTimeout</a></span>(int&nbsp;maxSize,
             java.time.Duration&nbsp;maxTime,
             <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows containing
 <code>maxSize</code> elements (or less for the final window) and starting from the first item.</div>
</td>
</tr>
<tr id="i380" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowTimeout-int-java.time.Duration-reactor.core.scheduler.Scheduler-boolean-">windowTimeout</a></span>(int&nbsp;maxSize,
             java.time.Duration&nbsp;maxTime,
             <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer,
             boolean&nbsp;fairBackpressure)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows containing
 <code>maxSize</code> elements (or less for the final window) and starting from the first item.</div>
</td>
</tr>
<tr id="i381" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-">windowUntil</a></span>(java.util.function.Predicate&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;boundaryTrigger)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows delimited by the
 given predicate.</div>
</td>
</tr>
<tr id="i382" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-boolean-">windowUntil</a></span>(java.util.function.Predicate&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;boundaryTrigger,
           boolean&nbsp;cutBefore)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows delimited by the
 given predicate.</div>
</td>
</tr>
<tr id="i383" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-boolean-int-">windowUntil</a></span>(java.util.function.Predicate&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;boundaryTrigger,
           boolean&nbsp;cutBefore,
           int&nbsp;prefetch)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows delimited by the given
 predicate and using a prefetch.</div>
</td>
</tr>
<tr id="i384" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowUntilChanged--">windowUntilChanged</a></span>()</code>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another) into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows.</div>
</td>
</tr>
<tr id="i385" class="rowColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowUntilChanged-java.util.function.Function-java.util.function.BiPredicate-">windowUntilChanged</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector,
                  java.util.function.BiPredicate&lt;? super V,? super V&gt;&nbsp;keyComparator)</code>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another), as compared by a key extracted through the user provided <code>Function</code> and compared using a supplied <code>BiPredicate</code>, into multiple
 <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows.</div>
</td>
</tr>
<tr id="i386" class="altColor">
<td class="colFirst"><code>&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowUntilChanged-java.util.function.Function-">windowUntilChanged</a></span>(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super V&gt;&nbsp;keySelector)</code>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another), as compared by a key extracted through the user provided <code>Function</code>, into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows.</div>
</td>
</tr>
<tr id="i387" class="rowColor">
<td class="colFirst"><code>&lt;U,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowWhen-org.reactivestreams.Publisher-java.util.function.Function-">windowWhen</a></span>(org.reactivestreams.Publisher&lt;U&gt;&nbsp;bucketOpening,
          java.util.function.Function&lt;? super U,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;closeSelector)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into potentially overlapping windows controlled by items of a
 start <code>Publisher</code> and end <code>Publisher</code> derived from the start values.</div>
</td>
</tr>
<tr id="i388" class="altColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowWhile-java.util.function.Predicate-">windowWhile</a></span>(java.util.function.Predicate&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;inclusionPredicate)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows that stay open
 while a given predicate matches the source elements.</div>
</td>
</tr>
<tr id="i389" class="rowColor">
<td class="colFirst"><code><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#windowWhile-java.util.function.Predicate-int-">windowWhile</a></span>(java.util.function.Predicate&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;inclusionPredicate,
           int&nbsp;prefetch)</code>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows that stay open
 while a given predicate matches the source elements.</div>
</td>
</tr>
<tr id="i390" class="altColor">
<td class="colFirst"><code>&lt;U,R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#withLatestFrom-org.reactivestreams.Publisher-java.util.function.BiFunction-">withLatestFrom</a></span>(org.reactivestreams.Publisher&lt;? extends U&gt;&nbsp;other,
              java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super U,? extends R&gt;&nbsp;resultSelector)</code>
<div class="block">Combine the most recently emitted values from both this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and another
 <code>Publisher</code> through a <code>BiFunction</code> and emits the result.</div>
</td>
</tr>
<tr id="i391" class="rowColor">
<td class="colFirst"><code>static &lt;I,O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-java.util.function.Function-int-org.reactivestreams.Publisher...-">zip</a></span>(java.util.function.Function&lt;? super java.lang.Object[],? extends O&gt;&nbsp;combinator,
   int&nbsp;prefetch,
   org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block">Zip multiple sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator).</div>
</td>
</tr>
<tr id="i392" class="altColor">
<td class="colFirst"><code>static &lt;I,O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher...-">zip</a></span>(java.util.function.Function&lt;? super java.lang.Object[],? extends O&gt;&nbsp;combinator,
   org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</code>
<div class="block">Zip multiple sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator).</div>
</td>
</tr>
<tr id="i393" class="rowColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-java.lang.Iterable-java.util.function.Function-">zip</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;sources,
   java.util.function.Function&lt;? super java.lang.Object[],? extends O&gt;&nbsp;combinator)</code>
<div class="block">Zip multiple sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator).</div>
</td>
</tr>
<tr id="i394" class="altColor">
<td class="colFirst"><code>static &lt;O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-java.lang.Iterable-int-java.util.function.Function-">zip</a></span>(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;sources,
   int&nbsp;prefetch,
   java.util.function.Function&lt;? super java.lang.Object[],? extends O&gt;&nbsp;combinator)</code>
<div class="block">Zip multiple sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator).</div>
</td>
</tr>
<tr id="i395" class="rowColor">
<td class="colFirst"><code>static &lt;TUPLE extends <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>,V&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-org.reactivestreams.Publisher-java.util.function.Function-">zip</a></span>(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;sources,
   java.util.function.Function&lt;? super TUPLE,? extends V&gt;&nbsp;combinator)</code>
<div class="block">Zip multiple sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator).</div>
</td>
</tr>
<tr id="i396" class="altColor">
<td class="colFirst"><code>static &lt;T1,T2&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;T1,T2&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">zip</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
   org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2)</code>
<div class="block">Zip two sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a>.</div>
</td>
</tr>
<tr id="i397" class="rowColor">
<td class="colFirst"><code>static &lt;T1,T2,O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.BiFunction-">zip</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
   org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
   java.util.function.BiFunction&lt;? super T1,? super T2,? extends O&gt;&nbsp;combinator)</code>
<div class="block">Zip two sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator).</div>
</td>
</tr>
<tr id="i398" class="altColor">
<td class="colFirst"><code>static &lt;T1,T2,T3&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple3.html" title="reactor.util.function中的类">Tuple3</a>&lt;T1,T2,T3&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">zip</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
   org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
   org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3)</code>
<div class="block">Zip three sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple3.html" title="reactor.util.function中的类"><code>Tuple3</code></a>.</div>
</td>
</tr>
<tr id="i399" class="rowColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,T4&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple4.html" title="reactor.util.function中的类">Tuple4</a>&lt;T1,T2,T3,T4&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">zip</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
   org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
   org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
   org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4)</code>
<div class="block">Zip four sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple4.html" title="reactor.util.function中的类"><code>Tuple4</code></a>.</div>
</td>
</tr>
<tr id="i400" class="altColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,T4,T5&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple5.html" title="reactor.util.function中的类">Tuple5</a>&lt;T1,T2,T3,T4,T5&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">zip</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
   org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
   org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
   org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
   org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5)</code>
<div class="block">Zip five sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple5.html" title="reactor.util.function中的类"><code>Tuple5</code></a>.</div>
</td>
</tr>
<tr id="i401" class="rowColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,T4,T5,T6&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple6.html" title="reactor.util.function中的类">Tuple6</a>&lt;T1,T2,T3,T4,T5,T6&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">zip</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
   org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
   org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
   org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
   org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5,
   org.reactivestreams.Publisher&lt;? extends T6&gt;&nbsp;source6)</code>
<div class="block">Zip six sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple6.html" title="reactor.util.function中的类"><code>Tuple6</code></a>.</div>
</td>
</tr>
<tr id="i402" class="altColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,T4,T5,T6,T7&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple7.html" title="reactor.util.function中的类">Tuple7</a>&lt;T1,T2,T3,T4,T5,T6,T7&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">zip</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
   org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
   org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
   org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
   org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5,
   org.reactivestreams.Publisher&lt;? extends T6&gt;&nbsp;source6,
   org.reactivestreams.Publisher&lt;? extends T7&gt;&nbsp;source7)</code>
<div class="block">Zip seven sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple7.html" title="reactor.util.function中的类"><code>Tuple7</code></a>.</div>
</td>
</tr>
<tr id="i403" class="rowColor">
<td class="colFirst"><code>static &lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;<br><a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple8.html" title="reactor.util.function中的类">Tuple8</a>&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">zip</a></span>(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
   org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
   org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
   org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
   org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5,
   org.reactivestreams.Publisher&lt;? extends T6&gt;&nbsp;source6,
   org.reactivestreams.Publisher&lt;? extends T7&gt;&nbsp;source7,
   org.reactivestreams.Publisher&lt;? extends T8&gt;&nbsp;source8)</code>
<div class="block">Zip eight sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple8.html" title="reactor.util.function中的类"><code>Tuple8</code></a>.</div>
</td>
</tr>
<tr id="i404" class="altColor">
<td class="colFirst"><code>&lt;T2&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,T2&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zipWith-org.reactivestreams.Publisher-">zipWith</a></span>(org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2)</code>
<div class="block">Zip this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with another <code>Publisher</code> source, that is to say wait
 for both to emit one element and combine these elements once into a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a>.</div>
</td>
</tr>
<tr id="i405" class="rowColor">
<td class="colFirst"><code>&lt;T2,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zipWith-org.reactivestreams.Publisher-java.util.function.BiFunction-">zipWith</a></span>(org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
       java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super T2,? extends V&gt;&nbsp;combinator)</code>
<div class="block">Zip this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with another <code>Publisher</code> source, that is to say wait
 for both to emit one element and combine these elements using a <code>combinator</code>
 <code>BiFunction</code>
 The operator will continue doing so until any of the sources completes.</div>
</td>
</tr>
<tr id="i406" class="altColor">
<td class="colFirst"><code>&lt;T2&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,T2&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zipWith-org.reactivestreams.Publisher-int-">zipWith</a></span>(org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
       int&nbsp;prefetch)</code>
<div class="block">Zip this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with another <code>Publisher</code> source, that is to say wait
 for both to emit one element and combine these elements once into a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a>.</div>
</td>
</tr>
<tr id="i407" class="rowColor">
<td class="colFirst"><code>&lt;T2,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zipWith-org.reactivestreams.Publisher-int-java.util.function.BiFunction-">zipWith</a></span>(org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
       int&nbsp;prefetch,
       java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super T2,? extends V&gt;&nbsp;combinator)</code>
<div class="block">Zip this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with another <code>Publisher</code> source, that is to say wait
 for both to emit one element and combine these elements using a <code>combinator</code>
 <code>BiFunction</code>
 The operator will continue doing so until any of the sources completes.</div>
</td>
</tr>
<tr id="i408" class="altColor">
<td class="colFirst"><code>&lt;T2&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,T2&gt;&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zipWithIterable-java.lang.Iterable-">zipWithIterable</a></span>(java.lang.Iterable&lt;? extends T2&gt;&nbsp;iterable)</code>
<div class="block">Zip elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the content of an <code>Iterable</code>, that is
 to say combine one element from each, pairwise, into a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a>.</div>
</td>
</tr>
<tr id="i409" class="rowColor">
<td class="colFirst"><code>&lt;T2,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../reactor/core/publisher/Flux.html#zipWithIterable-java.lang.Iterable-java.util.function.BiFunction-">zipWithIterable</a></span>(java.lang.Iterable&lt;? extends T2&gt;&nbsp;iterable,
               java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super T2,? extends V&gt;&nbsp;zipper)</code>
<div class="block">Zip elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the content of an <code>Iterable</code>, that is
 to say combine one element from each, pairwise, using the given zipper <code>BiFunction</code>.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>从类继承的方法&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>构造器详细资料</h3>
<a name="Flux--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Flux</h4>
<pre>public&nbsp;Flux()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>方法详细资料</h3>
<a name="combineLatest-java.util.function.Function-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineLatest</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;T,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;combineLatest(java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator,
                                                        org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of the <code>Publisher</code> sources.
 <p>
 <img class="marble" src="doc-files/marbles/combineLatest.svg" alt="">

 <p><strong>Discard Support:</strong> This operator is NOT suited for types that need guaranteed discard of unpropagated elements, as
 it doesn't track which elements have been used by the combinator and which haven't. Furthermore, elements can and
 will be passed to the combinator multiple times.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - type of the value from sources</dd>
<dd><code>V</code> - The produced output after transformation by the given combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The <code>Publisher</code> sources to combine values from</dd>
<dd><code>combinator</code> - The aggregate function that will receive the latest value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> based on the produced combinations</dd>
</dl>
</li>
</ul>
<a name="combineLatest-java.util.function.Function-int-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineLatest</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;T,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;combineLatest(java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator,
                                                        int&nbsp;prefetch,
                                                        org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of the <code>Publisher</code> sources.
 <p>
 <img class="marble" src="doc-files/marbles/combineLatest.svg" alt="">

 <p><strong>Discard Support:</strong> This operator is NOT suited for types that need guaranteed discard of unpropagated elements, as
 it doesn't track which elements have been used by the combinator and which haven't. Furthermore, elements can and
 will be passed to the combinator multiple times.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - type of the value from sources</dd>
<dd><code>V</code> - The produced output after transformation by the given combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The <code>Publisher</code> sources to combine values from</dd>
<dd><code>prefetch</code> - The demand sent to each combined source <code>Publisher</code></dd>
<dd><code>combinator</code> - The aggregate function that will receive the latest value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> based on the produced combinations</dd>
</dl>
</li>
</ul>
<a name="combineLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineLatest</h4>
<pre>public static&nbsp;&lt;T1,T2,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;combineLatest(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                              org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                              java.util.function.BiFunction&lt;? super T1,? super T2,? extends V&gt;&nbsp;combinator)</pre>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of two <code>Publisher</code> sources.
 <p>
 <img class="marble" src="doc-files/marbles/combineLatest.svg" alt="">

 <p><strong>Discard Support:</strong> This operator is NOT suited for types that need guaranteed discard of unpropagated elements, as
 it doesn't track which elements have been used by the combinator and which haven't. Furthermore, elements can and
 will be passed to the combinator multiple times.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>V</code> - The produced output after transformation by the given combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first <code>Publisher</code> source to combine values from</dd>
<dd><code>source2</code> - The second <code>Publisher</code> source to combine values from</dd>
<dd><code>combinator</code> - The aggregate function that will receive the latest value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> based on the produced combinations</dd>
</dl>
</li>
</ul>
<a name="combineLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineLatest</h4>
<pre>public static&nbsp;&lt;T1,T2,T3,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;combineLatest(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                                 org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                                 org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
                                                 java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</pre>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of three <code>Publisher</code> sources.
 <p>
 <img class="marble" src="doc-files/marbles/combineLatest.svg" alt="">

 <p><strong>Discard Support:</strong> This operator is NOT suited for types that need guaranteed discard of unpropagated elements, as
 it doesn't track which elements have been used by the combinator and which haven't. Furthermore, elements can and
 will be passed to the combinator multiple times.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>T3</code> - type of the value from source3</dd>
<dd><code>V</code> - The produced output after transformation by the given combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first <code>Publisher</code> source to combine values from</dd>
<dd><code>source2</code> - The second <code>Publisher</code> source to combine values from</dd>
<dd><code>source3</code> - The third <code>Publisher</code> source to combine values from</dd>
<dd><code>combinator</code> - The aggregate function that will receive the latest value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> based on the produced combinations</dd>
</dl>
</li>
</ul>
<a name="combineLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineLatest</h4>
<pre>public static&nbsp;&lt;T1,T2,T3,T4,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;combineLatest(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                                    org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                                    org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
                                                    org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
                                                    java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</pre>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of four <code>Publisher</code> sources.
 <p>
 <img class="marble" src="doc-files/marbles/combineLatest.svg" alt="">

 <p><strong>Discard Support:</strong> This operator is NOT suited for types that need guaranteed discard of unpropagated elements, as
 it doesn't track which elements have been used by the combinator and which haven't. Furthermore, elements can and
 will be passed to the combinator multiple times.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>T3</code> - type of the value from source3</dd>
<dd><code>T4</code> - type of the value from source4</dd>
<dd><code>V</code> - The produced output after transformation by the given combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first <code>Publisher</code> source to combine values from</dd>
<dd><code>source2</code> - The second <code>Publisher</code> source to combine values from</dd>
<dd><code>source3</code> - The third <code>Publisher</code> source to combine values from</dd>
<dd><code>source4</code> - The fourth <code>Publisher</code> source to combine values from</dd>
<dd><code>combinator</code> - The aggregate function that will receive the latest value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> based on the produced combinations</dd>
</dl>
</li>
</ul>
<a name="combineLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineLatest</h4>
<pre>public static&nbsp;&lt;T1,T2,T3,T4,T5,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;combineLatest(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                                       org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                                       org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
                                                       org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
                                                       org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5,
                                                       java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</pre>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of five <code>Publisher</code> sources.
 <p>
 <img class="marble" src="doc-files/marbles/combineLatest.svg" alt="">

 <p><strong>Discard Support:</strong> This operator is NOT suited for types that need guaranteed discard of unpropagated elements, as
 it doesn't track which elements have been used by the combinator and which haven't. Furthermore, elements can and
 will be passed to the combinator multiple times.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>T3</code> - type of the value from source3</dd>
<dd><code>T4</code> - type of the value from source4</dd>
<dd><code>T5</code> - type of the value from source5</dd>
<dd><code>V</code> - The produced output after transformation by the given combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first <code>Publisher</code> source to combine values from</dd>
<dd><code>source2</code> - The second <code>Publisher</code> source to combine values from</dd>
<dd><code>source3</code> - The third <code>Publisher</code> source to combine values from</dd>
<dd><code>source4</code> - The fourth <code>Publisher</code> source to combine values from</dd>
<dd><code>source5</code> - The fifth <code>Publisher</code> source to combine values from</dd>
<dd><code>combinator</code> - The aggregate function that will receive the latest value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> based on the produced combinations</dd>
</dl>
</li>
</ul>
<a name="combineLatest-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineLatest</h4>
<pre>public static&nbsp;&lt;T1,T2,T3,T4,T5,T6,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;combineLatest(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                                          org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                                          org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
                                                          org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
                                                          org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5,
                                                          org.reactivestreams.Publisher&lt;? extends T6&gt;&nbsp;source6,
                                                          java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</pre>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each of six <code>Publisher</code> sources.
 <p>
 <img class="marble" src="doc-files/marbles/combineLatest.svg" alt="">

 <p><strong>Discard Support:</strong> This operator is NOT suited for types that need guaranteed discard of unpropagated elements, as
 it doesn't track which elements have been used by the combinator and which haven't. Furthermore, elements can and
 will be passed to the combinator multiple times.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>T3</code> - type of the value from source3</dd>
<dd><code>T4</code> - type of the value from source4</dd>
<dd><code>T5</code> - type of the value from source5</dd>
<dd><code>T6</code> - type of the value from source6</dd>
<dd><code>V</code> - The produced output after transformation by the given combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first <code>Publisher</code> source to combine values from</dd>
<dd><code>source2</code> - The second <code>Publisher</code> source to combine values from</dd>
<dd><code>source3</code> - The third <code>Publisher</code> source to combine values from</dd>
<dd><code>source4</code> - The fourth <code>Publisher</code> source to combine values from</dd>
<dd><code>source5</code> - The fifth <code>Publisher</code> source to combine values from</dd>
<dd><code>source6</code> - The sixth <code>Publisher</code> source to combine values from</dd>
<dd><code>combinator</code> - The aggregate function that will receive the latest value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> based on the produced combinations</dd>
</dl>
</li>
</ul>
<a name="combineLatest-java.lang.Iterable-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineLatest</h4>
<pre>public static&nbsp;&lt;T,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;combineLatest(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                                          java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</pre>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each
 of the <code>Publisher</code> sources provided in an <code>Iterable</code>.
 <p>
 <img class="marble" src="doc-files/marbles/combineLatest.svg" alt="">

 <p><strong>Discard Support:</strong> This operator is NOT suited for types that need guaranteed discard of unpropagated elements, as
 it doesn't track which elements have been used by the combinator and which haven't. Furthermore, elements can and
 will be passed to the combinator multiple times.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The common base type of the values from sources</dd>
<dd><code>V</code> - The produced output after transformation by the given combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The list of <code>Publisher</code> sources to combine values from</dd>
<dd><code>combinator</code> - The aggregate function that will receive the latest value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> based on the produced combinations</dd>
</dl>
</li>
</ul>
<a name="combineLatest-java.lang.Iterable-int-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>combineLatest</h4>
<pre>public static&nbsp;&lt;T,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;combineLatest(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                                          int&nbsp;prefetch,
                                          java.util.function.Function&lt;java.lang.Object[],V&gt;&nbsp;combinator)</pre>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> whose data are generated by the combination of <strong>the
 most recently published</strong> value from each
 of the <code>Publisher</code> sources provided in an <code>Iterable</code>.
 <p>
 <img class="marble" src="doc-files/marbles/combineLatest.svg" alt="">

 <p><strong>Discard Support:</strong> This operator is NOT suited for types that need guaranteed discard of unpropagated elements, as
 it doesn't track which elements have been used by the combinator and which haven't. Furthermore, elements can and
 will be passed to the combinator multiple times.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The common base type of the values from sources</dd>
<dd><code>V</code> - The produced output after transformation by the given combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The list of <code>Publisher</code> sources to combine values from</dd>
<dd><code>prefetch</code> - demand produced to each combined source <code>Publisher</code></dd>
<dd><code>combinator</code> - The aggregate function that will receive the latest value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> based on the produced combinations</dd>
</dl>
</li>
</ul>
<a name="concat-java.lang.Iterable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;concat(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources)</pre>
<div class="block">Concatenate all sources provided in an <code>Iterable</code>, forwarding elements
 emitted by the sources downstream.
 <p>
 Concatenation is achieved by sequentially subscribing to the first source then
 waiting for it to complete before subscribing to the next, and so on until the
 last source completes. Any error interrupts the sequence immediately and is
 forwarded downstream.
 <p>
 <img class="marble" src="doc-files/marbles/concatVarSources.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The <code>Iterable</code> of <code>Publisher</code> to concatenate</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> concatenating all source sequences</dd>
</dl>
</li>
</ul>
<a name="concatWithValues-java.lang.Object:A-">
<!--   -->
</a><a name="concatWithValues-T...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatWithValues</h4>
<pre>@SafeVarargs
public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;concatWithValues(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>...&nbsp;values)</pre>
<div class="block">Concatenates the values to the end of the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 <p>
 <img class="marble" src="doc-files/marbles/concatWithValues.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>values</code> - The values to concatenate</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> concatenating all source sequences</dd>
</dl>
</li>
</ul>
<a name="concat-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;concat(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources)</pre>
<div class="block">Concatenate all sources emitted as an onNext signal from a parent <code>Publisher</code>,
 forwarding elements emitted by the sources downstream.
 <p>
 Concatenation is achieved by sequentially subscribing to the first source then
 waiting for it to complete before subscribing to the next, and so on until the
 last source completes. Any error interrupts the sequence immediately and is
 forwarded downstream.
 <p>
 <img class="marble" src="doc-files/marbles/concatAsyncSources.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The <code>Publisher</code> of <code>Publisher</code> to concatenate</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> concatenating all inner sources sequences</dd>
</dl>
</li>
</ul>
<a name="concat-org.reactivestreams.Publisher-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;concat(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                                 int&nbsp;prefetch)</pre>
<div class="block">Concatenate all sources emitted as an onNext signal from a parent <code>Publisher</code>,
 forwarding elements emitted by the sources downstream.
 <p>
 Concatenation is achieved by sequentially subscribing to the first source then
 waiting for it to complete before subscribing to the next, and so on until the
 last source completes. Any error interrupts the sequence immediately and is
 forwarded downstream.
 <p>
 <img class="marble" src="doc-files/marbles/concatAsyncSources.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The <code>Publisher</code> of <code>Publisher</code> to concatenate</dd>
<dd><code>prefetch</code> - the number of Publishers to prefetch from the outer <code>Publisher</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> concatenating all inner sources sequences</dd>
</dl>
</li>
</ul>
<a name="concat-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concat</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;concat(org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Concatenate all sources provided as a vararg, forwarding elements emitted by the
 sources downstream.
 <p>
 Concatenation is achieved by sequentially subscribing to the first source then
 waiting for it to complete before subscribing to the next, and so on until the
 last source completes. Any error interrupts the sequence immediately and is
 forwarded downstream.
 <p>
 <img class="marble" src="doc-files/marbles/concatVarSources.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The <code>Publisher</code> of <code>Publisher</code> to concat</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> concatenating all source sequences</dd>
</dl>
</li>
</ul>
<a name="concatDelayError-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatDelayError</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;concatDelayError(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources)</pre>
<div class="block">Concatenate all sources emitted as an onNext signal from a parent <code>Publisher</code>,
 forwarding elements emitted by the sources downstream.
 <p>
 Concatenation is achieved by sequentially subscribing to the first source then
 waiting for it to complete before subscribing to the next, and so on until the
 last source completes. Errors do not interrupt the main sequence but are propagated
 after the rest of the sources have had a chance to be concatenated.
 <p>
 <img class="marble" src="doc-files/marbles/concatAsyncSources.svg" alt="">


 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The <code>Publisher</code> of <code>Publisher</code> to concatenate</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> concatenating all inner sources sequences, delaying errors</dd>
</dl>
</li>
</ul>
<a name="concatDelayError-org.reactivestreams.Publisher-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatDelayError</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;concatDelayError(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                                           int&nbsp;prefetch)</pre>
<div class="block">Concatenate all sources emitted as an onNext signal from a parent <code>Publisher</code>,
 forwarding elements emitted by the sources downstream.
 <p>
 Concatenation is achieved by sequentially subscribing to the first source then
 waiting for it to complete before subscribing to the next, and so on until the
 last source completes. Errors do not interrupt the main sequence but are propagated
 after the rest of the sources have had a chance to be concatenated.
 <p>
 <img class="marble" src="doc-files/marbles/concatAsyncSources.svg" alt="">
 <p>
 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The <code>Publisher</code> of <code>Publisher</code> to concatenate</dd>
<dd><code>prefetch</code> - number of elements to prefetch from the source, to be turned into inner Publishers</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> concatenating all inner sources sequences until complete or error</dd>
</dl>
</li>
</ul>
<a name="concatDelayError-org.reactivestreams.Publisher-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatDelayError</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;concatDelayError(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                                           boolean&nbsp;delayUntilEnd,
                                           int&nbsp;prefetch)</pre>
<div class="block">Concatenate all sources emitted as an onNext signal from a parent <code>Publisher</code>,
 forwarding elements emitted by the sources downstream.
 <p>
 Concatenation is achieved by sequentially subscribing to the first source then
 waiting for it to complete before subscribing to the next, and so on until the
 last source completes.
 <p>
 Errors do not interrupt the main sequence but are propagated after the current
 concat backlog if <code>delayUntilEnd</code> is false or after all sources
 have had a chance to be concatenated if <code>delayUntilEnd</code> is true.
 <p>
 <img class="marble" src="doc-files/marbles/concatAsyncSources.svg" alt="">
 <p>

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The <code>Publisher</code> of <code>Publisher</code> to concatenate</dd>
<dd><code>delayUntilEnd</code> - delay error until all sources have been consumed instead of
 after the current source</dd>
<dd><code>prefetch</code> - the number of Publishers to prefetch from the outer <code>Publisher</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> concatenating all inner sources sequences until complete or error</dd>
</dl>
</li>
</ul>
<a name="concatDelayError-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatDelayError</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;concatDelayError(org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Concatenate all sources provided as a vararg, forwarding elements emitted by the
 sources downstream.
 <p>
 Concatenation is achieved by sequentially subscribing to the first source then
 waiting for it to complete before subscribing to the next, and so on until the
 last source completes. Errors do not interrupt the main sequence but are propagated
 after the rest of the sources have had a chance to be concatenated.
 <p>
 <img class="marble" src="doc-files/marbles/concatVarSources.svg" alt="">
 <p>

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The <code>Publisher</code> of <code>Publisher</code> to concat</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> concatenating all source sequences</dd>
</dl>
</li>
</ul>
<a name="create-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>create</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;create(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口">FluxSink</a>&lt;T&gt;&gt;&nbsp;emitter)</pre>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the capability of emitting multiple
 elements in a synchronous or asynchronous manner through the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> API.
 This includes emitting elements from multiple threads.
 <p>
 <img class="marble" src="doc-files/marbles/createForFlux.svg" alt="">
 <p>
 This Flux factory is useful if one wants to adapt some other multi-valued async API
 and not worry about cancellation and backpressure (which is handled by buffering
 all signals if the downstream can't keep up).
 <p>
 For example:

 <pre><code>
 Flux.&lt;String&gt;create(emitter -&gt; {

     ActionListener al = e -&gt; {
         emitter.next(textField.getText());
     };
     // without cleanup support:

     button.addActionListener(al);

     // with cleanup support:

     button.addActionListener(al);
     emitter.onDispose(() -> {
         button.removeListener(al);
     });
 });
 </code></pre>

 <p><strong>Discard Support:</strong> The <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> exposed by this operator buffers in case of
 overflow. The buffer is discarded when the main sequence is cancelled.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in the sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>emitter</code> - Consume the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> provided per-subscriber by Reactor to generate signals.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#push-java.util.function.Consumer-"><code>push(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a name="create-java.util.function.Consumer-reactor.core.publisher.FluxSink.OverflowStrategy-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>create</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;create(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口">FluxSink</a>&lt;T&gt;&gt;&nbsp;emitter,
                                 <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html" title="reactor.core.publisher中的枚举">FluxSink.OverflowStrategy</a>&nbsp;backpressure)</pre>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the capability of emitting multiple
 elements in a synchronous or asynchronous manner through the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> API.
 This includes emitting elements from multiple threads.
 <p>
 <img class="marble" src="doc-files/marbles/createWithOverflowStrategy.svg" alt="">
 <p>
 This Flux factory is useful if one wants to adapt some other multi-valued async API
 and not worry about cancellation and backpressure (which is handled by buffering
 all signals if the downstream can't keep up).
 <p>
 For example:

 <pre><code>
 Flux.&lt;String&gt;create(emitter -&gt; {

     ActionListener al = e -&gt; {
         emitter.next(textField.getText());
     };
     // without cleanup support:

     button.addActionListener(al);

     // with cleanup support:

     button.addActionListener(al);
     emitter.onDispose(() -> {
         button.removeListener(al);
     });
 }, FluxSink.OverflowStrategy.LATEST);
 </code></pre>

 <p><strong>Discard Support:</strong> The <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> exposed by this operator discards elements
 as relevant to the chosen <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html" title="reactor.core.publisher中的枚举"><code>FluxSink.OverflowStrategy</code></a>. For example, the <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html#DROP"><code>FluxSink.OverflowStrategy.DROP</code></a>
 discards each items as they are being dropped, while <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html#BUFFER"><code>FluxSink.OverflowStrategy.BUFFER</code></a>
 will discard the buffer upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in the sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>backpressure</code> - the backpressure mode, see <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html" title="reactor.core.publisher中的枚举"><code>FluxSink.OverflowStrategy</code></a> for the
 available backpressure modes</dd>
<dd><code>emitter</code> - Consume the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> provided per-subscriber by Reactor to generate signals.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#push-java.util.function.Consumer-reactor.core.publisher.FluxSink.OverflowStrategy-"><code>push(Consumer, reactor.core.publisher.FluxSink.OverflowStrategy)</code></a></dd>
</dl>
</li>
</ul>
<a name="push-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>push</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;push(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口">FluxSink</a>&lt;T&gt;&gt;&nbsp;emitter)</pre>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the capability of emitting multiple
 elements from a single-threaded producer through the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> API. For
 a multi-threaded capable alternative, see <a href="../../../reactor/core/publisher/Flux.html#create-java.util.function.Consumer-"><code>create(Consumer)</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/push.svg" alt="">
 <p>
 This Flux factory is useful if one wants to adapt some other single-threaded
 multi-valued async API and not worry about cancellation and backpressure (which is
 handled by buffering all signals if the downstream can't keep up).
 <p>
 For example:

 <pre><code>
 Flux.&lt;String&gt;push(emitter -&gt; {

         ActionListener al = e -&gt; {
                 emitter.next(textField.getText());
         };
         // without cleanup support:

         button.addActionListener(al);

         // with cleanup support:

         button.addActionListener(al);
         emitter.onDispose(() -> {
                 button.removeListener(al);
         });
 });
 </code></pre>

 <p><strong>Discard Support:</strong> The <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> exposed by this operator buffers in case of
 overflow. The buffer is discarded when the main sequence is cancelled.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in the sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>emitter</code> - Consume the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> provided per-subscriber by Reactor to generate signals.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#create-java.util.function.Consumer-"><code>create(Consumer)</code></a></dd>
</dl>
</li>
</ul>
<a name="push-java.util.function.Consumer-reactor.core.publisher.FluxSink.OverflowStrategy-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>push</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;push(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口">FluxSink</a>&lt;T&gt;&gt;&nbsp;emitter,
                               <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html" title="reactor.core.publisher中的枚举">FluxSink.OverflowStrategy</a>&nbsp;backpressure)</pre>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the capability of emitting multiple
 elements from a single-threaded producer through the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> API. For
 a multi-threaded capable alternative, see <a href="../../../reactor/core/publisher/Flux.html#create-java.util.function.Consumer-reactor.core.publisher.FluxSink.OverflowStrategy-"><code>create(Consumer, reactor.core.publisher.FluxSink.OverflowStrategy)</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/pushWithOverflowStrategy.svg" alt="">
 <p>
 This Flux factory is useful if one wants to adapt some other single-threaded
 multi-valued async API and not worry about cancellation and backpressure (which is
 handled by buffering all signals if the downstream can't keep up).
 <p>
 For example:

 <pre><code>
 Flux.&lt;String&gt;push(emitter -&gt; {

         ActionListener al = e -&gt; {
                 emitter.next(textField.getText());
         };
         // without cleanup support:

         button.addActionListener(al);

         // with cleanup support:

         button.addActionListener(al);
         emitter.onDispose(() -> {
                 button.removeListener(al);
         });
 }, FluxSink.OverflowStrategy.LATEST);
 </code></pre>

 <p><strong>Discard Support:</strong> The <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> exposed by this operator discards elements
 as relevant to the chosen <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html" title="reactor.core.publisher中的枚举"><code>FluxSink.OverflowStrategy</code></a>. For example, the <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html#DROP"><code>FluxSink.OverflowStrategy.DROP</code></a>
 discards each items as they are being dropped, while <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html#BUFFER"><code>FluxSink.OverflowStrategy.BUFFER</code></a>
 will discard the buffer upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in the sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>backpressure</code> - the backpressure mode, see <a href="../../../reactor/core/publisher/FluxSink.OverflowStrategy.html" title="reactor.core.publisher中的枚举"><code>FluxSink.OverflowStrategy</code></a> for the
 available backpressure modes</dd>
<dd><code>emitter</code> - Consume the <a href="../../../reactor/core/publisher/FluxSink.html" title="reactor.core.publisher中的接口"><code>FluxSink</code></a> provided per-subscriber by Reactor to generate signals.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#create-java.util.function.Consumer-reactor.core.publisher.FluxSink.OverflowStrategy-"><code>create(Consumer, reactor.core.publisher.FluxSink.OverflowStrategy)</code></a></dd>
</dl>
</li>
</ul>
<a name="defer-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defer</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;defer(java.util.function.Supplier&lt;? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;supplier)</pre>
<div class="block">Lazily supply a <code>Publisher</code> every time a <code>Subscription</code> is made on the
 resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, so the actual source instantiation is deferred until each
 subscribe and the <code>Supplier</code> can create a subscriber-specific instance.
 If the supplier doesn't generate a new instance however, this operator will
 effectively behave like <a href="../../../reactor/core/publisher/Flux.html#from-org.reactivestreams.Publisher-"><code>from(Publisher)</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/deferForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the type of values passing through the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>supplier</code> - the <code>Publisher</code> <code>Supplier</code> to call on subscribe</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a deferred <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#deferContextual-java.util.function.Function-"><code>deferContextual(Function)</code></a></dd>
</dl>
</li>
</ul>
<a name="deferContextual-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deferContextual</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;deferContextual(java.util.function.Function&lt;<a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口">ContextView</a>,? extends org.reactivestreams.Publisher&lt;T&gt;&gt;&nbsp;contextualPublisherFactory)</pre>
<div class="block">Lazily supply a <code>Publisher</code> every time a <code>Subscription</code> is made on the
 resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, so the actual source instantiation is deferred until each
 subscribe and the <code>Function</code> can create a subscriber-specific instance.
 This operator behaves the same way as <a href="../../../reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-"><code>defer(Supplier)</code></a>,
 but accepts a <code>Function</code> that will receive the current <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a> as an argument.
 If the function doesn't generate a new instance however, this operator will
 effectively behave like <a href="../../../reactor/core/publisher/Flux.html#from-org.reactivestreams.Publisher-"><code>from(Publisher)</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/deferForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the type of values passing through the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>contextualPublisherFactory</code> - the <code>Publisher</code> <code>Function</code> to call on subscribe</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a deferred <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> deriving actual <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> from context values for each subscription</dd>
</dl>
</li>
</ul>
<a name="empty--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>empty</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;empty()</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that completes without emitting any item.
 <p>
 <img class="marble" src="doc-files/marbles/empty.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the reified type of the target <code>Subscriber</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an empty <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="error-java.lang.Throwable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>error</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;error(java.lang.Throwable&nbsp;error)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that terminates with the specified error immediately after
 being subscribed to.
 <p>
 <img class="marble" src="doc-files/marbles/error.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the reified type of the target <code>Subscriber</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>error</code> - the error to signal to each <code>Subscriber</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new failing <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="error-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>error</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;error(java.util.function.Supplier&lt;? extends java.lang.Throwable&gt;&nbsp;errorSupplier)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that terminates with an error immediately after being
 subscribed to. The <code>Throwable</code> is generated by a <code>Supplier</code>, invoked
 each time there is a subscription and allowing for lazy instantiation.
 <p>
 <img class="marble" src="doc-files/marbles/errorWithSupplier.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the reified type of the target <code>Subscriber</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>errorSupplier</code> - the error signal <code>Supplier</code> to invoke for each <code>Subscriber</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new failing <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="error-java.lang.Throwable-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>error</h4>
<pre>public static&nbsp;&lt;O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;&nbsp;error(java.lang.Throwable&nbsp;throwable,
                                boolean&nbsp;whenRequested)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that terminates with the specified error, either immediately
 after being subscribed to or after being first requested.

 <p>
 <img class="marble" src="doc-files/marbles/errorWhenRequested.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>O</code> - the reified type of the target <code>Subscriber</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>throwable</code> - the error to signal to each <code>Subscriber</code></dd>
<dd><code>whenRequested</code> - if true, will onError on the first request instead of subscribe().</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new failing <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="first-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>first</h4>
<pre>@SafeVarargs
 @Deprecated
public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;first(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">use <a href="../../../reactor/core/publisher/Flux.html#firstWithSignal-org.reactivestreams.Publisher...-"><code>firstWithSignal(Publisher[])</code></a>. To be removed in reactor 3.5.</span></div>
<div class="block">Pick the first <code>Publisher</code> to emit any signal (onNext/onError/onComplete) and
 replay all signals from that <code>Publisher</code>, effectively behaving like the
 fastest of these competing sources.

 <p>
 <img class="marble" src="doc-files/marbles/firstWithSignalForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The competing source publishers</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> behaving like the fastest of its sources</dd>
</dl>
</li>
</ul>
<a name="first-java.lang.Iterable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>first</h4>
<pre>@Deprecated
public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;first(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources)</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">use <a href="../../../reactor/core/publisher/Flux.html#firstWithSignal-java.lang.Iterable-"><code>firstWithSignal(Iterable)</code></a>. To be removed in reactor 3.5.</span></div>
<div class="block">Pick the first <code>Publisher</code> to emit any signal (onNext/onError/onComplete) and
 replay all signals from that <code>Publisher</code>, effectively behaving like the
 fastest of these competing sources.

 <p>
 <img class="marble" src="doc-files/marbles/firstWithSignalForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The competing source publishers</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> behaving like the fastest of its sources</dd>
</dl>
</li>
</ul>
<a name="firstWithSignal-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>firstWithSignal</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;firstWithSignal(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block">Pick the first <code>Publisher</code> to emit any signal (onNext/onError/onComplete) and
 replay all signals from that <code>Publisher</code>, effectively behaving like the
 fastest of these competing sources.

 <p>
 <img class="marble" src="doc-files/marbles/firstWithSignalForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The competing source publishers</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> behaving like the fastest of its sources</dd>
</dl>
</li>
</ul>
<a name="firstWithSignal-java.lang.Iterable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>firstWithSignal</h4>
<pre>public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;firstWithSignal(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources)</pre>
<div class="block">Pick the first <code>Publisher</code> to emit any signal (onNext/onError/onComplete) and
 replay all signals from that <code>Publisher</code>, effectively behaving like the
 fastest of these competing sources.

 <p>
 <img class="marble" src="doc-files/marbles/firstWithSignalForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The competing source publishers</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> behaving like the fastest of its sources</dd>
</dl>
</li>
</ul>
<a name="firstWithValue-java.lang.Iterable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>firstWithValue</h4>
<pre>public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;firstWithValue(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources)</pre>
<div class="block">Pick the first <code>Publisher</code> to emit any value and replay all values
 from that <code>Publisher</code>, effectively behaving like the source that first
 emits an <code>onNext</code>.

 <p>
 Sources with values always "win" over empty sources (ones that only emit onComplete)
 or failing sources (ones that only emit onError).
 <p>
 When no source can provide a value, this operator fails with a <code>NoSuchElementException</code>
 (provided there are at least two sources). This exception has a <a href="../../../reactor/core/Exceptions.html#multiple-java.lang.Throwable...-"><code>composite</code></a>
 as its <code>cause</code> that can be used to inspect what went wrong with each source
 (so the composite has as many elements as there are sources).
 <p>
 Exceptions from failing sources are directly reflected in the composite at the index of the failing source.
 For empty sources, a <code>NoSuchElementException</code> is added at their respective index.
 One can use <a href="../../../reactor/core/Exceptions.html#unwrapMultiple-java.lang.Throwable-"><code>Exceptions.unwrapMultiple(topLevel.getCause())</code></a>
 to easily inspect these errors as a <code>List</code>.
 <p>
 Note that like in <a href="../../../reactor/core/publisher/Flux.html#firstWithSignal-java.lang.Iterable-"><code>firstWithSignal(Iterable)</code></a>, an infinite source can be problematic
 if no other source emits onNext.
 <p>
 <img class="marble" src="doc-files/marbles/firstWithValueForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - An <code>Iterable</code> of the competing source publishers</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> behaving like the fastest of its sources</dd>
</dl>
</li>
</ul>
<a name="firstWithValue-org.reactivestreams.Publisher-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>firstWithValue</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;firstWithValue(org.reactivestreams.Publisher&lt;? extends I&gt;&nbsp;first,
                                                       org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;others)</pre>
<div class="block">Pick the first <code>Publisher</code> to emit any value and replay all values
 from that <code>Publisher</code>, effectively behaving like the source that first
 emits an <code>onNext</code>.
 <p>
 Sources with values always "win" over an empty source (ones that only emit onComplete)
 or failing sources (ones that only emit onError).
 <p>
 When no source can provide a value, this operator fails with a <code>NoSuchElementException</code>
 (provided there are at least two sources). This exception has a <a href="../../../reactor/core/Exceptions.html#multiple-java.lang.Throwable...-"><code>composite</code></a>
 as its <code>cause</code> that can be used to inspect what went wrong with each source
 (so the composite has as many elements as there are sources).
 <p>
 Exceptions from failing sources are directly reflected in the composite at the index of the failing source.
 For empty sources, a <code>NoSuchElementException</code> is added at their respective index.
 One can use <a href="../../../reactor/core/Exceptions.html#unwrapMultiple-java.lang.Throwable-"><code>Exceptions.unwrapMultiple(topLevel.getCause())</code></a>
 to easily inspect these errors as a <code>List</code>.
 <p>
 Note that like in <a href="../../../reactor/core/publisher/Flux.html#firstWithSignal-org.reactivestreams.Publisher...-"><code>firstWithSignal(Publisher[])</code></a>, an infinite source can be problematic
 if no other source emits onNext.
 In case the <code>first</code> source is already an array-based <a href="../../../reactor/core/publisher/Flux.html#firstWithValue-org.reactivestreams.Publisher-org.reactivestreams.Publisher...-"><code>firstWithValue(Publisher, Publisher[])</code></a>
 instance, nesting is avoided: a single new array-based instance is created with all the
 sources from <code>first</code> plus all the <code>others</code> sources at the same level.
 <p>
 <img class="marble" src="doc-files/marbles/firstWithValueForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>first</code> - The first competing source publisher</dd>
<dd><code>others</code> - The other competing source publishers</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> behaving like the fastest of its sources</dd>
</dl>
</li>
</ul>
<a name="from-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>from</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;from(org.reactivestreams.Publisher&lt;? extends T&gt;&nbsp;source)</pre>
<div class="block">Decorate the specified <code>Publisher</code> with the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> API.
 <p>
 <img class="marble" src="doc-files/marbles/fromForFlux.svg" alt="">
 <p>
 <a href="../../../reactor/core/publisher/Hooks.html#onEachOperator-java.lang.String-java.util.function.Function-"><code>Hooks.onEachOperator(String, Function)</code></a> and similar assembly hooks are applied
 unless the source is already a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in both source and output sequences</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source</code> - the source to decorate</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="fromArray-java.lang.Object:A-">
<!--   -->
</a><a name="fromArray-T:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromArray</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;fromArray(T[]&nbsp;array)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits the items contained in the provided array.
 <p>
 <img class="marble" src="doc-files/marbles/fromArray.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in the source array and resulting Flux</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>array</code> - the array to read data from</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="fromIterable-java.lang.Iterable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromIterable</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;fromIterable(java.lang.Iterable&lt;? extends T&gt;&nbsp;it)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits the items contained in the provided <code>Iterable</code>.
 The <code>Iterable.iterator()</code> method will be invoked at least once and at most twice
 for each subscriber.
 <p>
 <img class="marble" src="doc-files/marbles/fromIterable.svg" alt="">
 <p>
 This operator inspects the <code>Iterable</code>'s <code>Spliterator</code> to assess if the iteration
 can be guaranteed to be finite (see <a href="../../../reactor/core/publisher/Operators.html#onDiscardMultiple-java.util.Iterator-boolean-reactor.util.context.Context-"><code>Operators.onDiscardMultiple(Iterator, boolean, Context)</code></a>).
 Since the default Spliterator wraps the Iterator we can have two <code>Iterable.iterator()</code>
 calls. This second invocation is skipped on a <code>Collection</code> however, a type which is
 assumed to be always finite.

 <p><strong>Discard Support:</strong> Upon cancellation, this operator attempts to discard the remainder of the
 <code>Iterable</code> if it can safely ensure the iterator is finite.
 Note that this means the <code>Iterable.iterator()</code> method could be invoked twice.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in the source <code>Iterable</code> and resulting Flux</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>it</code> - the <code>Iterable</code> to read data from</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="fromStream-java.util.stream.Stream-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromStream</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;fromStream(java.util.stream.Stream&lt;? extends T&gt;&nbsp;s)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits the items contained in the provided <code>Stream</code>.
 Keep in mind that a <code>Stream</code> cannot be re-used, which can be problematic in
 case of multiple subscriptions or re-subscription (like with <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> or
 <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a>). The <code>Stream</code> is <code>closed</code> automatically
 by the operator on cancellation, error or completion.
 <p>
 <img class="marble" src="doc-files/marbles/fromStream.svg" alt="">

 <p><strong>Discard Support:</strong> Upon cancellation, this operator attempts to discard remainder of the
 <code>Stream</code> through its open <code>Spliterator</code>, if it can safely ensure it is finite
 (see <a href="../../../reactor/core/publisher/Operators.html#onDiscardMultiple-java.util.Iterator-boolean-reactor.util.context.Context-"><code>Operators.onDiscardMultiple(Iterator, boolean, Context)</code></a>).</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in the source <code>Stream</code> and resulting Flux</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>s</code> - the <code>Stream</code> to read data from</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="fromStream-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromStream</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;fromStream(java.util.function.Supplier&lt;java.util.stream.Stream&lt;? extends T&gt;&gt;&nbsp;streamSupplier)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits the items contained in a <code>Stream</code> created by
 the provided <code>Supplier</code> for each subscription. The <code>Stream</code> is
 <code>closed</code> automatically by the operator on cancellation, error
 or completion.
 <p>
 <img class="marble" src="doc-files/marbles/fromStream.svg" alt="">

 <p><strong>Discard Support:</strong> Upon cancellation, this operator attempts to discard remainder of the
 <code>Stream</code> through its open <code>Spliterator</code>, if it can safely ensure it is finite
 (see <a href="../../../reactor/core/publisher/Operators.html#onDiscardMultiple-java.util.Iterator-boolean-reactor.util.context.Context-"><code>Operators.onDiscardMultiple(Iterator, boolean, Context)</code></a>).</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - The type of values in the source <code>Stream</code> and resulting Flux</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>streamSupplier</code> - the <code>Supplier</code> that generates the <code>Stream</code> from
 which to read data</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="generate-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generate</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;generate(java.util.function.Consumer&lt;<a href="../../../reactor/core/publisher/SynchronousSink.html" title="reactor.core.publisher中的接口">SynchronousSink</a>&lt;T&gt;&gt;&nbsp;generator)</pre>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by generating signals one-by-one via a
 consumer callback.
 <p>
 <img class="marble" src="doc-files/marbles/generateStateless.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the value type emitted</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>generator</code> - Consume the <a href="../../../reactor/core/publisher/SynchronousSink.html" title="reactor.core.publisher中的接口"><code>SynchronousSink</code></a> provided per-subscriber by Reactor
 to generate a <strong>single</strong> signal on each pass.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="generate-java.util.concurrent.Callable-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generate</h4>
<pre>public static&nbsp;&lt;T,S&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;generate(java.util.concurrent.Callable&lt;S&gt;&nbsp;stateSupplier,
                                     java.util.function.BiFunction&lt;S,<a href="../../../reactor/core/publisher/SynchronousSink.html" title="reactor.core.publisher中的接口">SynchronousSink</a>&lt;T&gt;,S&gt;&nbsp;generator)</pre>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by generating signals one-by-one via a
 consumer callback and some state. The <code>stateSupplier</code> may return null.
 <p>
 <img class="marble" src="doc-files/marbles/generate.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the value type emitted</dd>
<dd><code>S</code> - the per-subscriber custom state type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>stateSupplier</code> - called for each incoming Subscriber to provide the initial state for the generator bifunction</dd>
<dd><code>generator</code> - Consume the <a href="../../../reactor/core/publisher/SynchronousSink.html" title="reactor.core.publisher中的接口"><code>SynchronousSink</code></a> provided per-subscriber by Reactor
 as well as the current state to generate a <strong>single</strong> signal on each pass
 and return a (new) state.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="generate-java.util.concurrent.Callable-java.util.function.BiFunction-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generate</h4>
<pre>public static&nbsp;&lt;T,S&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;generate(java.util.concurrent.Callable&lt;S&gt;&nbsp;stateSupplier,
                                     java.util.function.BiFunction&lt;S,<a href="../../../reactor/core/publisher/SynchronousSink.html" title="reactor.core.publisher中的接口">SynchronousSink</a>&lt;T&gt;,S&gt;&nbsp;generator,
                                     java.util.function.Consumer&lt;? super S&gt;&nbsp;stateConsumer)</pre>
<div class="block">Programmatically create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by generating signals one-by-one via a
 consumer callback and some state, with a final cleanup callback. The
 <code>stateSupplier</code> may return null but your cleanup <code>stateConsumer</code>
 will need to handle the null case.
 <p>
 <img class="marble" src="doc-files/marbles/generateWithCleanup.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the value type emitted</dd>
<dd><code>S</code> - the per-subscriber custom state type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>stateSupplier</code> - called for each incoming Subscriber to provide the initial state for the generator bifunction</dd>
<dd><code>generator</code> - Consume the <a href="../../../reactor/core/publisher/SynchronousSink.html" title="reactor.core.publisher中的接口"><code>SynchronousSink</code></a> provided per-subscriber by Reactor
 as well as the current state to generate a <strong>single</strong> signal on each pass
 and return a (new) state.</dd>
<dd><code>stateConsumer</code> - called after the generator has terminated or the downstream cancelled, receiving the last
 state to be handled (i.e., release resources or do other cleanup).</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="interval-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interval</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Long&gt;&nbsp;interval(java.time.Duration&nbsp;period)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits long values starting with 0 and incrementing at
 specified time intervals on the global timer. The first element is emitted after
 an initial delay equal to the <code>period</code>. If demand is not produced in time,
 an onError will be signalled with an <a href="../../../reactor/core/Exceptions.html#isOverflow-java.lang.Throwable-"><code>overflow</code></a>
 <code>IllegalStateException</code> detailing the tick that couldn't be emitted.
 In normal conditions, the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> will never complete.
 <p>
 Runs on the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>Schedulers.parallel()</code></a> Scheduler.
 <p>
 <img class="marble" src="doc-files/marbles/interval.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>period</code> - the period <code>Duration</code> between each increment</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitting increasing numbers at regular intervals</dd>
</dl>
</li>
</ul>
<a name="interval-java.time.Duration-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interval</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Long&gt;&nbsp;interval(java.time.Duration&nbsp;delay,
                                            java.time.Duration&nbsp;period)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits long values starting with 0 and incrementing at
 specified time intervals, after an initial delay, on the global timer. If demand is
 not produced in time, an onError will be signalled with an
 <a href="../../../reactor/core/Exceptions.html#isOverflow-java.lang.Throwable-"><code>overflow</code></a> <code>IllegalStateException</code>
 detailing the tick that couldn't be emitted. In normal conditions, the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 will never complete.
 <p>
 Runs on the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>Schedulers.parallel()</code></a> Scheduler.
 <p>
 <img class="marble" src="doc-files/marbles/intervalWithDelay.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>delay</code> - the <code>Duration</code> to wait before emitting 0l</dd>
<dd><code>period</code> - the period <code>Duration</code> before each following increment</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitting increasing numbers at regular intervals</dd>
</dl>
</li>
</ul>
<a name="interval-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interval</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Long&gt;&nbsp;interval(java.time.Duration&nbsp;period,
                                            <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits long values starting with 0 and incrementing at
 specified time intervals, on the specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>. The first element is
 emitted after an initial delay equal to the <code>period</code>. If demand is not
 produced in time, an onError will be signalled with an <a href="../../../reactor/core/Exceptions.html#isOverflow-java.lang.Throwable-"><code>overflow</code></a>
 <code>IllegalStateException</code> detailing the tick that couldn't be emitted.
 In normal conditions, the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> will never complete.
 <p>
 <img class="marble" src="doc-files/marbles/interval.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>period</code> - the period <code>Duration</code> between each increment</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitting increasing numbers at regular intervals</dd>
</dl>
</li>
</ul>
<a name="interval-java.time.Duration-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interval</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Long&gt;&nbsp;interval(java.time.Duration&nbsp;delay,
                                            java.time.Duration&nbsp;period,
                                            <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits long values starting with 0 and incrementing at
 specified time intervals, after an initial delay, on the specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.
 If demand is not produced in time, an onError will be signalled with an
 <a href="../../../reactor/core/Exceptions.html#isOverflow-java.lang.Throwable-"><code>overflow</code></a> <code>IllegalStateException</code>
 detailing the tick that couldn't be emitted. In normal conditions, the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 will never complete.
 <p>
 <img class="marble" src="doc-files/marbles/intervalWithDelay.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>delay</code> - the <code>Duration</code> to wait before emitting 0l</dd>
<dd><code>period</code> - the period <code>Duration</code> before each following increment</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitting increasing numbers at regular intervals</dd>
</dl>
</li>
</ul>
<a name="just-java.lang.Object:A-">
<!--   -->
</a><a name="just-T...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>just</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;just(T...&nbsp;data)</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits the provided elements and then completes.
 <p>
 <img class="marble" src="doc-files/marbles/justMultiple.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the emitted data type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>data</code> - the elements to emit, as a vararg</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="just-java.lang.Object-">
<!--   -->
</a><a name="just-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>just</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;just(T&nbsp;data)</pre>
<div class="block">Create a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will only emit a single element then onComplete.
 <p>
 <img class="marble" src="doc-files/marbles/just.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the emitted data type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>data</code> - the single element to emit</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="merge-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;merge(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;source)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an interleaved merged sequence. Unlike <a href="../../../reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher-"><code>concat</code></a>, inner
 sources are subscribed to eagerly.
 <p>
 <img class="marble" src="doc-files/marbles/mergeAsyncSources.svg" alt="">

 <p>
 Note that merge is tailored to work with asynchronous sources or finite sources. When dealing with
 an infinite source that doesn't already publish on a dedicated Scheduler, you must isolate that source
 in its own Scheduler, as merge would otherwise attempt to drain it before subscribing to
 another source.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source</code> - a <code>Publisher</code> of <code>Publisher</code> sources to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="merge-org.reactivestreams.Publisher-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;merge(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;source,
                                int&nbsp;concurrency)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an interleaved merged sequence. Unlike <a href="../../../reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher-"><code>concat</code></a>, inner
 sources are subscribed to eagerly (but at most <code>concurrency</code> sources are
 subscribed to at the same time).
 <p>
 <img class="marble" src="doc-files/marbles/mergeAsyncSources.svg" alt="">
 <p>
 Note that merge is tailored to work with asynchronous sources or finite sources. When dealing with
 an infinite source that doesn't already publish on a dedicated Scheduler, you must isolate that source
 in its own Scheduler, as merge would otherwise attempt to drain it before subscribing to
 another source.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source</code> - a <code>Publisher</code> of <code>Publisher</code> sources to merge</dd>
<dd><code>concurrency</code> - the request produced to the main source thus limiting concurrent merge backlog</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="merge-org.reactivestreams.Publisher-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;merge(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;source,
                                int&nbsp;concurrency,
                                int&nbsp;prefetch)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an interleaved merged sequence. Unlike <a href="../../../reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher-"><code>concat</code></a>, inner
 sources are subscribed to eagerly (but at most <code>concurrency</code> sources are
 subscribed to at the same time).
 <p>
 <img class="marble" src="doc-files/marbles/mergeAsyncSources.svg" alt="">
 <p>
 Note that merge is tailored to work with asynchronous sources or finite sources. When dealing with
 an infinite source that doesn't already publish on a dedicated Scheduler, you must isolate that source
 in its own Scheduler, as merge would otherwise attempt to drain it before subscribing to
 another source.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source</code> - a <code>Publisher</code> of <code>Publisher</code> sources to merge</dd>
<dd><code>concurrency</code> - the request produced to the main source thus limiting concurrent merge backlog</dd>
<dd><code>prefetch</code> - the inner source request size</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="merge-java.lang.Iterable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre>public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;merge(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences contained in an <code>Iterable</code>
 into an interleaved merged sequence. Unlike <a href="../../../reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher-"><code>concat</code></a>, inner
 sources are subscribed to eagerly.
 A new <code>Iterator</code> will be created for each subscriber.
 <p>
 <img class="marble" src="doc-files/marbles/mergeFixedSources.svg" alt="">
 <p>
 Note that merge is tailored to work with asynchronous sources or finite sources. When dealing with
 an infinite source that doesn't already publish on a dedicated Scheduler, you must isolate that source
 in its own Scheduler, as merge would otherwise attempt to drain it before subscribing to
 another source.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - The source type of the data sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - the <code>Iterable</code> of sources to merge (will be lazily iterated on subscribe)</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="merge-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;merge(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences contained in an array / vararg
 into an interleaved merged sequence. Unlike <a href="../../../reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher-"><code>concat</code></a>,
 sources are subscribed to eagerly.
 <p>
 <img class="marble" src="doc-files/marbles/mergeFixedSources.svg" alt="">
 <p>
 Note that merge is tailored to work with asynchronous sources or finite sources. When dealing with
 an infinite source that doesn't already publish on a dedicated Scheduler, you must isolate that source
 in its own Scheduler, as merge would otherwise attempt to drain it before subscribing to
 another source.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - The source type of the data sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - the array of <code>Publisher</code> sources to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="merge-int-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>merge</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;merge(int&nbsp;prefetch,
                                              org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences contained in an array / vararg
 into an interleaved merged sequence. Unlike <a href="../../../reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher-"><code>concat</code></a>,
 sources are subscribed to eagerly.
 <p>
 <img class="marble" src="doc-files/marbles/mergeFixedSources.svg" alt="">
 <p>
 Note that merge is tailored to work with asynchronous sources or finite sources. When dealing with
 an infinite source that doesn't already publish on a dedicated Scheduler, you must isolate that source
 in its own Scheduler, as merge would otherwise attempt to drain it before subscribing to
 another source.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - The source type of the data sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - the array of <code>Publisher</code> sources to merge</dd>
<dd><code>prefetch</code> - the inner source request size</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a fresh Reactive <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> publisher ready to be subscribed</dd>
</dl>
</li>
</ul>
<a name="mergeDelayError-int-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeDelayError</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;mergeDelayError(int&nbsp;prefetch,
                                                        org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences contained in an array / vararg
 into an interleaved merged sequence. Unlike <a href="../../../reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher-"><code>concat</code></a>,
 sources are subscribed to eagerly.
 This variant will delay any error until after the rest of the merge backlog has been processed.
 <p>
 <img class="marble" src="doc-files/marbles/mergeFixedSources.svg" alt="">
 <p>
 Note that merge is tailored to work with asynchronous sources or finite sources. When dealing with
 an infinite source that doesn't already publish on a dedicated Scheduler, you must isolate that source
 in its own Scheduler, as merge would otherwise attempt to drain it before subscribing to
 another source.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - The source type of the data sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - the array of <code>Publisher</code> sources to merge</dd>
<dd><code>prefetch</code> - the inner source request size</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a fresh Reactive <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> publisher ready to be subscribed</dd>
</dl>
</li>
</ul>
<a name="mergePriority-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergePriority</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I extends java.lang.Comparable&lt;? super I&gt;&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;mergePriority(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by their natural order) <strong>as they arrive</strong>.
 This is not a <a href="../../../reactor/core/publisher/Flux.html#sort--"><code>sort()</code></a>, as it doesn't consider the whole of each sequences. Unlike mergeComparing,
 this operator does <em>not</em> wait for a value from each source to arrive either.
 <p>
 While this operator does retrieve at most one value from each source, it only compares values when two or more
 sources emit at the same time. In that case it picks the smallest of these competing values and continues doing so
 as long as there is demand. It is therefore best suited for asynchronous sources where you do not want to wait
 for a value from each source before emitting a value downstream.
 <p>
 <img class="marble" src="doc-files/marbles/mergePriorityNaturalOrder.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - a <code>Comparable</code> merged type that has a <code>natural order</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - <code>Publisher</code> sources of <code>Comparable</code> to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares the latest available value from each source, publishing the
 smallest value and replenishing the source that produced it.</dd>
</dl>
</li>
</ul>
<a name="mergePriority-java.util.Comparator-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergePriority</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;mergePriority(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                      org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>) <strong>as they arrive</strong>. This is not a <a href="../../../reactor/core/publisher/Flux.html#sort-java.util.Comparator-"><code>sort(Comparator)</code></a>, as it doesn't consider
 the whole of each sequences. Unlike mergeComparing, this operator does <em>not</em> wait for a value from each
 source to arrive either.
 <p>
 While this operator does retrieve at most one value from each source, it only compares values when two or more
 sources emit at the same time. In that case it picks the smallest of these competing values and continues doing so
 as long as there is demand. It is therefore best suited for asynchronous sources where you do not want to wait
 for a value from each source before emitting a value downstream.
 <p>
 <img class="marble" src="doc-files/marbles/mergePriority.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>comparator</code> - the <code>Comparator</code> to use to find the smallest value</dd>
<dd><code>sources</code> - <code>Publisher</code> sources to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares the latest available value from each source, publishing the
 smallest value and replenishing the source that produced it.</dd>
</dl>
</li>
</ul>
<a name="mergePriority-int-java.util.Comparator-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergePriority</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;mergePriority(int&nbsp;prefetch,
                                                      java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                      org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>) <strong>as they arrive</strong>. This is not a <a href="../../../reactor/core/publisher/Flux.html#sort-java.util.Comparator-"><code>sort(Comparator)</code></a>, as it doesn't consider
 the whole of each sequences. Unlike mergeComparing, this operator does <em>not</em> wait for a value from each
 source to arrive either.
 <p>
 While this operator does retrieve at most one value from each source, it only compares values when two or more
 sources emit at the same time. In that case it picks the smallest of these competing values and continues doing so
 as long as there is demand. It is therefore best suited for asynchronous sources where you do not want to wait
 for a value from each source before emitting a value downstream.
 <p>
 <img class="marble" src="doc-files/marbles/mergePriority.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>prefetch</code> - the number of elements to prefetch from each source (avoiding too
 many small requests to the source when picking)</dd>
<dd><code>comparator</code> - the <code>Comparator</code> to use to find the smallest value</dd>
<dd><code>sources</code> - <code>Publisher</code> sources to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares the latest available value from each source, publishing the
 smallest value and replenishing the source that produced it.</dd>
</dl>
</li>
</ul>
<a name="mergePriorityDelayError-int-java.util.Comparator-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergePriorityDelayError</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;mergePriorityDelayError(int&nbsp;prefetch,
                                                                java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                                org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>) <strong>as they arrive</strong>. This is not a <a href="../../../reactor/core/publisher/Flux.html#sort-java.util.Comparator-"><code>sort(Comparator)</code></a>, as it doesn't consider
 the whole of each sequences. Unlike mergeComparing, this operator does <em>not</em> wait for a value from each
 source to arrive either.
 <p>
 While this operator does retrieve at most one value from each source, it only compares values when two or more
 sources emit at the same time. In that case it picks the smallest of these competing values and continues doing so
 as long as there is demand. It is therefore best suited for asynchronous sources where you do not want to wait
 for a value from each source before emitting a value downstream.
 <p>
 Note that it is delaying errors until all data is consumed.
 <p>
 <img class="marble" src="doc-files/marbles/mergePriority.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>prefetch</code> - the number of elements to prefetch from each source (avoiding too
 many small requests to the source when picking)</dd>
<dd><code>comparator</code> - the <code>Comparator</code> to use to find the smallest value</dd>
<dd><code>sources</code> - <code>Publisher</code> sources to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares the latest available value from each source, publishing the
 smallest value and replenishing the source that produced it.</dd>
</dl>
</li>
</ul>
<a name="mergeComparing-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeComparing</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I extends java.lang.Comparable&lt;? super I&gt;&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;mergeComparing(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by their natural order).
 This is not a <a href="../../../reactor/core/publisher/Flux.html#sort--"><code>sort()</code></a>, as it doesn't consider the whole of each sequences.
 <p>
 Instead, this operator considers only one value from each source and picks the
 smallest of all these values, then replenishes the slot for that picked source.
 <p>
 <img class="marble" src="doc-files/marbles/mergeComparingNaturalOrder.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - a <code>Comparable</code> merged type that has a <code>natural order</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - <code>Publisher</code> sources of <code>Comparable</code> to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that , subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="mergeComparing-java.util.Comparator-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeComparing</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;mergeComparing(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                       org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>). This is not a <a href="../../../reactor/core/publisher/Flux.html#sort-java.util.Comparator-"><code>sort(Comparator)</code></a>, as it doesn't consider
 the whole of each sequences.
 <p>
 Instead, this operator considers only one value from each source and picks the
 smallest of all these values, then replenishes the slot for that picked source.
 <p>
 <img class="marble" src="doc-files/marbles/mergeComparing.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>comparator</code> - the <code>Comparator</code> to use to find the smallest value</dd>
<dd><code>sources</code> - <code>Publisher</code> sources to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares latest values from each source, using the
 smallest value and replenishing the source that produced it</dd>
</dl>
</li>
</ul>
<a name="mergeComparing-int-java.util.Comparator-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeComparing</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;mergeComparing(int&nbsp;prefetch,
                                                       java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                       org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>). This is not a <a href="../../../reactor/core/publisher/Flux.html#sort-java.util.Comparator-"><code>sort(Comparator)</code></a>, as it doesn't consider
 the whole of each sequences.
 <p>
 Instead, this operator considers only one value from each source and picks the
 smallest of all these values, then replenishes the slot for that picked source.
 <p>
 <img class="marble" src="doc-files/marbles/mergeComparing.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>prefetch</code> - the number of elements to prefetch from each source (avoiding too
 many small requests to the source when picking)</dd>
<dd><code>comparator</code> - the <code>Comparator</code> to use to find the smallest value</dd>
<dd><code>sources</code> - <code>Publisher</code> sources to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares latest values from each source, using the
 smallest value and replenishing the source that produced it</dd>
</dl>
</li>
</ul>
<a name="mergeComparingDelayError-int-java.util.Comparator-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeComparingDelayError</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;mergeComparingDelayError(int&nbsp;prefetch,
                                                                 java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                                 org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>). This is not a <a href="../../../reactor/core/publisher/Flux.html#sort-java.util.Comparator-"><code>sort(Comparator)</code></a>, as it doesn't consider
 the whole of each sequences.
 <p>
 Instead, this operator considers only one value from each source and picks the
 smallest of all these values, then replenishes the slot for that picked source.
 <p>
 Note that it is delaying errors until all data is consumed.
 <p>
 <img class="marble" src="doc-files/marbles/mergeComparing.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>prefetch</code> - the number of elements to prefetch from each source (avoiding too
 many small requests to the source when picking)</dd>
<dd><code>comparator</code> - the <code>Comparator</code> to use to find the smallest value</dd>
<dd><code>sources</code> - <code>Publisher</code> sources to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares latest values from each source, using the
 smallest value and replenishing the source that produced it</dd>
</dl>
</li>
</ul>
<a name="mergeOrdered-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeOrdered</h4>
<pre>@SafeVarargs
 @Deprecated
public static&nbsp;&lt;I extends java.lang.Comparable&lt;? super I&gt;&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;mergeOrdered(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">Use <a href="../../../reactor/core/publisher/Flux.html#mergeComparingDelayError-int-java.util.Comparator-org.reactivestreams.Publisher...-"><code>mergeComparingDelayError(int, Comparator, Publisher[])</code></a> instead
 (as <a href="../../../reactor/core/publisher/Flux.html#mergeComparing-org.reactivestreams.Publisher...-"><code>mergeComparing(Publisher[])</code></a> don't have this operator's delayError behavior).
 To be removed in 3.6.0 at the earliest.</span></div>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by their natural order).
 This is not a <a href="../../../reactor/core/publisher/Flux.html#sort--"><code>sort()</code></a>, as it doesn't consider the whole of each sequences.
 <p>
 Instead, this operator considers only one value from each source and picks the
 smallest of all these values, then replenishes the slot for that picked source.
 <p>
 Note that it is delaying errors until all data is consumed.
 <p>
 <img class="marble" src="doc-files/marbles/mergeComparingNaturalOrder.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - a <code>Comparable</code> merged type that has a <code>natural order</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - <code>Publisher</code> sources of <code>Comparable</code> to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares latest values from each source, using the
 smallest value and replenishing the source that produced it</dd>
</dl>
</li>
</ul>
<a name="mergeOrdered-java.util.Comparator-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeOrdered</h4>
<pre>@SafeVarargs
 @Deprecated
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;mergeOrdered(java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                                   org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">Use <a href="../../../reactor/core/publisher/Flux.html#mergeComparingDelayError-int-java.util.Comparator-org.reactivestreams.Publisher...-"><code>mergeComparingDelayError(int, Comparator, Publisher[])</code></a> instead
 (as <a href="../../../reactor/core/publisher/Flux.html#mergeComparing-org.reactivestreams.Publisher...-"><code>mergeComparing(Publisher[])</code></a> don't have this operator's delayError behavior).
 To be removed in 3.6.0 at the earliest.</span></div>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>). This is not a <a href="../../../reactor/core/publisher/Flux.html#sort-java.util.Comparator-"><code>sort(Comparator)</code></a>, as it doesn't consider
 the whole of each sequences.
 <p>
 Instead, this operator considers only one value from each source and picks the
 smallest of all these values, then replenishes the slot for that picked source.
 <p>
 Note that it is delaying errors until all data is consumed.
 <p>
 <img class="marble" src="doc-files/marbles/mergeComparing.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>comparator</code> - the <code>Comparator</code> to use to find the smallest value</dd>
<dd><code>sources</code> - <code>Publisher</code> sources to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares latest values from each source, using the
 smallest value and replenishing the source that produced it</dd>
</dl>
</li>
</ul>
<a name="mergeOrdered-int-java.util.Comparator-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeOrdered</h4>
<pre>@SafeVarargs
 @Deprecated
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;mergeOrdered(int&nbsp;prefetch,
                                                                   java.util.Comparator&lt;? super T&gt;&nbsp;comparator,
                                                                   org.reactivestreams.Publisher&lt;? extends T&gt;...&nbsp;sources)</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">Use <a href="../../../reactor/core/publisher/Flux.html#mergeComparingDelayError-int-java.util.Comparator-org.reactivestreams.Publisher...-"><code>mergeComparingDelayError(int, Comparator, Publisher[])</code></a> instead
 (as <a href="../../../reactor/core/publisher/Flux.html#mergeComparing-org.reactivestreams.Publisher...-"><code>mergeComparing(Publisher[])</code></a> don't have this operator's delayError behavior).
 To be removed in 3.6.0 at the earliest.</span></div>
<div class="block">Merge data from provided <code>Publisher</code> sequences into an ordered merged sequence,
 by picking the smallest values from each source (as defined by the provided
 <code>Comparator</code>). This is not a <a href="../../../reactor/core/publisher/Flux.html#sort-java.util.Comparator-"><code>sort(Comparator)</code></a>, as it doesn't consider
 the whole of each sequences.
 <p>
 Instead, this operator considers only one value from each source and picks the
 smallest of all these values, then replenishes the slot for that picked source.
 <p>
 Note that it is delaying errors until all data is consumed.
 <p>
 <img class="marble" src="doc-files/marbles/mergeComparing.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>prefetch</code> - the number of elements to prefetch from each source (avoiding too
 many small requests to the source when picking)</dd>
<dd><code>comparator</code> - the <code>Comparator</code> to use to find the smallest value</dd>
<dd><code>sources</code> - <code>Publisher</code> sources to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares latest values from each source, using the
 smallest value and replenishing the source that produced it</dd>
</dl>
</li>
</ul>
<a name="mergeSequential-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSequential</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;mergeSequential(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an ordered merged sequence. Unlike concat, the inner publishers are subscribed to
 eagerly. Unlike merge, their emitted values are merged into the final sequence in
 subscription order.
 <p>
 <img class="marble" src="doc-files/marbles/mergeSequentialAsyncSources.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - a <code>Publisher</code> of <code>Publisher</code> sources to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="mergeSequential-org.reactivestreams.Publisher-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSequential</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;mergeSequential(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                                          int&nbsp;maxConcurrency,
                                          int&nbsp;prefetch)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an ordered merged sequence. Unlike concat, the inner publishers are subscribed to
 eagerly (but at most <code>maxConcurrency</code> sources at a time). Unlike merge, their
 emitted values are merged into the final sequence in subscription order.
 <p>
 <img class="marble" src="doc-files/marbles/mergeSequentialAsyncSources.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - a <code>Publisher</code> of <code>Publisher</code> sources to merge</dd>
<dd><code>prefetch</code> - the inner source request size</dd>
<dd><code>maxConcurrency</code> - the request produced to the main source thus limiting concurrent merge backlog</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="mergeSequentialDelayError-org.reactivestreams.Publisher-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSequentialDelayError</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;mergeSequentialDelayError(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sources,
                                                    int&nbsp;maxConcurrency,
                                                    int&nbsp;prefetch)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences emitted by the passed <code>Publisher</code>
 into an ordered merged sequence. Unlike concat, the inner publishers are subscribed to
 eagerly (but at most <code>maxConcurrency</code> sources at a time). Unlike merge, their
 emitted values are merged into the final sequence in subscription order.
 This variant will delay any error until after the rest of the mergeSequential backlog has been processed.
 <p>
 <img class="marble" src="doc-files/marbles/mergeSequentialAsyncSources.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - a <code>Publisher</code> of <code>Publisher</code> sources to merge</dd>
<dd><code>prefetch</code> - the inner source request size</dd>
<dd><code>maxConcurrency</code> - the request produced to the main source thus limiting concurrent merge backlog</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="mergeSequential-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSequential</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;mergeSequential(org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an array/vararg
 into an ordered merged sequence. Unlike concat, sources are subscribed to
 eagerly. Unlike merge, their emitted values are merged into the final sequence in subscription order.
 <p>
 <img class="marble" src="doc-files/marbles/mergeSequentialVarSources.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - a number of <code>Publisher</code> sequences to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="mergeSequential-int-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSequential</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;mergeSequential(int&nbsp;prefetch,
                                                        org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an array/vararg
 into an ordered merged sequence. Unlike concat, sources are subscribed to
 eagerly. Unlike merge, their emitted values are merged into the final sequence in subscription order.
 <p>
 <img class="marble" src="doc-files/marbles/mergeSequentialVarSources.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>prefetch</code> - the inner source request size</dd>
<dd><code>sources</code> - a number of <code>Publisher</code> sequences to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="mergeSequentialDelayError-int-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSequentialDelayError</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;mergeSequentialDelayError(int&nbsp;prefetch,
                                                                  org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an array/vararg
 into an ordered merged sequence. Unlike concat, sources are subscribed to
 eagerly. Unlike merge, their emitted values are merged into the final sequence in subscription order.
 This variant will delay any error until after the rest of the mergeSequential backlog
 has been processed.
 <p>
 <img class="marble" src="doc-files/marbles/mergeSequentialVarSources.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>prefetch</code> - the inner source request size</dd>
<dd><code>sources</code> - a number of <code>Publisher</code> sequences to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="mergeSequential-java.lang.Iterable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSequential</h4>
<pre>public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;mergeSequential(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an <code>Iterable</code>
 into an ordered merged sequence. Unlike concat, sources are subscribed to
 eagerly. Unlike merge, their emitted values are merged into the final sequence in subscription order.
 <p>
 <img class="marble" src="doc-files/marbles/mergeSequentialVarSources.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - an <code>Iterable</code> of <code>Publisher</code> sequences to merge</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="mergeSequential-java.lang.Iterable-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSequential</h4>
<pre>public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;mergeSequential(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources,
                                          int&nbsp;maxConcurrency,
                                          int&nbsp;prefetch)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an <code>Iterable</code>
 into an ordered merged sequence. Unlike concat, sources are subscribed to
 eagerly (but at most <code>maxConcurrency</code> sources at a time). Unlike merge, their
 emitted values are merged into the final sequence in subscription order.
 <p>
 <img class="marble" src="doc-files/marbles/mergeSequentialVarSources.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - an <code>Iterable</code> of <code>Publisher</code> sequences to merge</dd>
<dd><code>maxConcurrency</code> - the request produced to the main source thus limiting concurrent merge backlog</dd>
<dd><code>prefetch</code> - the inner source request size</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="mergeSequentialDelayError-java.lang.Iterable-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeSequentialDelayError</h4>
<pre>public static&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;mergeSequentialDelayError(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;? extends I&gt;&gt;&nbsp;sources,
                                                    int&nbsp;maxConcurrency,
                                                    int&nbsp;prefetch)</pre>
<div class="block">Merge data from <code>Publisher</code> sequences provided in an <code>Iterable</code>
 into an ordered merged sequence. Unlike concat, sources are subscribed to
 eagerly (but at most <code>maxConcurrency</code> sources at a time). Unlike merge, their
 emitted values are merged into the final sequence in subscription order.
 This variant will delay any error until after the rest of the mergeSequential backlog
 has been processed.
 <p>
 <img class="marble" src="doc-files/marbles/mergeSequentialVarSources.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - the merged type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - an <code>Iterable</code> of <code>Publisher</code> sequences to merge</dd>
<dd><code>maxConcurrency</code> - the request produced to the main source thus limiting concurrent merge backlog</dd>
<dd><code>prefetch</code> - the inner source request size</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="never--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>never</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;never()</pre>
<div class="block">Create a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will never signal any data, error or completion signal.
 <p>
 <img class="marble" src="doc-files/marbles/never.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the <code>Subscriber</code> type target</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a never completing <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="range-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>range</h4>
<pre>public static&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Integer&gt;&nbsp;range(int&nbsp;start,
                                            int&nbsp;count)</pre>
<div class="block">Build a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will only emit a sequence of <code>count</code> incrementing integers,
 starting from <code>start</code>. That is, emit integers between <code>start</code> (included)
 and <code>start + count</code> (excluded) then complete.

 <p>
 <img class="marble" src="doc-files/marbles/range.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>start</code> - the first integer to be emit</dd>
<dd><code>count</code> - the total number of incrementing values to emit, including the first value</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a ranged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="switchOnNext-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>switchOnNext</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;switchOnNext(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;mergedPublishers)</pre>
<div class="block">Creates a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that mirrors the most recently emitted <code>Publisher</code>,
 forwarding its data until a new <code>Publisher</code> comes in the source.
 <p>
 The resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> will complete once there are no new <code>Publisher</code> in
 the source (source has completed) and the last mirrored <code>Publisher</code> has also
 completed.
 <p>
 <img class="marble" src="doc-files/marbles/switchOnNext.svg" alt="">
 <p>
 This operator requests the <code>mergedPublishers</code> source for an unbounded amount of inner publishers,
 but doesn't request each inner <code>Publisher</code> unless the downstream has made
 a corresponding request (no prefetch on publishers emitted by <code>mergedPublishers</code>).</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the produced type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mergedPublishers</code> - The <code>Publisher</code> of <code>Publisher</code> to switch on and mirror.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <code>SinkManyAbstractBase</code> accepting publishers and producing T</dd>
</dl>
</li>
</ul>
<a name="switchOnNext-org.reactivestreams.Publisher-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>switchOnNext</h4>
<pre>@Deprecated
public static&nbsp;&lt;T&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;switchOnNext(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;mergedPublishers,
                                                    int&nbsp;prefetch)</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">to be removed in 3.6.0 at the earliest. In 3.5.0, you should replace
 calls with prefetch=0 with calls to switchOnNext(mergedPublishers), as the default
 behavior of the single-parameter variant will then change to prefetch=0.</span></div>
<div class="block">Creates a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that mirrors the most recently emitted <code>Publisher</code>,
 forwarding its data until a new <code>Publisher</code> comes in the source.
 <p>
 The resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> will complete once there are no new <code>Publisher</code> in
 the source (source has completed) and the last mirrored <code>Publisher</code> has also
 completed.
 <p>
 <img class="marble" src="doc-files/marbles/switchOnNext.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the produced type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mergedPublishers</code> - The <code>Publisher</code> of <code>Publisher</code> to switch on and mirror.</dd>
<dd><code>prefetch</code> - the inner source request size</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <code>SinkManyAbstractBase</code> accepting publishers and producing T</dd>
</dl>
</li>
</ul>
<a name="using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>using</h4>
<pre>public static&nbsp;&lt;T,D&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;using(java.util.concurrent.Callable&lt;? extends D&gt;&nbsp;resourceSupplier,
                                  java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sourceSupplier,
                                  java.util.function.Consumer&lt;? super D&gt;&nbsp;resourceCleanup)</pre>
<div class="block">Uses a resource, generated by a supplier for each individual Subscriber, while streaming the values from a
 Publisher derived from the same resource and makes sure the resource is released if the sequence terminates or
 the Subscriber cancels.
 <p>
 Eager resource cleanup happens just before the source termination and exceptions raised by the cleanup Consumer
 may override the terminal event.
 <p>
 <img class="marble" src="doc-files/marbles/usingForFlux.svg" alt="">
 <p>
 For an asynchronous version of the cleanup, with distinct path for onComplete, onError
 and cancel terminations, see <a href="../../../reactor/core/publisher/Flux.html#usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-java.util.function.Function-"><code>usingWhen(Publisher, Function, Function, BiFunction, Function)</code></a>.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - emitted type</dd>
<dd><code>D</code> - resource type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>resourceSupplier</code> - a <code>Callable</code> that is called on subscribe to generate the resource</dd>
<dd><code>sourceSupplier</code> - a factory to derive a <code>Publisher</code> from the supplied resource</dd>
<dd><code>resourceCleanup</code> - a resource cleanup callback invoked on completion</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> built around a disposable resource</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-java.util.function.Function-"><code>usingWhen(Publisher, Function, Function, BiFunction, Function)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-"><code>usingWhen(Publisher, Function, Function)</code></a></dd>
</dl>
</li>
</ul>
<a name="using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>using</h4>
<pre>public static&nbsp;&lt;T,D&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;using(java.util.concurrent.Callable&lt;? extends D&gt;&nbsp;resourceSupplier,
                                  java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;sourceSupplier,
                                  java.util.function.Consumer&lt;? super D&gt;&nbsp;resourceCleanup,
                                  boolean&nbsp;eager)</pre>
<div class="block">Uses a resource, generated by a supplier for each individual Subscriber, while streaming the values from a
 Publisher derived from the same resource and makes sure the resource is released if the sequence terminates or
 the Subscriber cancels.
 <p>
 <ul> <li>Eager resource cleanup happens just before the source termination and exceptions raised by the cleanup
 Consumer may override the terminal event.</li> <li>Non-eager cleanup will drop any exception.</li> </ul>
 <p>
 <img class="marble" src="doc-files/marbles/usingForFlux.svg" alt="">
 <p>
 For an asynchronous version of the cleanup, with distinct path for onComplete, onError
 and cancel terminations, see <a href="../../../reactor/core/publisher/Flux.html#usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-java.util.function.Function-"><code>usingWhen(Publisher, Function, Function, BiFunction, Function)</code></a>.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - emitted type</dd>
<dd><code>D</code> - resource type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>resourceSupplier</code> - a <code>Callable</code> that is called on subscribe to generate the resource</dd>
<dd><code>sourceSupplier</code> - a factory to derive a <code>Publisher</code> from the supplied resource</dd>
<dd><code>resourceCleanup</code> - a resource cleanup callback invoked on completion</dd>
<dd><code>eager</code> - true to clean before terminating downstream subscribers</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> built around a disposable resource</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-java.util.function.Function-"><code>usingWhen(Publisher, Function, Function, BiFunction, Function)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-"><code>usingWhen(Publisher, Function, Function)</code></a></dd>
</dl>
</li>
</ul>
<a name="usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>usingWhen</h4>
<pre>public static&nbsp;&lt;T,D&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;usingWhen(org.reactivestreams.Publisher&lt;D&gt;&nbsp;resourceSupplier,
                                      java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;resourceClosure,
                                      java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;asyncCleanup)</pre>
<div class="block">Uses a resource, generated by a <code>Publisher</code> for each individual <code>Subscriber</code>,
 while streaming the values from a <code>Publisher</code> derived from the same resource.
 Whenever the resulting sequence terminates, a provided <code>Function</code> generates
 a "cleanup" <code>Publisher</code> that is invoked but doesn't change the content of the
 main sequence. Instead it just defers the termination (unless it errors, in which case
 the error suppresses the original termination signal).
 <p>
 Note that if the resource supplying <code>Publisher</code> emits more than one resource, the
 subsequent resources are dropped (<a href="../../../reactor/core/publisher/Operators.html#onNextDropped-T-reactor.util.context.Context-"><code>Operators.onNextDropped(Object, Context)</code></a>). If
 the publisher errors AFTER having emitted one resource, the error is also silently dropped
 (<a href="../../../reactor/core/publisher/Operators.html#onErrorDropped-java.lang.Throwable-reactor.util.context.Context-"><code>Operators.onErrorDropped(Throwable, Context)</code></a>).
 An empty completion or error without at least one onNext signal triggers a short-circuit
 of the main sequence with the same terminal signal (no resource is established, no
 cleanup is invoked).

 <p>
 <img class="marble" src="doc-files/marbles/usingWhenSuccessForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the type of elements emitted by the resource closure, and thus the main sequence</dd>
<dd><code>D</code> - the type of the resource object</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>resourceSupplier</code> - a <code>Publisher</code> that "generates" the resource,
 subscribed for each subscription to the main sequence</dd>
<dd><code>resourceClosure</code> - a factory to derive a <code>Publisher</code> from the supplied resource</dd>
<dd><code>asyncCleanup</code> - an asynchronous resource cleanup invoked when the resource
 closure terminates (with onComplete, onError or cancel)</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> built around a "transactional" resource, with asynchronous
 cleanup on all terminations (onComplete, onError, cancel)</dd>
</dl>
</li>
</ul>
<a name="usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>usingWhen</h4>
<pre>public static&nbsp;&lt;T,D&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;T&gt;&nbsp;usingWhen(org.reactivestreams.Publisher&lt;D&gt;&nbsp;resourceSupplier,
                                      java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;? extends T&gt;&gt;&nbsp;resourceClosure,
                                      java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;asyncComplete,
                                      java.util.function.BiFunction&lt;? super D,? super java.lang.Throwable,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;asyncError,
                                      java.util.function.Function&lt;? super D,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;asyncCancel)</pre>
<div class="block">Uses a resource, generated by a <code>Publisher</code> for each individual <code>Subscriber</code>,
 while streaming the values from a <code>Publisher</code> derived from the same resource.
 Note that all steps of the operator chain that would need the resource to be in an open
 stable state need to be described inside the <code>resourceClosure</code> <code>Function</code>.
 <p>
 Whenever the resulting sequence terminates, the relevant <code>Function</code> generates
 a "cleanup" <code>Publisher</code> that is invoked but doesn't change the content of the
 main sequence. Instead it just defers the termination (unless it errors, in which case
 the error suppresses the original termination signal).

 <p>
 <img class="marble" src="doc-files/marbles/usingWhenSuccessForFlux.svg" alt="">
 <p>
 Individual cleanups can also be associated with main sequence cancellation and
 error terminations:
 <p>
 <img class="marble" src="doc-files/marbles/usingWhenFailureForFlux.svg" alt="">
 <p>
 Note that if the resource supplying <code>Publisher</code> emits more than one resource, the
 subsequent resources are dropped (<a href="../../../reactor/core/publisher/Operators.html#onNextDropped-T-reactor.util.context.Context-"><code>Operators.onNextDropped(Object, Context)</code></a>). If
 the publisher errors AFTER having emitted one resource, the error is also silently dropped
 (<a href="../../../reactor/core/publisher/Operators.html#onErrorDropped-java.lang.Throwable-reactor.util.context.Context-"><code>Operators.onErrorDropped(Throwable, Context)</code></a>).
 An empty completion or error without at least one onNext signal triggers a short-circuit
 of the main sequence with the same terminal signal (no resource is established, no
 cleanup is invoked).
 <p>
 Additionally, the terminal signal is replaced by any error that might have happened
 in the terminating <code>Publisher</code>:
 <p>
 <img class="marble" src="doc-files/marbles/usingWhenCleanupErrorForFlux.svg" alt="">
 <p>
 Finally, early cancellations will cancel the resource supplying <code>Publisher</code>:
 <p>
 <img class="marble" src="doc-files/marbles/usingWhenEarlyCancelForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T</code> - the type of elements emitted by the resource closure, and thus the main sequence</dd>
<dd><code>D</code> - the type of the resource object</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>resourceSupplier</code> - a <code>Publisher</code> that "generates" the resource,
 subscribed for each subscription to the main sequence</dd>
<dd><code>resourceClosure</code> - a factory to derive a <code>Publisher</code> from the supplied resource</dd>
<dd><code>asyncComplete</code> - an asynchronous resource cleanup invoked if the resource closure terminates with onComplete</dd>
<dd><code>asyncError</code> - an asynchronous resource cleanup invoked if the resource closure terminates with onError.
 The terminating error is provided to the <code>BiFunction</code></dd>
<dd><code>asyncCancel</code> - an asynchronous resource cleanup invoked if the resource closure is cancelled.
 When <code>null</code>, the <code>asyncComplete</code> path is used instead.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> built around a "transactional" resource, with several
 termination path triggering asynchronous cleanup sequences</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#usingWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-"><code>usingWhen(Publisher, Function, Function)</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>public static&nbsp;&lt;T1,T2,O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;&nbsp;zip(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                    org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                    java.util.function.BiFunction&lt;? super T1,? super T2,? extends O&gt;&nbsp;combinator)</pre>
<div class="block">Zip two sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator). The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipTwoSourcesWithZipperForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>O</code> - The produced output after transformation by the combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first <code>Publisher</code> source to zip.</dd>
<dd><code>source2</code> - The second <code>Publisher</code> source to zip.</dd>
<dd><code>combinator</code> - The aggregate function that will receive a unique value from each upstream and return the
 value to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>public static&nbsp;&lt;T1,T2&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;T1,T2&gt;&gt;&nbsp;zip(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                              org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2)</pre>
<div class="block">Zip two sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a>.
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipFixedSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first <code>Publisher</code> source to zip.</dd>
<dd><code>source2</code> - The second <code>Publisher</code> source to zip.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>public static&nbsp;&lt;T1,T2,T3&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple3.html" title="reactor.util.function中的类">Tuple3</a>&lt;T1,T2,T3&gt;&gt;&nbsp;zip(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                                    org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                                    org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3)</pre>
<div class="block">Zip three sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple3.html" title="reactor.util.function中的类"><code>Tuple3</code></a>.
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipFixedSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>T3</code> - type of the value from source3</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source2</code> - The second upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source3</code> - The third upstream <code>Publisher</code> to subscribe to.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>public static&nbsp;&lt;T1,T2,T3,T4&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple4.html" title="reactor.util.function中的类">Tuple4</a>&lt;T1,T2,T3,T4&gt;&gt;&nbsp;zip(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                                          org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                                          org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
                                                          org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4)</pre>
<div class="block">Zip four sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple4.html" title="reactor.util.function中的类"><code>Tuple4</code></a>.
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipFixedSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>T3</code> - type of the value from source3</dd>
<dd><code>T4</code> - type of the value from source4</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source2</code> - The second upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source3</code> - The third upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source4</code> - The fourth upstream <code>Publisher</code> to subscribe to.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>public static&nbsp;&lt;T1,T2,T3,T4,T5&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple5.html" title="reactor.util.function中的类">Tuple5</a>&lt;T1,T2,T3,T4,T5&gt;&gt;&nbsp;zip(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                                                org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                                                org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
                                                                org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
                                                                org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5)</pre>
<div class="block">Zip five sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple5.html" title="reactor.util.function中的类"><code>Tuple5</code></a>.
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipFixedSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>T3</code> - type of the value from source3</dd>
<dd><code>T4</code> - type of the value from source4</dd>
<dd><code>T5</code> - type of the value from source5</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source2</code> - The second upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source3</code> - The third upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source4</code> - The fourth upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source5</code> - The fifth upstream <code>Publisher</code> to subscribe to.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>public static&nbsp;&lt;T1,T2,T3,T4,T5,T6&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple6.html" title="reactor.util.function中的类">Tuple6</a>&lt;T1,T2,T3,T4,T5,T6&gt;&gt;&nbsp;zip(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                                                      org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                                                      org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
                                                                      org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
                                                                      org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5,
                                                                      org.reactivestreams.Publisher&lt;? extends T6&gt;&nbsp;source6)</pre>
<div class="block">Zip six sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple6.html" title="reactor.util.function中的类"><code>Tuple6</code></a>.
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipFixedSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>T3</code> - type of the value from source3</dd>
<dd><code>T4</code> - type of the value from source4</dd>
<dd><code>T5</code> - type of the value from source5</dd>
<dd><code>T6</code> - type of the value from source6</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source2</code> - The second upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source3</code> - The third upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source4</code> - The fourth upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source5</code> - The fifth upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source6</code> - The sixth upstream <code>Publisher</code> to subscribe to.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>public static&nbsp;&lt;T1,T2,T3,T4,T5,T6,T7&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple7.html" title="reactor.util.function中的类">Tuple7</a>&lt;T1,T2,T3,T4,T5,T6,T7&gt;&gt;&nbsp;zip(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                                                            org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                                                            org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
                                                                            org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
                                                                            org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5,
                                                                            org.reactivestreams.Publisher&lt;? extends T6&gt;&nbsp;source6,
                                                                            org.reactivestreams.Publisher&lt;? extends T7&gt;&nbsp;source7)</pre>
<div class="block">Zip seven sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple7.html" title="reactor.util.function中的类"><code>Tuple7</code></a>.
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipFixedSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>T3</code> - type of the value from source3</dd>
<dd><code>T4</code> - type of the value from source4</dd>
<dd><code>T5</code> - type of the value from source5</dd>
<dd><code>T6</code> - type of the value from source6</dd>
<dd><code>T7</code> - type of the value from source7</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source2</code> - The second upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source3</code> - The third upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source4</code> - The fourth upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source5</code> - The fifth upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source6</code> - The sixth upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source7</code> - The seventh upstream <code>Publisher</code> to subscribe to.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>public static&nbsp;&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple8.html" title="reactor.util.function中的类">Tuple8</a>&lt;T1,T2,T3,T4,T5,T6,T7,T8&gt;&gt;&nbsp;zip(org.reactivestreams.Publisher&lt;? extends T1&gt;&nbsp;source1,
                                                                                  org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                                                                  org.reactivestreams.Publisher&lt;? extends T3&gt;&nbsp;source3,
                                                                                  org.reactivestreams.Publisher&lt;? extends T4&gt;&nbsp;source4,
                                                                                  org.reactivestreams.Publisher&lt;? extends T5&gt;&nbsp;source5,
                                                                                  org.reactivestreams.Publisher&lt;? extends T6&gt;&nbsp;source6,
                                                                                  org.reactivestreams.Publisher&lt;? extends T7&gt;&nbsp;source7,
                                                                                  org.reactivestreams.Publisher&lt;? extends T8&gt;&nbsp;source8)</pre>
<div class="block">Zip eight sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into a <a href="../../../reactor/util/function/Tuple8.html" title="reactor.util.function中的类"><code>Tuple8</code></a>.
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipFixedSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T1</code> - type of the value from source1</dd>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>T3</code> - type of the value from source3</dd>
<dd><code>T4</code> - type of the value from source4</dd>
<dd><code>T5</code> - type of the value from source5</dd>
<dd><code>T6</code> - type of the value from source6</dd>
<dd><code>T7</code> - type of the value from source7</dd>
<dd><code>T8</code> - type of the value from source8</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source1</code> - The first upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source2</code> - The second upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source3</code> - The third upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source4</code> - The fourth upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source5</code> - The fifth upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source6</code> - The sixth upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source7</code> - The seventh upstream <code>Publisher</code> to subscribe to.</dd>
<dd><code>source8</code> - The eight upstream <code>Publisher</code> to subscribe to.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-java.lang.Iterable-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>public static&nbsp;&lt;O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;&nbsp;zip(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;sources,
                              java.util.function.Function&lt;? super java.lang.Object[],? extends O&gt;&nbsp;combinator)</pre>
<div class="block">Zip multiple sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator).
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.

 The <code>Iterable.iterator()</code> will be called on each <code>Publisher.subscribe(Subscriber)</code>.

 <p>
 <img class="marble" src="doc-files/marbles/zipIterableSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>O</code> - the combined produced type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - the <code>Iterable</code> providing sources to zip</dd>
<dd><code>combinator</code> - The aggregate function that will receive a unique value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-java.lang.Iterable-int-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>public static&nbsp;&lt;O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;&nbsp;zip(java.lang.Iterable&lt;? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;sources,
                              int&nbsp;prefetch,
                              java.util.function.Function&lt;? super java.lang.Object[],? extends O&gt;&nbsp;combinator)</pre>
<div class="block">Zip multiple sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator).
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.

 The <code>Iterable.iterator()</code> will be called on each <code>Publisher.subscribe(Subscriber)</code>.

 <p>
 <img class="marble" src="doc-files/marbles/zipIterableSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>O</code> - the combined produced type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - the <code>Iterable</code> providing sources to zip</dd>
<dd><code>prefetch</code> - the inner source request size</dd>
<dd><code>combinator</code> - The aggregate function that will receive a unique value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-java.util.function.Function-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I,O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;&nbsp;zip(java.util.function.Function&lt;? super java.lang.Object[],? extends O&gt;&nbsp;combinator,
                                              org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block">Zip multiple sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator).
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipIterableSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - the type of the input sources</dd>
<dd><code>O</code> - the combined produced type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>combinator</code> - The aggregate function that will receive a unique value from each upstream and return the
 value to signal downstream</dd>
<dd><code>sources</code> - the array providing sources to zip</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-java.util.function.Function-int-org.reactivestreams.Publisher...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>@SafeVarargs
public static&nbsp;&lt;I,O&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;O&gt;&nbsp;zip(java.util.function.Function&lt;? super java.lang.Object[],? extends O&gt;&nbsp;combinator,
                                              int&nbsp;prefetch,
                                              org.reactivestreams.Publisher&lt;? extends I&gt;...&nbsp;sources)</pre>
<div class="block">Zip multiple sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator).
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipIterableSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>I</code> - the type of the input sources</dd>
<dd><code>O</code> - the combined produced type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>combinator</code> - The aggregate function that will receive a unique value from each upstream and return the
 value to signal downstream</dd>
<dd><code>prefetch</code> - individual source request size</dd>
<dd><code>sources</code> - the array providing sources to zip</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zip-org.reactivestreams.Publisher-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zip</h4>
<pre>public static&nbsp;&lt;TUPLE extends <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;zip(org.reactivestreams.Publisher&lt;? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;sources,
                                                   java.util.function.Function&lt;? super TUPLE,? extends V&gt;&nbsp;combinator)</pre>
<div class="block">Zip multiple sources together, that is to say wait for all the sources to emit one
 element and combine these elements once into an output value (constructed by the provided
 combinator).
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 Note that the <code>Publisher</code> sources from the outer <code>Publisher</code> will
 accumulate into an exhaustive list before starting zip operation.
 <p>
 <img class="marble" src="doc-files/marbles/zipAsyncSourcesForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>TUPLE</code> - the raw tuple type</dd>
<dd><code>V</code> - The produced output after transformation by the given combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sources</code> - The <code>Publisher</code> of <code>Publisher</code> sources to zip. A finite publisher is required.</dd>
<dd><code>combinator</code> - The aggregate function that will receive a unique value from each upstream and return the value
 to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> based on the produced value</dd>
</dl>
</li>
</ul>
<a name="all-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>all</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Boolean&gt;&nbsp;all(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate)</pre>
<div class="block">如果此序列的所有值都与 <code>Predicate</code> 匹配，则发出单个布尔值 true.
 否则返回false
 <p>
 Emit a single boolean true if all values of this sequence match
 the <code>Predicate</code>.
 <p>
 The implementation uses short-circuit logic and completes with false if
 the predicate doesn't match a value.

 <p>
 <img class="marble" src="doc-files/marbles/all.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>predicate</code> - the <code>Predicate</code> that needs to apply to all emitted items</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> with <code>true</code> if all values satisfies a predicate and <code>false</code>
 otherwise</dd>
</dl>
</li>
</ul>
<a name="any-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>any</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Boolean&gt;&nbsp;any(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate)</pre>
<div class="block">Emit a single boolean true if any of the values of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence match
 the predicate.
 <p>
 The implementation uses short-circuit logic and completes with true if
 the predicate matches a value.

 <p>
 <img class="marble" src="doc-files/marbles/any.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>predicate</code> - the <code>Predicate</code> that needs to apply to at least one emitted item</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> with <code>true</code> if any value satisfies a predicate and <code>false</code>
 otherwise</dd>
</dl>
</li>
</ul>
<a name="as-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>as</h4>
<pre>public final&nbsp;&lt;P&gt;&nbsp;P&nbsp;as(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,P&gt;&nbsp;transformer)</pre>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a target type.
 <blockquote><pre>
 <code> flux.as(Mono::from).subscribe() </code>
 </pre></blockquote></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>P</code> - the returned instance type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>transformer</code> - the <code>Function</code> to immediately map this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 into a target type instance.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> transformed to an instance of P</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#transformDeferred-java.util.function.Function-"><code>transformDeferred(Function) for a lazy transformation of Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="blockFirst--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blockFirst</h4>
<pre><a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;blockFirst()</pre>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and <strong>block indefinitely</strong>
 until the upstream signals its first value or completes. Returns that value,
 or null if the Flux completes empty. In case the Flux errors, the original
 exception is thrown (wrapped in a <code>RuntimeException</code> if it was a checked
 exception).
 <p>
 Note that each blockFirst() will trigger a new subscription: in other words,
 the result might miss signal from hot publishers.

 <p>
 <img class="marble" src="doc-files/marbles/blockFirst.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the first value or null</dd>
</dl>
</li>
</ul>
<a name="blockFirst-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blockFirst</h4>
<pre><a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;blockFirst(java.time.Duration&nbsp;timeout)</pre>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and <strong>block</strong> until the upstream
 signals its first value, completes or a timeout expires. Returns that value,
 or null if the Flux completes empty. In case the Flux errors, the original
 exception is thrown (wrapped in a <code>RuntimeException</code> if it was a checked
 exception). If the provided timeout expires, a <code>RuntimeException</code> is thrown.
 <p>
 Note that each blockFirst() will trigger a new subscription: in other words,
 the result might miss signal from hot publishers.

 <p>
 <img class="marble" src="doc-files/marbles/blockFirstWithTimeout.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timeout</code> - maximum time period to wait for before raising a <code>RuntimeException</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the first value or null</dd>
</dl>
</li>
</ul>
<a name="blockLast--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blockLast</h4>
<pre><a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;blockLast()</pre>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and <strong>block indefinitely</strong>
 until the upstream signals its last value or completes. Returns that value,
 or null if the Flux completes empty. In case the Flux errors, the original
 exception is thrown (wrapped in a <code>RuntimeException</code> if it was a checked
 exception).
 <p>
 Note that each blockLast() will trigger a new subscription: in other words,
 the result might miss signal from hot publishers.

 <p>
 <img class="marble" src="doc-files/marbles/blockLast.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the last value or null</dd>
</dl>
</li>
</ul>
<a name="blockLast-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>blockLast</h4>
<pre><a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;blockLast(java.time.Duration&nbsp;timeout)</pre>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and <strong>block</strong> until the upstream
 signals its last value, completes or a timeout expires. Returns that value,
 or null if the Flux completes empty. In case the Flux errors, the original
 exception is thrown (wrapped in a <code>RuntimeException</code> if it was a checked
 exception). If the provided timeout expires, a <code>RuntimeException</code> is thrown.
 <p>
 Note that each blockLast() will trigger a new subscription: in other words,
 the result might miss signal from hot publishers.

 <p>
 <img class="marble" src="doc-files/marbles/blockLastWithTimeout.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timeout</code> - maximum time period to wait for before raising a <code>RuntimeException</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the last value or null</dd>
</dl>
</li>
</ul>
<a name="buffer--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;buffer()</pre>
<div class="block">Collect all incoming values into a single <code>List</code> buffer that will be emitted
 by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> once this Flux completes.
 <p>
 <img class="marble" src="doc-files/marbles/buffer.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the buffer upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a buffered <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of at most one <code>List</code></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#collectList--"><code>for an alternative collecting algorithm returning {@link Mono}</code></a></dd>
</dl>
</li>
</ul>
<a name="buffer-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;buffer(int&nbsp;maxSize)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted
 by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given max size is reached or once this
 Flux completes.
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithMaxSize.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the maximum collected size</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code></dd>
</dl>
</li>
</ul>
<a name="buffer-int-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public final&nbsp;&lt;C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;&nbsp;buffer(int&nbsp;maxSize,
                                                                        java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</pre>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers that
 will be emitted by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given max size is reached
 or once this Flux completes.
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithMaxSize.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal,
 as well as latest unbuffered element if the bufferSupplier fails.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>C</code> - the <code>Collection</code> buffer type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the maximum collected size</dd>
<dd><code>bufferSupplier</code> - a <code>Supplier</code> of the concrete <code>Collection</code> to use for each buffer</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>Collection</code></dd>
</dl>
</li>
</ul>
<a name="buffer-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;buffer(int&nbsp;maxSize,
                                            int&nbsp;skip)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted
 by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given max size is reached or once this
 Flux completes. Buffers can be created with gaps, as a new buffer will be created
 every time <code>skip</code> values have been emitted by the source.
 <p>
 When maxSize < skip : dropping buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithMaxSizeLessThanSkipSize.svg" alt="">
 <p>
 When maxSize > skip : overlapping buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithMaxSizeGreaterThanSkipSize.svg" alt="">
 <p>
 When maxSize == skip : exact buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithMaxSizeEqualsSkipSize.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements in between buffers (in the case of
 dropping buffers). It also discards the currently open buffer upon cancellation or error triggered by a data signal.
 Note however that overlapping buffer variant DOES NOT discard, as this might result in an element
 being discarded from an early buffer while it is still valid in a more recent buffer.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>skip</code> - the number of items to count before creating a new buffer</dd>
<dd><code>maxSize</code> - the max collected size</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of possibly overlapped or gapped <code>List</code></dd>
</dl>
</li>
</ul>
<a name="buffer-int-int-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public final&nbsp;&lt;C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;&nbsp;buffer(int&nbsp;maxSize,
                                                                        int&nbsp;skip,
                                                                        java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</pre>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers that
 will be emitted by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given max size is reached
 or once this Flux completes. Buffers can be created with gaps, as a new buffer will
 be created every time <code>skip</code> values have been emitted by the source
 <p>
 When maxSize < skip : dropping buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithMaxSizeLessThanSkipSize.svg" alt="">
 <p>
 When maxSize > skip : overlapping buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithMaxSizeGreaterThanSkipSize.svg" alt="">
 <p>
 When maxSize == skip : exact buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithMaxSizeEqualsSkipSize.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements in between buffers (in the case of
 dropping buffers). It also discards the currently open buffer upon cancellation or error triggered by a data signal.
 Note however that overlapping buffer variant DOES NOT discard, as this might result in an element
 being discarded from an early buffer while it is still valid in a more recent buffer.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>C</code> - the <code>Collection</code> buffer type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>skip</code> - the number of items to count before creating a new buffer</dd>
<dd><code>maxSize</code> - the max collected size</dd>
<dd><code>bufferSupplier</code> - a <code>Supplier</code> of the concrete <code>Collection</code> to use for each buffer</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of possibly overlapped or gapped
 <code>Collection</code></dd>
</dl>
</li>
</ul>
<a name="buffer-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;buffer(org.reactivestreams.Publisher&lt;?&gt;&nbsp;other)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers, as delimited by the
 signals of a companion <code>Publisher</code> this operator will subscribe to.
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithBoundary.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the companion <code>Publisher</code> whose signals trigger new buffers</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code> delimited by signals from a <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="buffer-org.reactivestreams.Publisher-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public final&nbsp;&lt;C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;&nbsp;buffer(org.reactivestreams.Publisher&lt;?&gt;&nbsp;other,
                                                                        java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</pre>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers, as
 delimited by the signals of a companion <code>Publisher</code> this operator will
 subscribe to.
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithBoundary.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal,
 and the last received element when the bufferSupplier fails.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>C</code> - the <code>Collection</code> buffer type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the companion <code>Publisher</code> whose signals trigger new buffers</dd>
<dd><code>bufferSupplier</code> - a <code>Supplier</code> of the concrete <code>Collection</code> to use for each buffer</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>Collection</code> delimited by signals from a <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="buffer-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;buffer(java.time.Duration&nbsp;bufferingTimespan)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted by
 the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> every <code>bufferingTimespan</code>.
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithTimespan.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>bufferingTimespan</code> - the duration from buffer creation until a buffer is closed and emitted</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code> delimited by the given time span</dd>
</dl>
</li>
</ul>
<a name="buffer-java.time.Duration-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;buffer(java.time.Duration&nbsp;bufferingTimespan,
                                            java.time.Duration&nbsp;openBufferEvery)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers created at a given
 <code>openBufferEvery</code> period. Each buffer will last until the <code>bufferingTimespan</code> has elapsed,
 thus emitting the bucket in the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.
 <p>
 When bufferingTimespan < openBufferEvery : dropping buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithTimespanLessThanOpenBufferEvery.svg" alt="">
 <p>
 When bufferingTimespan > openBufferEvery : overlapping buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithTimespanGreaterThanOpenBufferEvery.svg" alt="">
 <p>
 When bufferingTimespan == openBufferEvery : exact buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithTimespanEqualsOpenBufferEvery.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.
 It DOES NOT provide strong guarantees in the case of overlapping buffers, as elements
 might get discarded too early (from the first of two overlapping buffers for instance).</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>bufferingTimespan</code> - the duration from buffer creation until a buffer is closed and emitted</dd>
<dd><code>openBufferEvery</code> - the interval at which to create a new buffer</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code> delimited by the given period openBufferEvery and sized by bufferingTimespan</dd>
</dl>
</li>
</ul>
<a name="buffer-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;buffer(java.time.Duration&nbsp;bufferingTimespan,
                                            <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted by
 the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> every <code>bufferingTimespan</code>, as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithTimespan.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>bufferingTimespan</code> - the duration from buffer creation until a buffer is closed and emitted</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code> delimited by the given period</dd>
</dl>
</li>
</ul>
<a name="buffer-java.time.Duration-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>buffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;buffer(java.time.Duration&nbsp;bufferingTimespan,
                                            java.time.Duration&nbsp;openBufferEvery,
                                            <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers created at a given
 <code>openBufferEvery</code> period, as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>. Each
 buffer will last until the <code>bufferingTimespan</code> has elapsed (also measured on the scheduler),
 thus emitting the bucket in the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.
 <p>
 When bufferingTimespan < openBufferEvery : dropping buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithTimespanLessThanOpenBufferEvery.svg" alt="">
 <p>
 When bufferingTimespan > openBufferEvery : overlapping buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithTimespanGreaterThanOpenBufferEvery.svg" alt="">
 <p>
 When bufferingTimespan == openBufferEvery : exact buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWithTimespanEqualsOpenBufferEvery.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.
 It DOES NOT provide strong guarantees in the case of overlapping buffers, as elements
 might get discarded too early (from the first of two overlapping buffers for instance).</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>bufferingTimespan</code> - the duration from buffer creation until a buffer is closed and emitted</dd>
<dd><code>openBufferEvery</code> - the interval at which to create a new buffer</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code> delimited by the given period openBufferEvery and sized by bufferingTimespan</dd>
</dl>
</li>
</ul>
<a name="bufferTimeout-int-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferTimeout</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;bufferTimeout(int&nbsp;maxSize,
                                                   java.time.Duration&nbsp;maxTime)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted
 by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the buffer reaches a maximum size OR the
 maxTime <code>Duration</code> elapses.
 <p>
 <img class="marble" src="doc-files/marbles/bufferTimeoutWithMaxSizeAndTimespan.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the max collected size</dd>
<dd><code>maxTime</code> - the timeout enforcing the release of a partial buffer</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code> delimited by given size or a given period timeout</dd>
</dl>
</li>
</ul>
<a name="bufferTimeout-int-java.time.Duration-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferTimeout</h4>
<pre>public final&nbsp;&lt;C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;&nbsp;bufferTimeout(int&nbsp;maxSize,
                                                                               java.time.Duration&nbsp;maxTime,
                                                                               java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</pre>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers that
 will be emitted by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the buffer reaches a maximum
 size OR the maxTime <code>Duration</code> elapses.
 <p>
 <img class="marble" src="doc-files/marbles/bufferTimeoutWithMaxSizeAndTimespan.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>C</code> - the <code>Collection</code> buffer type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the max collected size</dd>
<dd><code>maxTime</code> - the timeout enforcing the release of a partial buffer</dd>
<dd><code>bufferSupplier</code> - a <code>Supplier</code> of the concrete <code>Collection</code> to use for each buffer</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>Collection</code> delimited by given size or a given period timeout</dd>
</dl>
</li>
</ul>
<a name="bufferTimeout-int-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferTimeout</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;bufferTimeout(int&nbsp;maxSize,
                                                   java.time.Duration&nbsp;maxTime,
                                                   <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted
 by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the buffer reaches a maximum size OR the
 maxTime <code>Duration</code> elapses, as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/bufferTimeoutWithMaxSizeAndTimespan.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the max collected size</dd>
<dd><code>maxTime</code> - the timeout enforcing the release of a partial buffer</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code> delimited by given size or a given period timeout</dd>
</dl>
</li>
</ul>
<a name="bufferTimeout-int-java.time.Duration-reactor.core.scheduler.Scheduler-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferTimeout</h4>
<pre>public final&nbsp;&lt;C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;&nbsp;bufferTimeout(int&nbsp;maxSize,
                                                                               java.time.Duration&nbsp;maxTime,
                                                                               <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer,
                                                                               java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</pre>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers that
 will be emitted by the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the buffer reaches a maximum
 size OR the maxTime <code>Duration</code> elapses, as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/bufferTimeoutWithMaxSizeAndTimespan.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>C</code> - the <code>Collection</code> buffer type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the max collected size</dd>
<dd><code>maxTime</code> - the timeout enforcing the release of a partial buffer</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dd><code>bufferSupplier</code> - a <code>Supplier</code> of the concrete <code>Collection</code> to use for each buffer</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>Collection</code> delimited by given size or a given period timeout</dd>
</dl>
</li>
</ul>
<a name="bufferUntil-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferUntil</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;bufferUntil(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted by
 the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given predicate returns true. Note that
 the element that triggers the predicate to return true (and thus closes a buffer)
 is included as last element in the emitted buffer.
 <p>
 <img class="marble" src="doc-files/marbles/bufferUntil.svg" alt="">
 <p>
 On completion, if the latest buffer is non-empty and has not been closed it is
 emitted. However, such a "partial" buffer isn't emitted in case of onError
 termination.

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>predicate</code> - a predicate that triggers the next buffer when it becomes true.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code></dd>
</dl>
</li>
</ul>
<a name="bufferUntil-java.util.function.Predicate-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferUntil</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;bufferUntil(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate,
                                                 boolean&nbsp;cutBefore)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted by
 the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> each time the given predicate returns true. Note that
 the buffer into which the element that triggers the predicate to return true
 (and thus closes a buffer) is included depends on the <code>cutBefore</code> parameter:
 set it to true to include the boundary element in the newly opened buffer, false to
 include it in the closed buffer (as in <a href="../../../reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-"><code>bufferUntil(Predicate)</code></a>).
 <p>
 <img class="marble" src="doc-files/marbles/bufferUntilWithCutBefore.svg" alt="">
 <p>
 On completion, if the latest buffer is non-empty and has not been closed it is
 emitted. However, such a "partial" buffer isn't emitted in case of onError
 termination.

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>predicate</code> - a predicate that triggers the next buffer when it becomes true.</dd>
<dd><code>cutBefore</code> - set to true to include the triggering element in the new buffer rather than the old.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code></dd>
</dl>
</li>
</ul>
<a name="bufferUntilChanged--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferUntilChanged</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;bufferUntilChanged()</pre>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another) into multiple <code>List</code> buffers that will be emitted by the
 resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/bufferUntilChanged.svg" alt="">
 <p></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code></dd>
</dl>
</li>
</ul>
<a name="bufferUntilChanged-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferUntilChanged</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;bufferUntilChanged(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector)</pre>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another), as compared by a key extracted through the user provided <code>Function</code>, into multiple <code>List</code> buffers that will be emitted by the
 resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/bufferUntilChangedWithKey.svg" alt="">
 <p></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keySelector</code> - function to compute comparison key for each element</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code></dd>
</dl>
</li>
</ul>
<a name="bufferUntilChanged-java.util.function.Function-java.util.function.BiPredicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferUntilChanged</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;bufferUntilChanged(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector,
                                                            java.util.function.BiPredicate&lt;? super V,? super V&gt;&nbsp;keyComparator)</pre>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another), as compared by a key extracted through the user provided <code>Function</code> and compared using a supplied <code>BiPredicate</code>, into multiple
 <code>List</code> buffers that will be emitted by the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/bufferUntilChangedWithKey.svg" alt="">
 <p></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keySelector</code> - function to compute comparison key for each element</dd>
<dd><code>keyComparator</code> - predicate used to compare keys</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code></dd>
</dl>
</li>
</ul>
<a name="bufferWhile-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferWhile</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;bufferWhile(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers that will be emitted by
 the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>. Each buffer continues aggregating values while the
 given predicate returns true, and a new buffer is created as soon as the
 predicate returns false... Note that the element that triggers the predicate
 to return false (and thus closes a buffer) is NOT included in any emitted buffer.
 <p>
 <img class="marble" src="doc-files/marbles/bufferWhile.svg" alt="">
 <p>
 On completion, if the latest buffer is non-empty and has not been closed it is
 emitted. However, such a "partial" buffer isn't emitted in case of onError
 termination.

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal,
 as well as the buffer-triggering element.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>predicate</code> - a predicate that triggers the next buffer when it becomes false.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code></dd>
</dl>
</li>
</ul>
<a name="bufferWhen-org.reactivestreams.Publisher-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferWhen</h4>
<pre>public final&nbsp;&lt;U,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;bufferWhen(org.reactivestreams.Publisher&lt;U&gt;&nbsp;bucketOpening,
                                                      java.util.function.Function&lt;? super U,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;closeSelector)</pre>
<div class="block">Collect incoming values into multiple <code>List</code> buffers started each time an opening
 companion <code>Publisher</code> emits. Each buffer will last until the corresponding
 closing companion <code>Publisher</code> emits, thus releasing the buffer to the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.
 <p>
 When Open signal is strictly not overlapping Close signal : dropping buffers (see green marbles in diagram below).
 <p>
 When Open signal is strictly more frequent than Close signal : overlapping buffers (see second and third buffers in diagram below).
 <p>
 When Open signal is exactly coordinated with Close signal : exact buffers
 <p>
 <img class="marble" src="doc-files/marbles/bufferWhen.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.
 It DOES NOT provide strong guarantees in the case of overlapping buffers, as elements
 might get discarded too early (from the first of two overlapping buffers for instance).</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the element type of the buffer-opening sequence</dd>
<dd><code>V</code> - the element type of the buffer-closing sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>bucketOpening</code> - a companion <code>Publisher</code> to subscribe for buffer creation signals.</dd>
<dd><code>closeSelector</code> - a factory that, given a buffer opening signal, returns a companion
 <code>Publisher</code> to subscribe to for buffer closure and emission signals.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>List</code> delimited by an opening <code>Publisher</code> and a relative
 closing <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="bufferWhen-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bufferWhen</h4>
<pre>public final&nbsp;&lt;U,V,C extends java.util.Collection&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;C&gt;&nbsp;bufferWhen(org.reactivestreams.Publisher&lt;U&gt;&nbsp;bucketOpening,
                                                                                java.util.function.Function&lt;? super U,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;closeSelector,
                                                                                java.util.function.Supplier&lt;C&gt;&nbsp;bufferSupplier)</pre>
<div class="block">Collect incoming values into multiple user-defined <code>Collection</code> buffers started each time an opening
 companion <code>Publisher</code> emits. Each buffer will last until the corresponding
 closing companion <code>Publisher</code> emits, thus releasing the buffer to the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.
 <p>
 When Open signal is strictly not overlapping Close signal : dropping buffers (see green marbles in diagram below).
 <p>
 When Open signal is strictly more frequent than Close signal : overlapping buffers (see second and third buffers in diagram below).
 <p>
 <img class="marble" src="doc-files/marbles/bufferWhenWithSupplier.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the currently open buffer upon cancellation or error triggered by a data signal.
 It DOES NOT provide strong guarantees in the case of overlapping buffers, as elements
 might get discarded too early (from the first of two overlapping buffers for instance).</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the element type of the buffer-opening sequence</dd>
<dd><code>V</code> - the element type of the buffer-closing sequence</dd>
<dd><code>C</code> - the <code>Collection</code> buffer type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>bucketOpening</code> - a companion <code>Publisher</code> to subscribe for buffer creation signals.</dd>
<dd><code>closeSelector</code> - a factory that, given a buffer opening signal, returns a companion
 <code>Publisher</code> to subscribe to for buffer closure and emission signals.</dd>
<dd><code>bufferSupplier</code> - a <code>Supplier</code> of the concrete <code>Collection</code> to use for each buffer</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>Collection</code> delimited by an opening <code>Publisher</code> and a relative
 closing <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="cache--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cache</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;cache()</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further <code>Subscriber</code>. Will
 retain an unbounded volume of onNext signals. Completion and Error will also be
 replayed.
 <p>
 <img class="marble" src="doc-files/marbles/cacheForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="cache-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cache</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;cache(int&nbsp;history)</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further <code>Subscriber</code>.
 Will retain up to the given history size onNext signals. Completion and Error will also be
 replayed.
 <p>
     Note that <code>cache(0)</code> will only cache the terminal signal without
     expiration.
 <p>
 <img class="marble" src="doc-files/marbles/cacheWithHistoryLimitForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>history</code> - number of elements retained in cache</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="cache-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cache</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;cache(java.time.Duration&nbsp;ttl)</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further
 <code>Subscriber</code>. Will retain an unbounded history but apply a per-item expiry timeout
 <p>
   Completion and Error will also be replayed until <code>ttl</code> triggers in which case
   the next <code>Subscriber</code> will start over a new subscription.
 <p>
 <img class="marble" src="doc-files/marbles/cacheWithTtlForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>ttl</code> - Time-to-live for each cached item and post termination.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="cache-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cache</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;cache(java.time.Duration&nbsp;ttl,
                           <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further
 <code>Subscriber</code>. Will retain an unbounded history but apply a per-item expiry timeout
 <p>
   Completion and Error will also be replayed until <code>ttl</code> triggers in which case
   the next <code>Subscriber</code> will start over a new subscription.
 <p>
 <img class="marble" src="doc-files/marbles/cacheWithTtlForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>ttl</code> - Time-to-live for each cached item and post termination.</dd>
<dd><code>timer</code> - the <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> on which to measure the duration.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="cache-int-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cache</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;cache(int&nbsp;history,
                           java.time.Duration&nbsp;ttl)</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further
 <code>Subscriber</code>. Will retain up to the given history size and apply a per-item expiry
 timeout.
 <p>
   Completion and Error will also be replayed until <code>ttl</code> triggers in which case
   the next <code>Subscriber</code> will start over a new subscription.
 <p>
 <img class="marble" src="doc-files/marbles/cacheWithTtlAndMaxLimitForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>history</code> - number of elements retained in cache</dd>
<dd><code>ttl</code> - Time-to-live for each cached item and post termination.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="cache-int-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cache</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;cache(int&nbsp;history,
                           java.time.Duration&nbsp;ttl,
                           <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further
 <code>Subscriber</code>. Will retain up to the given history size and apply a per-item expiry
 timeout.
 <p>
   Completion and Error will also be replayed until <code>ttl</code> triggers in which case
   the next <code>Subscriber</code> will start over a new subscription.
 <p>
 <img class="marble" src="doc-files/marbles/cacheWithTtlAndMaxLimitForFlux.svg"
 alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>history</code> - number of elements retained in cache</dd>
<dd><code>ttl</code> - Time-to-live for each cached item and post termination.</dd>
<dd><code>timer</code> - the <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> on which to measure the duration.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="cast-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cast</h4>
<pre>public final&nbsp;&lt;E&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;E&gt;&nbsp;cast(java.lang.Class&lt;E&gt;&nbsp;clazz)</pre>
<div class="block">Cast the current <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> produced type into a target produced type.

 <p>
 <img class="marble" src="doc-files/marbles/castForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>E</code> - the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> output type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>clazz</code> - the target class to cast to</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a casted <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="cancelOn-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cancelOn</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;cancelOn(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</pre>
<div class="block">Prepare this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> so that subscribers will cancel from it on a
 specified
 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/cancelOnForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>scheduler</code> - the <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> to signal cancel  on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a scheduled cancel <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="checkpoint--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkpoint</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;checkpoint()</pre>
<div class="block">Activate traceback (full assembly tracing) for this particular <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, in case of an error
 upstream of the checkpoint. Tracing incurs the cost of an exception stack trace
 creation.
 <p>
 It should be placed towards the end of the reactive chain, as errors
 triggered downstream of it cannot be observed and augmented with the traceback.
 <p>
 The traceback is attached to the error as a <code>suppressed exception</code>.
 As such, if the error is a <a href="../../../reactor/core/Exceptions.html#isMultiple-java.lang.Throwable-"><code>composite one</code></a>, the traceback
 would appear as a component of the composite. In any case, the traceback nature can be detected via
 <a href="../../../reactor/core/Exceptions.html#isTraceback-java.lang.Throwable-"><code>Exceptions.isTraceback(Throwable)</code></a>.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the assembly tracing <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</dd>
</dl>
</li>
</ul>
<a name="checkpoint-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkpoint</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;checkpoint(java.lang.String&nbsp;description)</pre>
<div class="block">Activate traceback (assembly marker) for this particular <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by giving it a description that
 will be reflected in the assembly traceback in case of an error upstream of the
 checkpoint. Note that unlike <a href="../../../reactor/core/publisher/Flux.html#checkpoint--"><code>checkpoint()</code></a>, this doesn't create a
 filled stack trace, avoiding the main cost of the operator.
 However, as a trade-off the description must be unique enough for the user to find
 out where this Flux was assembled. If you only want a generic description, and
 still rely on the stack trace to find the assembly site, use the
 <a href="../../../reactor/core/publisher/Flux.html#checkpoint-java.lang.String-boolean-"><code>checkpoint(String, boolean)</code></a> variant.
 <p>
 It should be placed towards the end of the reactive chain, as errors
 triggered downstream of it cannot be observed and augmented with assembly trace.
 <p>
 The traceback is attached to the error as a <code>suppressed exception</code>.
 As such, if the error is a <a href="../../../reactor/core/Exceptions.html#isMultiple-java.lang.Throwable-"><code>composite one</code></a>, the traceback
 would appear as a component of the composite. In any case, the traceback nature can be detected via
 <a href="../../../reactor/core/Exceptions.html#isTraceback-java.lang.Throwable-"><code>Exceptions.isTraceback(Throwable)</code></a>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>description</code> - a unique enough description to include in the light assembly traceback.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the assembly marked <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="checkpoint-java.lang.String-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkpoint</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;checkpoint(<a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                java.lang.String&nbsp;description,
                                boolean&nbsp;forceStackTrace)</pre>
<div class="block">Activate traceback (full assembly tracing or the lighter assembly marking depending on the
 <code>forceStackTrace</code> option).
 <p>
 By setting the <code>forceStackTrace</code> parameter to true, activate assembly
 tracing for this particular <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and give it a description that
 will be reflected in the assembly traceback in case of an error upstream of the
 checkpoint. Note that unlike <a href="../../../reactor/core/publisher/Flux.html#checkpoint-java.lang.String-"><code>checkpoint(String)</code></a>, this will incur
 the cost of an exception stack trace creation. The description could for
 example be a meaningful name for the assembled flux or a wider correlation ID,
 since the stack trace will always provide enough information to locate where this
 Flux was assembled.
 <p>
 By setting <code>forceStackTrace</code> to false, behaves like
 <a href="../../../reactor/core/publisher/Flux.html#checkpoint-java.lang.String-"><code>checkpoint(String)</code></a> and is subject to the same caveat in choosing the
 description.
 <p>
 It should be placed towards the end of the reactive chain, as errors
 triggered downstream of it cannot be observed and augmented with assembly marker.
 <p>
 The traceback is attached to the error as a <code>suppressed exception</code>.
 As such, if the error is a <a href="../../../reactor/core/Exceptions.html#isMultiple-java.lang.Throwable-"><code>composite one</code></a>, the traceback
 would appear as a component of the composite. In any case, the traceback nature can be detected via
 <a href="../../../reactor/core/Exceptions.html#isTraceback-java.lang.Throwable-"><code>Exceptions.isTraceback(Throwable)</code></a>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>description</code> - a description (must be unique enough if forceStackTrace is set
 to false).</dd>
<dd><code>forceStackTrace</code> - false to make a light checkpoint without a stacktrace, true
 to use a stack trace.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the assembly marked <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</dd>
</dl>
</li>
</ul>
<a name="collect-java.util.function.Supplier-java.util.function.BiConsumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collect</h4>
<pre>public final&nbsp;&lt;E&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;E&gt;&nbsp;collect(java.util.function.Supplier&lt;E&gt;&nbsp;containerSupplier,
                                 java.util.function.BiConsumer&lt;E,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;collector)</pre>
<div class="block">自定义收集
 <p>
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a user-defined container,
 by applying a collector <code>BiConsumer</code> taking the container and each element.
 The collected result will be emitted when this sequence completes, emitting the
 empty container if the sequence was empty.

 <p>
 <img class="marble" src="doc-files/marbles/collect.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the container upon cancellation or error triggered by a data signal.
 Either the container type is a <code>Collection</code> (in which case individual elements are discarded)
 or not (in which case the entire container is discarded). In case the collector <code>BiConsumer</code> fails
 to accumulate an element, the container is discarded as above and the triggering element is also discarded.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>E</code> - the container type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>containerSupplier</code> - the supplier of the container instance for each Subscriber, 收集操作, ArrayList<T>::add</dd>
<dd><code>collector</code> - a consumer of both the container instance and the value being currently collected, 容器, ArrayList<T>::new</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of the collected container on complete</dd>
</dl>
</li>
</ul>
<a name="collect-java.util.stream.Collector-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collect</h4>
<pre>public final&nbsp;&lt;R,A&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;R&gt;&nbsp;collect(java.util.stream.Collector&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,A,? extends R&gt;&nbsp;collector)</pre>
<div class="block">Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a container,
 by applying a Java 8 Stream API <code>Collector</code>
 The collected result will be emitted when this sequence completes, emitting
 the empty container if the sequence was empty.

 <p>
 <img class="marble" src="doc-files/marbles/collectWithCollector.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the intermediate container (see <code>Collector.supplier()</code>) upon
 cancellation, error or exception while applying the <code>Collector.finisher()</code>. Either the container type
 is a <code>Collection</code> (in which case individual elements are discarded) or not (in which case the entire
 container is discarded). In case the accumulator <code>BiConsumer</code> of the collector fails to accumulate
 an element into the intermediate container, the container is discarded as above and the triggering element
 is also discarded.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>A</code> - The mutable accumulation type</dd>
<dd><code>R</code> - the container type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>collector</code> - the <code>Collector</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of the collected container on complete</dd>
</dl>
</li>
</ul>
<a name="collectList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectList</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;collectList()</pre>
<div class="block">收集Flux发布的元素到List中
 <p>
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a <code>List</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>List</code> if the sequence was empty.

 <p>
 <img class="marble" src="doc-files/marbles/collectList.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the elements in the <code>List</code> upon
 cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of a <code>List</code> of all values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="collectMap-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectMap</h4>
<pre>public final&nbsp;&lt;K&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;collectMap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor)</pre>
<div class="block">收集Flux发布的元素到Map中，自定义Key,Value为原值.允许<a href="../../../reactor/core/publisher/Flux.html#empty--"><code>empty()</code></a>
 <p>
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hashed <code>Map</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>Map</code> if the sequence was empty.
 The key is extracted from each element by applying the <code>keyExtractor</code>
 <code>Function</code>. In case several elements map to the same key, the associated value
 will be the most recently emitted element.

 <p>
 <img class="marble" src="doc-files/marbles/collectMapWithKeyExtractor.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the whole <code>Map</code> upon cancellation or error
 triggered by a data signal, so discard handlers will have to unpack the map.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>K</code> - the type of the key extracted from each source element</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keyExtractor</code> - a <code>Function</code> to map elements to a key for the <code>Map</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of a <code>Map</code> of key-element pairs (only including latest
 element in case of key conflicts)</dd>
</dl>
</li>
</ul>
<a name="collectMap-java.util.function.Function-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectMap</h4>
<pre>public final&nbsp;&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,V&gt;&gt;&nbsp;collectMap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor,
                                                       java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueExtractor)</pre>
<div class="block">Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hashed <code>Map</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>Map</code> if the sequence was empty.
 The key is extracted from each element by applying the <code>keyExtractor</code>
 <code>Function</code>, and the value is extracted by the <code>valueExtractor</code> Function.
 In case several elements map to the same key, the associated value will be derived
 from the most recently emitted element.

 <p>
 <img class="marble" src="doc-files/marbles/collectMapWithKeyAndValueExtractors.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the whole <code>Map</code> upon cancellation or error
 triggered by a data signal, so discard handlers will have to unpack the map.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>K</code> - the type of the key extracted from each source element</dd>
<dd><code>V</code> - the type of the value extracted from each source element</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keyExtractor</code> - a <code>Function</code> to map elements to a key for the <code>Map</code></dd>
<dd><code>valueExtractor</code> - a <code>Function</code> to map elements to a value for the <code>Map</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of a <code>Map</code> of key-element pairs (only including latest
 element's value in case of key conflicts)</dd>
</dl>
</li>
</ul>
<a name="collectMap-java.util.function.Function-java.util.function.Function-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectMap</h4>
<pre>public final&nbsp;&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,V&gt;&gt;&nbsp;collectMap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor,
                                                       java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueExtractor,
                                                       java.util.function.Supplier&lt;java.util.Map&lt;K,V&gt;&gt;&nbsp;mapSupplier)</pre>
<div class="block">Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a user-defined <code>Map</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>Map</code> if the sequence was empty.
 The key is extracted from each element by applying the <code>keyExtractor</code>
 <code>Function</code>, and the value is extracted by the <code>valueExtractor</code> Function.
 In case several elements map to the same key, the associated value will be derived
 from the most recently emitted element.

 <p>
 <img class="marble" src="doc-files/marbles/collectMapWithKeyAndValueExtractors.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the whole <code>Map</code> upon cancellation or error
 triggered by a data signal, so discard handlers will have to unpack the map.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>K</code> - the type of the key extracted from each source element</dd>
<dd><code>V</code> - the type of the value extracted from each source element</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keyExtractor</code> - a <code>Function</code> to map elements to a key for the <code>Map</code></dd>
<dd><code>valueExtractor</code> - a <code>Function</code> to map elements to a value for the <code>Map</code></dd>
<dd><code>mapSupplier</code> - a <code>Map</code> factory called for each <code>Subscriber</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of a <code>Map</code> of key-value pairs (only including latest
 element's value in case of key conflicts)</dd>
</dl>
</li>
</ul>
<a name="collectMultimap-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectMultimap</h4>
<pre>public final&nbsp;&lt;K&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,java.util.Collection&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&gt;&nbsp;collectMultimap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor)</pre>
<div class="block">分组，类似Java Stream 的 groupBy，兼容 <a href="../../../reactor/core/publisher/Flux.html#empty--"><code>empty()</code></a>
 <p>
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a <code>multimap</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>multimap</code> if the sequence was empty.
 The key is extracted from each element by applying the <code>keyExtractor</code>
 <code>Function</code>, and every element mapping to the same key is stored in the <code>List</code>
 associated to said key.

 <p>
 <img class="marble" src="doc-files/marbles/collectMultiMapWithKeyExtractor.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the whole <code>Map</code> upon cancellation or error
 triggered by a data signal, so discard handlers will have to unpack the list values in the map.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>K</code> - the type of the key extracted from each source element</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keyExtractor</code> - a <code>Function</code> to map elements to a key for the <code>Map</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of a <code>Map</code> of key-List(elements) pairs</dd>
</dl>
</li>
</ul>
<a name="collectMultimap-java.util.function.Function-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectMultimap</h4>
<pre>public final&nbsp;&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;&nbsp;collectMultimap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor,
                                                                                  java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueExtractor)</pre>
<div class="block">Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a <code>multimap</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>multimap</code> if the sequence was empty.
 The key is extracted from each element by applying the <code>keyExtractor</code>
 <code>Function</code>, and every element mapping to the same key is converted by the
 <code>valueExtractor</code> Function to a value stored in the <code>List</code> associated to
 said key.

 <p>
 <img class="marble" src="doc-files/marbles/collectMultiMapWithKeyAndValueExtractors.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the whole <code>Map</code> upon cancellation or error
 triggered by a data signal, so discard handlers will have to unpack the list values in the map.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>K</code> - the type of the key extracted from each source element</dd>
<dd><code>V</code> - the type of the value extracted from each source element</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keyExtractor</code> - a <code>Function</code> to map elements to a key for the <code>Map</code></dd>
<dd><code>valueExtractor</code> - a <code>Function</code> to map elements to a value for the <code>Map</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of a <code>Map</code> of key-List(values) pairs</dd>
</dl>
</li>
</ul>
<a name="collectMultimap-java.util.function.Function-java.util.function.Function-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectMultimap</h4>
<pre>public final&nbsp;&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;&nbsp;collectMultimap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyExtractor,
                                                                                  java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueExtractor,
                                                                                  java.util.function.Supplier&lt;java.util.Map&lt;K,java.util.Collection&lt;V&gt;&gt;&gt;&nbsp;mapSupplier)</pre>
<div class="block">Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a user-defined <code>multimap</code> that is
 emitted by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> when this sequence completes, emitting the
 empty <code>multimap</code> if the sequence was empty.
 The key is extracted from each element by applying the <code>keyExtractor</code>
 <code>Function</code>, and every element mapping to the same key is converted by the
 <code>valueExtractor</code> Function to a value stored in the <code>Collection</code> associated to
 said key.

 <p>
 <img class="marble" src="doc-files/marbles/collectMultiMapWithKeyAndValueExtractors.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the whole <code>Map</code> upon cancellation or error
 triggered by a data signal, so discard handlers will have to unpack the list values in the map.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>K</code> - the type of the key extracted from each source element</dd>
<dd><code>V</code> - the type of the value extracted from each source element</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keyExtractor</code> - a <code>Function</code> to map elements to a key for the <code>Map</code></dd>
<dd><code>valueExtractor</code> - a <code>Function</code> to map elements to a value for the <code>Map</code></dd>
<dd><code>mapSupplier</code> - a multimap (<code>Map</code> of <code>Collection</code>) factory called
 for each <code>Subscriber</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of a <code>Map</code> of key-Collection(values) pairs</dd>
</dl>
</li>
</ul>
<a name="collectSortedList--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectSortedList</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;collectSortedList()</pre>
<div class="block">收集元素到集合并正序排序
 <p>
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until this sequence completes,
 and then sort them in natural order into a <code>List</code> that is emitted by the
 resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>. If the sequence was empty, empty <code>List</code> will be emitted.

 <p>
 <img class="marble" src="doc-files/marbles/collectSortedList.svg" alt="">

 <p><strong>Discard Support:</strong> This operator is based on <a href="../../../reactor/core/publisher/Flux.html#collectList--"><code>collectList()</code></a>, and as such discards the
 elements in the <code>List</code> individually upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of a sorted <code>List</code> of all values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, in natural order</dd>
</dl>
</li>
</ul>
<a name="collectSortedList-java.util.Comparator-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>collectSortedList</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.util.List&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;collectSortedList(<a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                                       java.util.Comparator&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;comparator)</pre>
<div class="block">收集元素到集合，自定义排序
 <p>
 Collect all elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until this sequence completes,
 and then sort them using a <code>Comparator</code> into a <code>List</code> that is emitted
 by the resulting <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>. If the sequence was empty, empty <code>List</code> will be emitted.

 <p>
 <img class="marble" src="doc-files/marbles/collectSortedListWithComparator.svg" alt="">

 <p><strong>Discard Support:</strong> This operator is based on <a href="../../../reactor/core/publisher/Flux.html#collectList--"><code>collectList()</code></a>, and as such discards the
 elements in the <code>List</code> individually upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>comparator</code> - a <code>Comparator</code> to sort the items of this sequences</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of a sorted <code>List</code> of all values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="concatMap-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatMap</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;concatMap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, sequentially and
 preserving order using concatenation.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap</code></a> and <a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-"><code>flatMapSequential</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator waits for one
     inner to complete before generating the next one and subscribing to it.</li>
     <li><b>Ordering of the flattened values</b>: this operator naturally preserves
     the same order as the source elements, concatenating the inners from each source
     element sequentially.</li>
     <li><b>Interleaving</b>: this operator does not let values from different inners
     interleave (concatenation).</li>
 </ul>

 <p>
 Errors will immediately short circuit current concat backlog.
 Note that no prefetching is done on the source, which gets requested only if there
 is downstream demand.

 <p>
 <img class="marble" src="doc-files/marbles/concatMap.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the produced concatenated type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the function to transform this sequence of T into concatenated sequences of V</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a concatenated <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="concatMap-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatMap</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;concatMap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
                                   int&nbsp;prefetch)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, sequentially and
 preserving order using concatenation.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap</code></a> and <a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-"><code>flatMapSequential</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator waits for one
     inner to complete before generating the next one and subscribing to it.</li>
     <li><b>Ordering of the flattened values</b>: this operator naturally preserves
     the same order as the source elements, concatenating the inners from each source
     element sequentially.</li>
     <li><b>Interleaving</b>: this operator does not let values from different inners
     interleave (concatenation).</li>
 </ul>

 <p>
 Errors will immediately short circuit current concat backlog. The prefetch argument
 allows to give an arbitrary prefetch size to the upstream source, or to disable
 prefetching with <code>0</code>.

 <p>
 <img class="marble" src="doc-files/marbles/concatMap.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the produced concatenated type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the function to transform this sequence of T into concatenated sequences of V</dd>
<dd><code>prefetch</code> - the number of values to prefetch from upstream source, or <code>0</code> to disable prefetching</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a concatenated <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="concatMapDelayError-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatMapDelayError</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;concatMapDelayError(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, sequentially and
 preserving order using concatenation.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap</code></a> and <a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-"><code>flatMapSequential</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator waits for one
     inner to complete before generating the next one and subscribing to it.</li>
     <li><b>Ordering of the flattened values</b>: this operator naturally preserves
     the same order as the source elements, concatenating the inners from each source
     element sequentially.</li>
     <li><b>Interleaving</b>: this operator does not let values from different inners
     interleave (concatenation).</li>
 </ul>

 <p>
 Errors in the individual publishers will be delayed at the end of the whole concat
 sequence (possibly getting combined into a <a href="../../../reactor/core/Exceptions.html#isMultiple-java.lang.Throwable-"><code>composite</code></a>)
 if several sources error.
 Note that no prefetching is done on the source, which gets requested only if there
 is downstream demand.

 <p>
 <img class="marble" src="doc-files/marbles/concatMap.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the produced concatenated type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the function to transform this sequence of T into concatenated sequences of V</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a concatenated <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="concatMapDelayError-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatMapDelayError</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;concatMapDelayError(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
                                             int&nbsp;prefetch)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, sequentially and
 preserving order using concatenation.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap</code></a> and <a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-"><code>flatMapSequential</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator waits for one
     inner to complete before generating the next one and subscribing to it.</li>
     <li><b>Ordering of the flattened values</b>: this operator naturally preserves
     the same order as the source elements, concatenating the inners from each source
     element sequentially.</li>
     <li><b>Interleaving</b>: this operator does not let values from different inners
     interleave (concatenation).</li>
 </ul>

 <p>
 Errors in the individual publishers will be delayed at the end of the whole concat
 sequence (possibly getting combined into a <a href="../../../reactor/core/Exceptions.html#isMultiple-java.lang.Throwable-"><code>composite</code></a>)
 if several sources error.
 The prefetch argument allows to give an arbitrary prefetch size to the upstream source,
 or to disable prefetching with <code>0</code>.

 <p>
 <img class="marble" src="doc-files/marbles/concatMap.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the produced concatenated type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the function to transform this sequence of T into concatenated sequences of V</dd>
<dd><code>prefetch</code> - the number of values to prefetch from upstream source, or <code>0</code> to disable prefetching</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a concatenated <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="concatMapDelayError-java.util.function.Function-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatMapDelayError</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;concatMapDelayError(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
                                             boolean&nbsp;delayUntilEnd,
                                             int&nbsp;prefetch)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, sequentially and
 preserving order using concatenation.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap</code></a> and <a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-"><code>flatMapSequential</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator waits for one
     inner to complete before generating the next one and subscribing to it.</li>
     <li><b>Ordering of the flattened values</b>: this operator naturally preserves
     the same order as the source elements, concatenating the inners from each source
     element sequentially.</li>
     <li><b>Interleaving</b>: this operator does not let values from different inners
     interleave (concatenation).</li>
 </ul>

 <p>
 Errors in the individual publishers will be delayed after the current concat
 backlog if delayUntilEnd is false or after all sources if delayUntilEnd is true.
 The prefetch argument allows to give an arbitrary prefetch size to the upstream source,
 or to disable prefetching with <code>0</code>.

 <p>
 <img class="marble" src="doc-files/marbles/concatMap.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the produced concatenated type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the function to transform this sequence of T into concatenated sequences of V</dd>
<dd><code>delayUntilEnd</code> - delay error until all sources have been consumed instead of
 after the current source</dd>
<dd><code>prefetch</code> - the number of values to prefetch from upstream source, or <code>0</code> to disable prefetching</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a concatenated <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="concatMapIterable-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatMapIterable</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;concatMapIterable(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <code>Iterable</code>, then flatten the elements from those by
 concatenating them into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>. For each iterable, <code>Iterable.iterator()</code> will be called
 at least once and at most twice.

 <p>
 <img class="marble" src="doc-files/marbles/concatMapIterable.svg" alt="">
 <p>
 This operator inspects each <code>Iterable</code>'s <code>Spliterator</code> to assess if the iteration
 can be guaranteed to be finite (see <a href="../../../reactor/core/publisher/Operators.html#onDiscardMultiple-java.util.Iterator-boolean-reactor.util.context.Context-"><code>Operators.onDiscardMultiple(Iterator, boolean, Context)</code></a>).
 Since the default Spliterator wraps the Iterator we can have two <code>Iterable.iterator()</code>
 calls per iterable. This second invocation is skipped on a <code>Collection</code> however, a type which is
 assumed to be always finite.
 <p>
 Note that unlike <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap(Function)</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap(Function)</code></a>, with Iterable there is
 no notion of eager vs lazy inner subscription. The content of the Iterables are all played sequentially.
 Thus <code>flatMapIterable</code> and <code>concatMapIterable</code> are equivalent offered as a discoverability
 improvement for users that explore the API with the concat vs flatMap expectation.

 <p><strong>Discard Support:</strong> Upon cancellation, this operator discards <code>T</code> elements it prefetched and, in
 some cases, attempts to discard remainder of the currently processed <code>Iterable</code> (if it can
 safely ensure the iterator is finite). Note that this means each <code>Iterable</code>'s <code>Iterable.iterator()</code>
 method could be invoked twice.

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 (including when fusion is enabled). Exceptions thrown by the consumer are passed to
 the <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>onErrorContinue(BiConsumer)</code></a> error consumer (the value consumer
 is not invoked, as the source element will be part of the sequence). The onNext
 signal is then propagated as normal.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N <code>Iterable</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a concatenation of the values from the Iterables obtained from each element in this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="concatMapIterable-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatMapIterable</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;concatMapIterable(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;mapper,
                                           int&nbsp;prefetch)</pre>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <code>Iterable</code>, then flatten the emissions from those by
 concatenating them into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.
 The prefetch argument allows to give an arbitrary prefetch size to the upstream source.
 For each iterable, <code>Iterable.iterator()</code> will be called at least once and at most twice.

 <p>
 <img class="marble" src="doc-files/marbles/concatMapIterable.svg" alt="">
 <p>
 This operator inspects each <code>Iterable</code>'s <code>Spliterator</code> to assess if the iteration
 can be guaranteed to be finite (see <a href="../../../reactor/core/publisher/Operators.html#onDiscardMultiple-java.util.Iterator-boolean-reactor.util.context.Context-"><code>Operators.onDiscardMultiple(Iterator, boolean, Context)</code></a>).
 Since the default Spliterator wraps the Iterator we can have two <code>Iterable.iterator()</code>
 calls per iterable. This second invocation is skipped on a <code>Collection</code> however, a type which is
 assumed to be always finite.
 <p>
 Note that unlike <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap(Function)</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap(Function)</code></a>, with Iterable there is
 no notion of eager vs lazy inner subscription. The content of the Iterables are all played sequentially.
 Thus <code>flatMapIterable</code> and <code>concatMapIterable</code> are equivalent offered as a discoverability
 improvement for users that explore the API with the concat vs flatMap expectation.

 <p><strong>Discard Support:</strong> Upon cancellation, this operator discards <code>T</code> elements it prefetched and, in
 some cases, attempts to discard remainder of the currently processed <code>Iterable</code> (if it can
 safely ensure the iterator is finite). Note that this means each <code>Iterable</code>'s <code>Iterable.iterator()</code>
 method could be invoked twice.

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 (including when fusion is enabled). Exceptions thrown by the consumer are passed to
 the <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>onErrorContinue(BiConsumer)</code></a> error consumer (the value consumer
 is not invoked, as the source element will be part of the sequence). The onNext
 signal is then propagated as normal.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N <code>Iterable</code></dd>
<dd><code>prefetch</code> - the number of values to request from the source upon subscription, to be transformed to <code>Iterable</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a concatenation of the values from the Iterables obtained from each element in this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="concatWith-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>concatWith</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;concatWith(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;other)</pre>
<div class="block">Concatenate emissions of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the provided <code>Publisher</code> (no interleave).
 <p>
 <img class="marble" src="doc-files/marbles/concatWithForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the <code>Publisher</code> sequence to concat after this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a concatenated <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="contextCapture--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contextCapture</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;contextCapture()</pre>
<div class="block">If <a href="https://github.com/micrometer-metrics/context-propagation">context-propagation library</a>
 is on the classpath, this is a convenience shortcut to capture thread local values during the
 subscription phase and put them in the <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> that is visible upstream of this operator.
 <p>
 As a result this operator should generally be used as close as possible to the end of
 the chain / subscription point.
 <p>
 If the <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a> visible upstream is not empty, a small subset of operators will automatically
 restore the context snapshot (<a href="../../../reactor/core/publisher/Flux.html#handle-java.util.function.BiConsumer-"><code>handle</code></a>, <a href="../../../reactor/core/publisher/Flux.html#tap-reactor.core.observability.SignalListenerFactory-"><code>tap</code></a>).
 If context-propagation is not available at runtime, this operator simply returns the current <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 instance.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> where context-propagation API has been used to capture entries and
 inject them into the <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#handle-java.util.function.BiConsumer-"><code>handle(BiConsumer)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#tap-reactor.core.observability.SignalListenerFactory-"><code>tap(SignalListenerFactory)</code></a></dd>
</dl>
</li>
</ul>
<a name="contextWrite-reactor.util.context.ContextView-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contextWrite</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;contextWrite(<a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口">ContextView</a>&nbsp;contextToAppend)</pre>
<div class="block">Enrich the <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> visible from downstream for the benefit of upstream
 operators, by making all values from the provided <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a> visible on top
 of pairs from downstream.
 <p>
 A <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> (and its <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a>) is tied to a given subscription
 and is read by querying the downstream <code>Subscriber</code>. <code>Subscriber</code> that
 don't enrich the context instead access their own downstream's context. As a result,
 this operator conceptually enriches a <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> coming from under it in the chain
 (downstream, by default an empty one) and makes the new enriched <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a>
 visible to operators above it in the chain.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>contextToAppend</code> - the <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a> to merge with the downstream <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a>,
 resulting in a new more complete <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> that will be visible from upstream.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a contextualized <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a></dd>
</dl>
</li>
</ul>
<a name="contextWrite-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contextWrite</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;contextWrite(java.util.function.Function&lt;<a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口">Context</a>,<a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口">Context</a>&gt;&nbsp;contextModifier)</pre>
<div class="block">Enrich the <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> visible from downstream for the benefit of upstream
 operators, by applying a <code>Function</code> to the downstream <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a>.
 <p>
 The <code>Function</code> takes a <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> for convenience, allowing to easily
 call <a href="../../../reactor/util/context/Context.html#put-java.lang.Object-java.lang.Object-"><code>write APIs</code></a> to return a new <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a>.
 <p>
 A <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> (and its <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a>) is tied to a given subscription
 and is read by querying the downstream <code>Subscriber</code>. <code>Subscriber</code> that
 don't enrich the context instead access their own downstream's context. As a result,
 this operator conceptually enriches a <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> coming from under it in the chain
 (downstream, by default an empty one) and makes the new enriched <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a>
 visible to operators above it in the chain.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>contextModifier</code> - the <code>Function</code> to apply to the downstream <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a>,
 resulting in a new more complete <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> that will be visible from upstream.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a contextualized <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a></dd>
</dl>
</li>
</ul>
<a name="count--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>count</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Long&gt;&nbsp;count()</pre>
<div class="block">统计元素个数，当观察到 onComplete 时返回统计数
 <p>
 Counts the number of values in this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.
 The count will be emitted when onComplete is observed.

 <p>
 <img class="marble" src="doc-files/marbles/count.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of <code>Long</code> count</dd>
</dl>
</li>
</ul>
<a name="defaultIfEmpty-java.lang.Object-">
<!--   -->
</a><a name="defaultIfEmpty-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defaultIfEmpty</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;defaultIfEmpty(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;defaultV)</pre>
<div class="block">Provide a default unique value if this sequence is completed without any data
 <p>
 <img class="marble" src="doc-files/marbles/defaultIfEmpty.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>defaultV</code> - the alternate value if this sequence is empty</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="delayElements-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delayElements</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;delayElements(java.time.Duration&nbsp;delay)</pre>
<div class="block">Delay each of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> elements (<code>Subscriber.onNext(T)</code> signals)
 by a given <code>Duration</code>. Signals are delayed and continue on the
 <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel</code></a> default Scheduler, but empty sequences or
 immediate error signals are not delayed.

 <p>
 <img class="marble" src="doc-files/marbles/delayElements.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>delay</code> - duration by which to delay each <code>Subscriber.onNext(T)</code> signal</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a delayed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#delaySubscription-java.time.Duration-"><code>delaySubscription to introduce a delay at the beginning of the sequence only</code></a></dd>
</dl>
</li>
</ul>
<a name="delayElements-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delayElements</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;delayElements(java.time.Duration&nbsp;delay,
                                   <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Delay each of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> elements (<code>Subscriber.onNext(T)</code> signals)
 by a given <code>Duration</code>. Signals are delayed and continue on a user-specified
 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>, but empty sequences or immediate error signals are not delayed.

 <p>
 <img class="marble" src="doc-files/marbles/delayElements.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>delay</code> - period to delay each <code>Subscriber.onNext(T)</code> signal</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to delay each signal on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a delayed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="delaySequence-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delaySequence</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;delaySequence(java.time.Duration&nbsp;delay)</pre>
<div class="block">Shift this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> forward in time by a given <code>Duration</code>.
 Unlike with <a href="../../../reactor/core/publisher/Flux.html#delayElements-java.time.Duration-"><code>delayElements(Duration)</code></a>, elements are shifted forward in time
 as they are emitted, always resulting in the delay between two elements being
 the same as in the source (only the first element is visibly delayed from the
 previous event, that is the subscription).
 Signals are delayed and continue on the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel</code></a>
 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>, but empty sequences or immediate error signals are not delayed.
 <p>
 With this operator, a source emitting at 10Hz with a delaySequence <code>Duration</code>
 of 1s will still emit at 10Hz, with an initial "hiccup" of 1s.
 On the other hand, <a href="../../../reactor/core/publisher/Flux.html#delayElements-java.time.Duration-"><code>delayElements(Duration)</code></a> would end up emitting
 at 1Hz.
 <p>
 This is closer to <a href="../../../reactor/core/publisher/Flux.html#delaySubscription-java.time.Duration-"><code>delaySubscription(Duration)</code></a>, except the source
 is subscribed to immediately.

 <p>
 <img class="marble" src="doc-files/marbles/delaySequence.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements currently being delayed
         * if the sequence is cancelled during the delay.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>delay</code> - <code>Duration</code> to shift the sequence by</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a shifted <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitting at the same frequency as the source</dd>
</dl>
</li>
</ul>
<a name="delaySequence-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delaySequence</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;delaySequence(java.time.Duration&nbsp;delay,
                                   <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Shift this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> forward in time by a given <code>Duration</code>.
 Unlike with <a href="../../../reactor/core/publisher/Flux.html#delayElements-java.time.Duration-reactor.core.scheduler.Scheduler-"><code>delayElements(Duration, Scheduler)</code></a>, elements are shifted forward in time
 as they are emitted, always resulting in the delay between two elements being
 the same as in the source (only the first element is visibly delayed from the
 previous event, that is the subscription).
 Signals are delayed and continue on a user-specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>, but empty
 sequences or immediate error signals are not delayed.
 <p>
 With this operator, a source emitting at 10Hz with a delaySequence <code>Duration</code>
 of 1s will still emit at 10Hz, with an initial "hiccup" of 1s.
 On the other hand, <a href="../../../reactor/core/publisher/Flux.html#delayElements-java.time.Duration-reactor.core.scheduler.Scheduler-"><code>delayElements(Duration, Scheduler)</code></a> would end up emitting
 at 1Hz.
 <p>
 This is closer to <a href="../../../reactor/core/publisher/Flux.html#delaySubscription-java.time.Duration-reactor.core.scheduler.Scheduler-"><code>delaySubscription(Duration, Scheduler)</code></a>, except the source
 is subscribed to immediately.

 <p>
 <img class="marble" src="doc-files/marbles/delaySequence.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements currently being delayed
 if the sequence is cancelled during the delay.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>delay</code> - <code>Duration</code> to shift the sequence by</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to delay signals on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a shifted <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitting at the same frequency as the source</dd>
</dl>
</li>
</ul>
<a name="delayUntil-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delayUntil</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;delayUntil(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;triggerProvider)</pre>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and generate a <code>Publisher</code> from each of this
 Flux elements, each acting as a trigger for relaying said element.
 <p>
 That is to say, the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> delays each of its emission until the
 associated trigger Publisher terminates.
 <p>
 In case of an error either in the source or in a trigger, that error is propagated
 immediately downstream.
 Note that unlike with the <a href="../../../reactor/core/publisher/Mono.html#delayUntil-java.util.function.Function-"><code>Mono variant</code></a> there is
 no fusion of subsequent calls.
 <p>
 <img class="marble" src="doc-files/marbles/delayUntilForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>triggerProvider</code> - a <code>Function</code> that maps each element into a
 <code>Publisher</code> whose termination will trigger relaying the value.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>this Flux, but with elements delayed until their derived publisher terminates.</dd>
</dl>
</li>
</ul>
<a name="delaySubscription-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delaySubscription</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;delaySubscription(java.time.Duration&nbsp;delay)</pre>
<div class="block">Delay the <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscription</code></a> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> source until the given
 period elapses. The delay is introduced through the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel</code></a> default Scheduler.

 <p>
 <img class="marble" src="doc-files/marbles/delaySubscriptionForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>delay</code> - duration before subscribing this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a delayed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="delaySubscription-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delaySubscription</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;delaySubscription(java.time.Duration&nbsp;delay,
                                       <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Delay the <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscription</code></a> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> source until the given
 period elapses, as measured on the user-provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/delaySubscriptionForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>delay</code> - <code>Duration</code> before subscribing this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a delayed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="delaySubscription-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>delaySubscription</h4>
<pre>public final&nbsp;&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;delaySubscription(org.reactivestreams.Publisher&lt;U&gt;&nbsp;subscriptionDelay)</pre>
<div class="block">Delay the <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscription</code></a> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 source until another <code>Publisher</code> signals a value or completes.

 <p>
 <img class="marble" src="doc-files/marbles/delaySubscriptionWithPublisherForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the other source type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>subscriptionDelay</code> - a companion <code>Publisher</code> whose onNext/onComplete signal will trigger the <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscription</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a delayed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="dematerialize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dematerialize</h4>
<pre>public final&nbsp;&lt;X&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;X&gt;&nbsp;dematerialize()</pre>
<div class="block">An operator working only if this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emits onNext, onError or onComplete <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a>
 instances, transforming these <a href="../../../reactor/core/publisher/Flux.html#materialize--"><code>materialized</code></a> signals into
 real signals on the <code>Subscriber</code>.
 The error <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a> will trigger onError and complete <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a> will trigger
 onComplete.

 <p>
 <img class="marble" src="doc-files/marbles/dematerializeForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>X</code> - the dematerialized type</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a dematerialized <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#materialize--"><code>materialize()</code></a></dd>
</dl>
</li>
</ul>
<a name="distinct--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distinct</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;distinct()</pre>
<div class="block">For each <code>Subscriber</code>, track elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that have been
 seen and filter out duplicates.
 <p>
 The values themselves are recorded into a <code>HashSet</code> for distinct detection.
 Use <code>distinct(Object::hashcode)</code> if you want a more lightweight approach that
 doesn't retain all the objects, but is more susceptible to falsely considering two
 elements as distinct due to a hashcode collision.

 <p>
 <img class="marble" src="doc-files/marbles/distinct.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that don't match the distinct predicate,
 but you should use the version with a cleanup if you need discarding of keys
 categorized by the operator as "seen". See <a href="../../../reactor/core/publisher/Flux.html#distinct-java.util.function.Function-java.util.function.Supplier-java.util.function.BiPredicate-java.util.function.Consumer-"><code>distinct(Function, Supplier, BiPredicate, Consumer)</code></a>.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a filtering <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> only emitting distinct values</dd>
</dl>
</li>
</ul>
<a name="distinct-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distinct</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;distinct(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector)</pre>
<div class="block">For each <code>Subscriber</code>, track elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that have been
 seen and filter out duplicates, as compared by a key extracted through the user
 provided <code>Function</code>.

 <p>
 <img class="marble" src="doc-files/marbles/distinctWithKey.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that don't match the distinct predicate,
 but you should use the version with a cleanup if you need discarding of keys
 categorized by the operator as "seen". See <a href="../../../reactor/core/publisher/Flux.html#distinct-java.util.function.Function-java.util.function.Supplier-java.util.function.BiPredicate-java.util.function.Consumer-"><code>distinct(Function, Supplier, BiPredicate, Consumer)</code></a>.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the type of the key extracted from each value in this sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keySelector</code> - function to compute comparison key for each element</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a filtering <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> only emitting values with distinct keys</dd>
</dl>
</li>
</ul>
<a name="distinct-java.util.function.Function-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distinct</h4>
<pre>public final&nbsp;&lt;V,C extends java.util.Collection&lt;? super V&gt;&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;distinct(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector,
                                                                            java.util.function.Supplier&lt;C&gt;&nbsp;distinctCollectionSupplier)</pre>
<div class="block">For each <code>Subscriber</code>, track elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that have been
 seen and filter out duplicates, as compared by a key extracted through the user
 provided <code>Function</code> and by the <code>add method</code>
 of the <code>Collection</code> supplied (typically a <code>Set</code>).

 <p>
 <img class="marble" src="doc-files/marbles/distinctWithKey.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that don't match the distinct predicate,
 but you should use the version with a cleanup if you need discarding of keys
 categorized by the operator as "seen". See <a href="../../../reactor/core/publisher/Flux.html#distinct-java.util.function.Function-java.util.function.Supplier-java.util.function.BiPredicate-java.util.function.Consumer-"><code>distinct(Function, Supplier, BiPredicate, Consumer)</code></a>.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the type of the key extracted from each value in this sequence</dd>
<dd><code>C</code> - the type of Collection used for distinct checking of keys</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keySelector</code> - function to compute comparison key for each element</dd>
<dd><code>distinctCollectionSupplier</code> - supplier of the <code>Collection</code> used for distinct
 check through <code>add</code> of the key.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a filtering <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> only emitting values with distinct keys</dd>
</dl>
</li>
</ul>
<a name="distinct-java.util.function.Function-java.util.function.Supplier-java.util.function.BiPredicate-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distinct</h4>
<pre>public final&nbsp;&lt;V,C&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;distinct(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector,
                                    java.util.function.Supplier&lt;C&gt;&nbsp;distinctStoreSupplier,
                                    java.util.function.BiPredicate&lt;C,V&gt;&nbsp;distinctPredicate,
                                    java.util.function.Consumer&lt;C&gt;&nbsp;cleanup)</pre>
<div class="block">For each <code>Subscriber</code>, track elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that have been
 seen and filter out duplicates, as compared by applying a <code>BiPredicate</code> on
 an arbitrary user-supplied <code>&lt;C&gt;</code> store and a key extracted through the user
 provided <code>Function</code>. The BiPredicate should typically add the key to the
 arbitrary store for further comparison. A cleanup callback is also invoked on the
 store upon termination of the sequence.

 <p>
 <img class="marble" src="doc-files/marbles/distinctWithKey.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that don't match the distinct predicate,
 but you should use the <code>cleanup</code> as well if you need discarding of keys
 categorized by the operator as "seen".</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the type of the key extracted from each value in this sequence</dd>
<dd><code>C</code> - the type of store backing the <code>BiPredicate</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keySelector</code> - function to compute comparison key for each element</dd>
<dd><code>distinctStoreSupplier</code> - supplier of the arbitrary store object used in distinct
 checks along the extracted key.</dd>
<dd><code>distinctPredicate</code> - the <code>BiPredicate</code> to apply to the arbitrary store +
 extracted key to perform a distinct check. Since nothing is assumed of the store,
 this predicate should also add the key to the store as necessary.</dd>
<dd><code>cleanup</code> - the cleanup callback to invoke on the store upon termination.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a filtering <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> only emitting values with distinct keys</dd>
</dl>
</li>
</ul>
<a name="distinctUntilChanged--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distinctUntilChanged</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;distinctUntilChanged()</pre>
<div class="block">Filter out subsequent repetitions of an element (that is, if they arrive right after
 one another).

 <p>
 <img class="marble" src="doc-files/marbles/distinctUntilChanged.svg" alt="">
 <p>
 The last distinct value seen is retained for further comparison, which is done
 on the values themselves using <code>the equals method</code>.
 Use <code>distinctUntilChanged(Object::hashcode)</code> if you want a more lightweight approach that
 doesn't retain all the objects, but is more susceptible to falsely considering two
 elements as distinct due to a hashcode collision.

 <p><strong>Discard Support:</strong> Although this operator discards elements that are considered as "already seen",
 it is not recommended for cases where discarding is needed as the operator doesn't
 discard the "key" (in this context, the distinct instance that was last seen).</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a filtering <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with only one occurrence in a row of each element
 (yet elements can repeat in the overall sequence)</dd>
</dl>
</li>
</ul>
<a name="distinctUntilChanged-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distinctUntilChanged</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;distinctUntilChanged(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector)</pre>
<div class="block">Filter out subsequent repetitions of an element (that is, if they arrive right after
 one another), as compared by a key extracted through the user provided <code>Function</code>
 using equality.

 <p>
 <img class="marble" src="doc-files/marbles/distinctUntilChangedWithKey.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are considered as "already seen".
 The keys themselves are not discarded.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the type of the key extracted from each value in this sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keySelector</code> - function to compute comparison key for each element</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a filtering <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with only one occurrence in a row of each element of
 the same key (yet element keys can repeat in the overall sequence)</dd>
</dl>
</li>
</ul>
<a name="distinctUntilChanged-java.util.function.Function-java.util.function.BiPredicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distinctUntilChanged</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;distinctUntilChanged(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector,
                                              java.util.function.BiPredicate&lt;? super V,? super V&gt;&nbsp;keyComparator)</pre>
<div class="block">Filter out subsequent repetitions of an element (that is, if they arrive right
 after one another), as compared by a key extracted through the user provided <code>Function</code> and then comparing keys with the supplied <code>BiPredicate</code>.
 <p>
 <img class="marble" src="doc-files/marbles/distinctUntilChangedWithKey.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are considered as "already seen"
 (for which the <code>keyComparator</code> returns true). The keys themselves
 are not discarded.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the type of the key extracted from each value in this sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keySelector</code> - function to compute comparison key for each element</dd>
<dd><code>keyComparator</code> - predicate used to compare keys.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a filtering <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with only one occurrence in a row of each element
 of the same key for which the predicate returns true (yet element keys can repeat
 in the overall sequence)</dd>
</dl>
</li>
</ul>
<a name="doAfterTerminate-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doAfterTerminate</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doAfterTerminate(java.lang.Runnable&nbsp;afterTerminate)</pre>
<div class="block">Add behavior (side-effect) triggered after the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> terminates, either by completing downstream successfully or with an error.
 <p>
 <img class="marble" src="doc-files/marbles/doAfterTerminateForFlux.svg" alt="">
 <p>
 The relevant signal is propagated downstream, then the <code>Runnable</code> is executed.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>afterTerminate</code> - the callback to call after <code>Subscriber.onComplete()</code> or <code>Subscriber.onError(java.lang.Throwable)</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed  <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="doOnCancel-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doOnCancel</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doOnCancel(java.lang.Runnable&nbsp;onCancel)</pre>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is cancelled.
 <p>
 <img class="marble" src="doc-files/marbles/doOnCancelForFlux.svg" alt="">
 <p>
 The handler is executed first, then the cancel signal is propagated upstream
 to the source.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>onCancel</code> - the callback to call on <code>Subscription.cancel()</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed  <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="doOnComplete-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doOnComplete</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doOnComplete(java.lang.Runnable&nbsp;onComplete)</pre>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes successfully.
 <p>
 <img class="marble" src="doc-files/marbles/doOnComplete.svg" alt="">
 <p>
 The <code>Runnable</code> is executed first, then the onComplete signal is propagated
 downstream.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>onComplete</code> - the callback to call on <code>Subscriber.onComplete()</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed  <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="doOnDiscard-java.lang.Class-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doOnDiscard</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doOnDiscard(java.lang.Class&lt;R&gt;&nbsp;type,
                                     java.util.function.Consumer&lt;? super R&gt;&nbsp;discardHook)</pre>
<div class="block">Potentially modify the behavior of the <i>whole chain</i> of operators upstream of this one to
 conditionally clean up elements that get <i>discarded</i> by these operators.
 <p>
 The <code>discardHook</code> MUST be idempotent and safe to use on any instance of the desired
 type.
 Calls to this method are additive, and the order of invocation of the <code>discardHook</code>
 is the same as the order of declaration (calling <code>.filter(...).doOnDiscard(first).doOnDiscard(second)</code>
 will let the filter invoke <code>first</code> then <code>second</code> handlers).
 <p>
 Two main categories of discarding operators exist:
 <ul>
     <li>filtering operators, dropping some source elements as part of their designed behavior</li>
     <li>operators that prefetch a few elements and keep them around pending a request, but get cancelled/in error</li>
 </ul>
 WARNING: Not all operators support this instruction. The ones that do are identified in the javadoc by
 the presence of a <strong>Discard Support</strong> section.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>type</code> - the <code>Class</code> of elements in the upstream chain of operators that
 this cleanup hook should take into account.</dd>
<dd><code>discardHook</code> - a <code>Consumer</code> of elements in the upstream chain of operators
 that performs the cleanup.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that cleans up matching elements that get discarded upstream of it.</dd>
</dl>
</li>
</ul>
<a name="doOnEach-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doOnEach</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doOnEach(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口">Signal</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;signalConsumer)</pre>
<div class="block">Add behavior (side-effects) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emits an item, fails with an error
 or completes successfully. All these events are represented as a <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a>
 that is passed to the side-effect callback. Note that this is an advanced operator,
 typically used for monitoring of a Flux. These <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a> have a <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a>
 associated to them.
 <p>
 <img class="marble" src="doc-files/marbles/doOnEachForFlux.svg" alt="">
 <p>
 The <code>Consumer</code> is executed first, then the relevant signal is propagated
 downstream.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>signalConsumer</code> - the mandatory callback to call on
   <code>Subscriber.onNext(Object)</code>, <code>Subscriber.onError(Throwable)</code> and
   <code>Subscriber.onComplete()</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-"><code>doOnNext(Consumer)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-"><code>doOnError(Consumer)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#doOnComplete-java.lang.Runnable-"><code>doOnComplete(Runnable)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#materialize--"><code>materialize()</code></a>, 
<a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a></dd>
</dl>
</li>
</ul>
<a name="doOnError-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doOnError</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doOnError(java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes with an error.
 <p>
 <img class="marble" src="doc-files/marbles/doOnErrorForFlux.svg" alt="">
 <p>
 The <code>Consumer</code> is executed first, then the onError signal is propagated
 downstream.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>onError</code> - the callback to call on <code>Subscriber.onError(java.lang.Throwable)</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed  <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="doOnError-java.lang.Class-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doOnError</h4>
<pre>public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doOnError(java.lang.Class&lt;E&gt;&nbsp;exceptionType,
                                                               java.util.function.Consumer&lt;? super E&gt;&nbsp;onError)</pre>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes with an error matching the given exception type.
 <p>
 <img class="marble" src="doc-files/marbles/doOnErrorWithClassPredicateForFlux.svg" alt="">
 <p>
 The <code>Consumer</code> is executed first, then the onError signal is propagated
 downstream.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>E</code> - type of the error to handle</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>exceptionType</code> - the type of exceptions to handle</dd>
<dd><code>onError</code> - the error handler for each error</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed  <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="doOnError-java.util.function.Predicate-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doOnError</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doOnError(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                               java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;onError)</pre>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes with an error matching the given exception.
 <p>
 <img class="marble" src="doc-files/marbles/doOnErrorWithPredicateForFlux.svg" alt="">
 <p>
 The <code>Consumer</code> is executed first, then the onError signal is propagated
 downstream.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>predicate</code> - the matcher for exceptions to handle</dd>
<dd><code>onError</code> - the error handler for each error</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed  <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="doOnNext-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doOnNext</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doOnNext(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onNext)</pre>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emits an item.
 <p>
 <img class="marble" src="doc-files/marbles/doOnNextForFlux.svg" alt="">
 <p>
 The <code>Consumer</code> is executed first, then the onNext signal is propagated
 downstream.

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 (including when fusion is enabled). Exceptions thrown by the consumer are passed to
 the <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>onErrorContinue(BiConsumer)</code></a> error consumer (the value consumer
 is not invoked, as the source element will be part of the sequence). The onNext
 signal is then propagated as normal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>onNext</code> - the callback to call on <code>Subscriber.onNext(T)</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed  <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="doOnRequest-java.util.function.LongConsumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doOnRequest</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doOnRequest(java.util.function.LongConsumer&nbsp;consumer)</pre>
<div class="block">Add behavior (side-effect) triggering a <code>LongConsumer</code> when this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 receives any request.
 <p>
     Note that non fatal error raised in the callback will not be propagated and
     will simply trigger <a href="../../../reactor/core/publisher/Operators.html#onOperatorError-java.lang.Throwable-reactor.util.context.Context-"><code>Operators.onOperatorError(Throwable, Context)</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/doOnRequestForFlux.svg" alt="">
 <p>
 The <code>LongConsumer</code> is executed first, then the request signal is propagated
 upstream to the parent.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>consumer</code> - the consumer to invoke on each request</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed  <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="doOnSubscribe-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doOnSubscribe</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doOnSubscribe(java.util.function.Consumer&lt;? super org.reactivestreams.Subscription&gt;&nbsp;onSubscribe)</pre>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is being subscribed,
 that is to say when a <code>Subscription</code> has been produced by the <code>Publisher</code>
 and is being passed to the <code>Subscriber.onSubscribe(Subscription)</code>.
 <p>
 This method is <strong>not</strong> intended for capturing the subscription and calling its methods,
 but for side effects like monitoring. For instance, the correct way to cancel a subscription is
 to call <a href="../../../reactor/core/Disposable.html#dispose--"><code>Disposable.dispose()</code></a> on the Disposable returned by <a href="../../../reactor/core/publisher/Flux.html#subscribe--"><code>subscribe()</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/doOnSubscribe.svg" alt="">
 <p>
 The <code>Consumer</code> is executed first, then the <code>Subscription</code> is propagated
 downstream to the next subscriber in the chain that is being established.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>onSubscribe</code> - the callback to call on <code>Subscriber.onSubscribe(org.reactivestreams.Subscription)</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed  <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#doFirst-java.lang.Runnable-"><code>doFirst(Runnable)</code></a></dd>
</dl>
</li>
</ul>
<a name="doOnTerminate-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doOnTerminate</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doOnTerminate(java.lang.Runnable&nbsp;onTerminate)</pre>
<div class="block">Add behavior (side-effect) triggered when the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> terminates, either by
 completing successfully or failing with an error.
 <p>
 <img class="marble" src="doc-files/marbles/doOnTerminateForFlux.svg" alt="">
 <p>
 The <code>Runnable</code> is executed first, then the onComplete/onError signal is propagated
 downstream.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>onTerminate</code> - the callback to call on <code>Subscriber.onComplete()</code> or <code>Subscriber.onError(java.lang.Throwable)</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed  <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="doFirst-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doFirst</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doFirst(java.lang.Runnable&nbsp;onFirst)</pre>
<div class="block">Add behavior (side-effect) triggered <strong>before</strong> the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is
 <strong>subscribed to</strong>, which should be the first event after assembly time.
 <p>
 <img class="marble" src="doc-files/marbles/doFirstForFlux.svg" alt="">
 <p>
 Note that when several <a href="../../../reactor/core/publisher/Flux.html#doFirst-java.lang.Runnable-"><code>doFirst(Runnable)</code></a> operators are used anywhere in a
 chain of operators, their order of execution is reversed compared to the declaration
 order (as subscribe signal flows backward, from the ultimate subscriber to the source
 publisher):
 <pre><code>
 Flux.just(1, 2)
     .doFirst(() -> System.out.println("three"))
     .doFirst(() -> System.out.println("two"))
     .doFirst(() -> System.out.println("one"));
 //would print one two three
 </code>
 </pre>
 <p>
 In case the <code>Runnable</code> throws an exception, said exception will be directly
 propagated to the subscribing <code>Subscriber</code> along with a no-op <code>Subscription</code>,
 similarly to what <a href="../../../reactor/core/publisher/Flux.html#error-java.lang.Throwable-"><code>error(Throwable)</code></a> does. Otherwise, after the handler has
 executed, the <code>Subscriber</code> is directly subscribed to the original source
 <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> (<code>this</code>).
 <p>
 This side-effect method provides stronger <i>first</i> guarantees compared to
 <a href="../../../reactor/core/publisher/Flux.html#doOnSubscribe-java.util.function.Consumer-"><code>doOnSubscribe(Consumer)</code></a>, which is triggered once the <code>Subscription</code>
 has been set up and passed to the <code>Subscriber</code>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>onFirst</code> - the callback to execute before the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is subscribed to</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="doFinally-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doFinally</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;doFinally(java.util.function.Consumer&lt;<a href="../../../reactor/core/publisher/SignalType.html" title="reactor.core.publisher中的枚举">SignalType</a>&gt;&nbsp;onFinally)</pre>
<div class="block">Add behavior (side-effect) triggered <strong>after</strong> the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> terminates for any reason,
 including cancellation. The terminating event (<a href="../../../reactor/core/publisher/SignalType.html#ON_COMPLETE"><code>SignalType.ON_COMPLETE</code></a>,
 <a href="../../../reactor/core/publisher/SignalType.html#ON_ERROR"><code>SignalType.ON_ERROR</code></a> and <a href="../../../reactor/core/publisher/SignalType.html#CANCEL"><code>SignalType.CANCEL</code></a>) is passed to the consumer,
 which is executed after the signal has been passed downstream.
 <p>
 Note that the fact that the signal is propagated downstream before the callback is
 executed means that several doFinally in a row will be executed in
 <strong>reverse order</strong>. If you want to assert the execution of the callback
 please keep in mind that the Flux will complete before it is executed, so its
 effect might not be visible immediately after eg. a <a href="../../../reactor/core/publisher/Flux.html#blockLast--"><code>blockLast()</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/doFinallyForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>onFinally</code> - the callback to execute after a terminal signal (complete, error
 or cancel)</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an observed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="elapsed--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elapsed</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;java.lang.Long,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;elapsed()</pre>
<div class="block">Map this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2&lt;Long, T&gt;</code></a>
 of timemillis and source data. The timemillis corresponds to the elapsed time
 between each signal as measured by the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel</code></a> scheduler.
 First duration is measured between the subscription and the first element.

 <p>
 <img class="marble" src="doc-files/marbles/elapsedForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits a tuple of time elapsed in milliseconds and matching data</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#timed--"><code>timed()</code></a>, 
<a href="../../../reactor/core/publisher/Timed.html#elapsed--"><code>Timed.elapsed()</code></a></dd>
</dl>
</li>
</ul>
<a name="elapsed-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elapsed</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;java.lang.Long,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;elapsed(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</pre>
<div class="block">Map this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2&lt;Long, T&gt;</code></a>
 of timemillis and source data. The timemillis corresponds to the elapsed time
 between each signal as measured by the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.
 First duration is measured between the subscription and the first element.
 <p>
 <img class="marble" src="doc-files/marbles/elapsedForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>scheduler</code> - a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to <a href="../../../reactor/core/scheduler/Scheduler.html#now-java.util.concurrent.TimeUnit-"><code>read time from</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits tuples of time elapsed in milliseconds and matching data</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#timed-reactor.core.scheduler.Scheduler-"><code>timed(Scheduler)</code></a>, 
<a href="../../../reactor/core/publisher/Timed.html#elapsed--"><code>Timed.elapsed()</code></a></dd>
</dl>
</li>
</ul>
<a name="elementAt-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementAt</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;elementAt(int&nbsp;index)</pre>
<div class="block">丢弃操作，丢弃指定下标之前的元素并返回指定下标的元素
 <p>
 Emit only the element at the given index position or <code>IndexOutOfBoundsException</code>
 if the sequence is shorter.

 <p>
 <img class="marble" src="doc-files/marbles/elementAt.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that appear before the requested index.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>index</code> - zero-based index of the only item to emit</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of the item at the specified zero-based index</dd>
</dl>
</li>
</ul>
<a name="elementAt-int-java.lang.Object-">
<!--   -->
</a><a name="elementAt-int-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>elementAt</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;elementAt(int&nbsp;index,
                               <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;defaultValue)</pre>
<div class="block">Emit only the element at the given index position or fall back to a
 default value if the sequence is shorter.

 <p>
 <img class="marble" src="doc-files/marbles/elementAtWithDefault.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that appear before the requested index.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>index</code> - zero-based index of the only item to emit</dd>
<dd><code>defaultValue</code> - a default value to emit if the sequence is shorter</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> of the item at the specified zero-based index or a default value</dd>
</dl>
</li>
</ul>
<a name="expandDeep-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>expandDeep</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;expandDeep(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;expander,
                                int&nbsp;capacityHint)</pre>
<div class="block">Recursively expand elements into a graph and emit all the resulting element,
 in a depth-first traversal order.
 <p>
 That is: emit one value from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, expand it and emit the first value
 at this first level of recursion, and so on... When no more recursion is possible,
 backtrack to the previous level and re-apply the strategy.
 <p>
 For example, given the hierarchical structure
 <pre>
  A
   - AA
     - aa1
  B
   - BB
     - bb1
 </pre>

 Expands <code>Flux.just(A, B)</code> into
 <pre>
  A
  AA
  aa1
  B
  BB
  bb1
 </pre></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>expander</code> - the <code>Function</code> applied at each level of recursion to expand
 values into a <code>Publisher</code>, producing a graph.</dd>
<dd><code>capacityHint</code> - a capacity hint to prepare the inner queues to accommodate n
 elements per level of recursion.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> expanded depth-first</dd>
</dl>
</li>
</ul>
<a name="expandDeep-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>expandDeep</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;expandDeep(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;expander)</pre>
<div class="block">Recursively expand elements into a graph and emit all the resulting element,
 in a depth-first traversal order.
 <p>
 That is: emit one value from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, expand it and emit the first value
 at this first level of recursion, and so on... When no more recursion is possible,
 backtrack to the previous level and re-apply the strategy.
 <p>
 For example, given the hierarchical structure
 <pre>
  A
   - AA
     - aa1
  B
   - BB
     - bb1
 </pre>

 Expands <code>Flux.just(A, B)</code> into
 <pre>
  A
  AA
  aa1
  B
  BB
  bb1
 </pre></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>expander</code> - the <code>Function</code> applied at each level of recursion to expand
 values into a <code>Publisher</code>, producing a graph.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> expanded depth-first</dd>
</dl>
</li>
</ul>
<a name="expand-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>expand</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;expand(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;expander,
                            int&nbsp;capacityHint)</pre>
<div class="block">Recursively expand elements into a graph and emit all the resulting element using
 a breadth-first traversal strategy.
 <p>
 That is: emit the values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> first, then expand each at a first level of
 recursion and emit all of the resulting values, then expand all of these at a second
 level and so on.
 <p>
 For example, given the hierarchical structure
 <pre>
  A
   - AA
     - aa1
  B
   - BB
     - bb1
 </pre>

 Expands <code>Flux.just(A, B)</code> into
 <pre>
  A
  B
  AA
  BB
  aa1
  bb1
 </pre></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>expander</code> - the <code>Function</code> applied at each level of recursion to expand
 values into a <code>Publisher</code>, producing a graph.</dd>
<dd><code>capacityHint</code> - a capacity hint to prepare the inner queues to accommodate n
 elements per level of recursion.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a breadth-first expanded <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="expand-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>expand</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;expand(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;expander)</pre>
<div class="block">Recursively expand elements into a graph and emit all the resulting element using
 a breadth-first traversal strategy.
 <p>
 That is: emit the values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> first, then expand each at a first level of
 recursion and emit all of the resulting values, then expand all of these at a second
 level and so on..
 <p>
 For example, given the hierarchical structure
 <pre>
  A
   - AA
     - aa1
  B
   - BB
     - bb1
 </pre>

 Expands <code>Flux.just(A, B)</code> into
 <pre>
  A
  B
  AA
  BB
  aa1
  bb1
 </pre></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>expander</code> - the <code>Function</code> applied at each level of recursion to expand
 values into a <code>Publisher</code>, producing a graph.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a breadth-first expanded <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="filter-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filter</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;filter(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;p)</pre>
<div class="block">Evaluate each source value against the given <code>Predicate</code>. If the predicate test succeeds, the value is
 emitted. If the predicate test fails, the value is ignored and a request of 1 is made upstream.

 <p>
 <img class="marble" src="doc-files/marbles/filterForFlux.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that do not match the filter. It
 also discards elements internally queued for backpressure upon cancellation or error triggered by a data signal.

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 (including when fusion is enabled). Exceptions thrown by the predicate are
 considered as if the predicate returned false: they cause the source value to be
 dropped and a new element (<code>request(1)</code>) being requested from upstream.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>p</code> - the <code>Predicate</code> to test values against</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> containing only values that pass the predicate test</dd>
</dl>
</li>
</ul>
<a name="filterWhen-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterWhen</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;filterWhen(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;java.lang.Boolean&gt;&gt;&nbsp;asyncPredicate)</pre>
<div class="block">Test each value emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously using a generated
 <code>Publisher&lt;Boolean&gt;</code> test. A value is replayed if the first item emitted
 by its corresponding test is true. It is dropped if its test is either
 empty or its first emitted value is false.
 <p>
 Note that only the first value of the test publisher is considered, and unless it
 is a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>, test will be cancelled after receiving that first value. Test
 publishers are generated and subscribed to in sequence.

 <p>
 <img class="marble" src="doc-files/marbles/filterWhenForFlux.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that do not match the filter. It
 also discards elements internally queued for backpressure upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>asyncPredicate</code> - the function generating a <code>Publisher</code> of <code>Boolean</code>
 for each value, to filter the Flux with</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a filtered <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="filterWhen-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>filterWhen</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;filterWhen(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;java.lang.Boolean&gt;&gt;&nbsp;asyncPredicate,
                                int&nbsp;bufferSize)</pre>
<div class="block">Test each value emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously using a generated
 <code>Publisher&lt;Boolean&gt;</code> test. A value is replayed if the first item emitted
 by its corresponding test is true. It is dropped if its test is either
 empty or its first emitted value is false.
 <p>
 Note that only the first value of the test publisher is considered, and unless it
 is a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>, test will be cancelled after receiving that first value. Test
 publishers are generated and subscribed to in sequence.

 <p>
 <img class="marble" src="doc-files/marbles/filterWhenForFlux.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that do not match the filter. It
 also discards elements internally queued for backpressure upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>asyncPredicate</code> - the function generating a <code>Publisher</code> of <code>Boolean</code>
 for each value, to filter the Flux with</dd>
<dd><code>bufferSize</code> - the maximum expected number of values to hold pending a result of
 their respective asynchronous predicates, rounded to the next power of two. This is
 capped depending on the size of the heap and the JVM limits, so be careful with
 large values (although eg. 65536 should still be fine). Also serves as
 the initial request size for the source.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a filtered <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="flatMap-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMap</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;flatMap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> through merging,
 which allow them to interleave.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-"><code>flatMapSequential</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator is eagerly
     subscribing to its inners.</li>
     <li><b>Ordering of the flattened values</b>: this operator does not necessarily preserve
     original ordering, as inner element are flattened as they arrive.</li>
     <li><b>Interleaving</b>: this operator lets values from different inners interleave
     (similar to merging the inner sequences).</li>
 </ul>
 <p>
 <img class="marble" src="doc-files/marbles/flatMapForFlux.svg" alt="">
 <p>

 <p><strong>Discard Support:</strong> This operator discards elements internally queued for backpressure upon cancellation or error triggered by a data signal.

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 in the mapper <code>Function</code>. Exceptions thrown by the mapper then behave as if
 it had mapped the value to an empty publisher. If the mapper does map to a scalar
 publisher (an optimization in which the value can be resolved immediately without
 subscribing to the publisher, e.g. a <a href="../../../reactor/core/publisher/Mono.html#fromCallable-java.util.concurrent.Callable-"><code>Mono.fromCallable(Callable)</code></a>) but said
 publisher throws, this can be resumed from in the same manner.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N sequences <code>Publisher</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="flatMap-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMap</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;flatMap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
                                 int&nbsp;concurrency)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> through merging,
 which allow them to interleave.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-"><code>flatMapSequential</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator is eagerly
     subscribing to its inners.</li>
     <li><b>Ordering of the flattened values</b>: this operator does not necessarily preserve
     original ordering, as inner element are flattened as they arrive.</li>
     <li><b>Interleaving</b>: this operator lets values from different inners interleave
     (similar to merging the inner sequences).</li>
 </ul>
 The concurrency argument allows to control how many <code>Publisher</code> can be
 subscribed to and merged in parallel. In turn, that argument shows the size of
 the first <code>Subscription.request(long)</code> to the upstream.

 <p>
 <img class="marble" src="doc-files/marbles/flatMapWithConcurrency.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements internally queued for backpressure upon cancellation or error triggered by a data signal.

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 in the mapper <code>Function</code>. Exceptions thrown by the mapper then behave as if
 it had mapped the value to an empty publisher. If the mapper does map to a scalar
 publisher (an optimization in which the value can be resolved immediately without
 subscribing to the publisher, e.g. a <a href="../../../reactor/core/publisher/Mono.html#fromCallable-java.util.concurrent.Callable-"><code>Mono.fromCallable(Callable)</code></a>) but said
 publisher throws, this can be resumed from in the same manner.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N sequences <code>Publisher</code></dd>
<dd><code>concurrency</code> - the maximum number of in-flight inner sequences</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="flatMap-java.util.function.Function-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMap</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;flatMap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
                                 int&nbsp;concurrency,
                                 int&nbsp;prefetch)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> through merging,
 which allow them to interleave.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-"><code>flatMapSequential</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator is eagerly
     subscribing to its inners.</li>
     <li><b>Ordering of the flattened values</b>: this operator does not necessarily preserve
     original ordering, as inner element are flattened as they arrive.</li>
     <li><b>Interleaving</b>: this operator lets values from different inners interleave
     (similar to merging the inner sequences).</li>
 </ul>
 The concurrency argument allows to control how many <code>Publisher</code> can be
 subscribed to and merged in parallel. In turn, that argument shows the size of
 the first <code>Subscription.request(long)</code> to the upstream.
 The prefetch argument allows to give an arbitrary prefetch size to the merged
 <code>Publisher</code> (in other words prefetch size means the size of the first
 <code>Subscription.request(long)</code> to the merged <code>Publisher</code>).

 <p>
 <img class="marble" src="doc-files/marbles/flatMapWithConcurrencyAndPrefetch.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements internally queued for backpressure upon cancellation or error triggered by a data signal.

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 in the mapper <code>Function</code>. Exceptions thrown by the mapper then behave as if
 it had mapped the value to an empty publisher. If the mapper does map to a scalar
 publisher (an optimization in which the value can be resolved immediately without
 subscribing to the publisher, e.g. a <a href="../../../reactor/core/publisher/Mono.html#fromCallable-java.util.concurrent.Callable-"><code>Mono.fromCallable(Callable)</code></a>) but said
 publisher throws, this can be resumed from in the same manner.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N sequences <code>Publisher</code></dd>
<dd><code>concurrency</code> - the maximum number of in-flight inner sequences</dd>
<dd><code>prefetch</code> - the maximum in-flight elements from each inner <code>Publisher</code> sequence</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="flatMapDelayError-java.util.function.Function-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapDelayError</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;flatMapDelayError(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;mapper,
                                           int&nbsp;concurrency,
                                           int&nbsp;prefetch)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> through merging,
 which allow them to interleave.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-"><code>flatMapSequential</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator is eagerly
     subscribing to its inners.</li>
     <li><b>Ordering of the flattened values</b>: this operator does not necessarily preserve
     original ordering, as inner element are flattened as they arrive.</li>
     <li><b>Interleaving</b>: this operator lets values from different inners interleave
     (similar to merging the inner sequences).</li>
 </ul>
 The concurrency argument allows to control how many <code>Publisher</code> can be
 subscribed to and merged in parallel. The prefetch argument allows to give an
 arbitrary prefetch size to the merged <code>Publisher</code>. This variant will delay
 any error until after the rest of the flatMap backlog has been processed.

 <p>
 <img class="marble" src="doc-files/marbles/flatMapWithConcurrencyAndPrefetch.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements internally queued for backpressure upon cancellation or error triggered by a data signal.

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 in the mapper <code>Function</code>. Exceptions thrown by the mapper then behave as if
 it had mapped the value to an empty publisher. If the mapper does map to a scalar
 publisher (an optimization in which the value can be resolved immediately without
 subscribing to the publisher, e.g. a <a href="../../../reactor/core/publisher/Mono.html#fromCallable-java.util.concurrent.Callable-"><code>Mono.fromCallable(Callable)</code></a>) but said
 publisher throws, this can be resumed from in the same manner.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N sequences <code>Publisher</code></dd>
<dd><code>concurrency</code> - the maximum number of in-flight inner sequences</dd>
<dd><code>prefetch</code> - the maximum in-flight elements from each inner <code>Publisher</code> sequence</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="flatMap-java.util.function.Function-java.util.function.Function-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMap</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;flatMap(<a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                 java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapperOnNext,
                                 <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                 java.util.function.Function&lt;? super java.lang.Throwable,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapperOnError,
                                 <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                 java.util.function.Supplier&lt;? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapperOnComplete)</pre>
<div class="block">Transform the signals emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> through merging,
 which allow them to interleave. Note that at least one of the signal mappers must
 be provided, and all provided mappers must produce a publisher.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-"><code>flatMapSequential</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator is eagerly
     subscribing to its inners.</li>
     <li><b>Ordering of the flattened values</b>: this operator does not necessarily preserve
     original ordering, as inner element are flattened as they arrive.</li>
     <li><b>Interleaving</b>: this operator lets values from different inners interleave
     (similar to merging the inner sequences).</li>
 </ul>
 <p>
 OnError will be transformed into completion signal after its mapping callback has been applied.
 <p>
 <img class="marble" src="doc-files/marbles/flatMapWithMappersOnTerminalEventsForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the output <code>Publisher</code> type target</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapperOnNext</code> - the <code>Function</code> to call on next data and returning a sequence to merge.
 Use null to ignore (provided at least one other mapper is specified).</dd>
<dd><code>mapperOnError</code> - the <code>Function</code> to call on error signal and returning a sequence to merge.
 Use null to ignore (provided at least one other mapper is specified).</dd>
<dd><code>mapperOnComplete</code> - the <code>Function</code> to call on complete signal and returning a sequence to merge.
 Use null to ignore (provided at least one other mapper is specified).</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="flatMapIterable-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapIterable</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;flatMapIterable(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <code>Iterable</code>, then flatten the elements from those by
 merging them into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>. For each iterable, <code>Iterable.iterator()</code> will be called at least
 once and at most twice.

 <p>
 <img class="marble" src="doc-files/marbles/flatMapIterableForFlux.svg" alt="">
 <p>
 This operator inspects each <code>Iterable</code>'s <code>Spliterator</code> to assess if the iteration
 can be guaranteed to be finite (see <a href="../../../reactor/core/publisher/Operators.html#onDiscardMultiple-java.util.Iterator-boolean-reactor.util.context.Context-"><code>Operators.onDiscardMultiple(Iterator, boolean, Context)</code></a>).
 Since the default Spliterator wraps the Iterator we can have two <code>Iterable.iterator()</code>
 calls per iterable. This second invocation is skipped on a <code>Collection</code> however, a type which is
 assumed to be always finite.
 <p>
 Note that unlike <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap(Function)</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap(Function)</code></a>, with Iterable there is
 no notion of eager vs lazy inner subscription. The content of the Iterables are all played sequentially.
 Thus <code>flatMapIterable</code> and <code>concatMapIterable</code> are equivalent offered as a discoverability
 improvement for users that explore the API with the concat vs flatMap expectation.

 <p><strong>Discard Support:</strong> Upon cancellation, this operator discards <code>T</code> elements it prefetched and, in
 some cases, attempts to discard remainder of the currently processed <code>Iterable</code> (if it can
 safely ensure the iterator is finite). Note that this means each <code>Iterable</code>'s <code>Iterable.iterator()</code>
 method could be invoked twice.

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 (including when fusion is enabled). Exceptions thrown by the consumer are passed to
 the <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>onErrorContinue(BiConsumer)</code></a> error consumer (the value consumer
 is not invoked, as the source element will be part of the sequence). The onNext
 signal is then propagated as normal.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N <code>Iterable</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a concatenation of the values from the Iterables obtained from each element in this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="flatMapIterable-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapIterable</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;flatMapIterable(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends java.lang.Iterable&lt;? extends R&gt;&gt;&nbsp;mapper,
                                         int&nbsp;prefetch)</pre>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into <code>Iterable</code>, then flatten the emissions from those by
 merging them into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>. The prefetch argument allows to give an
 arbitrary prefetch size to the upstream source.
 For each iterable, <code>Iterable.iterator()</code> will be called at least once and at most twice.

 <p>
 <img class="marble" src="doc-files/marbles/flatMapIterableForFlux.svg" alt="">
 <p>
 This operator inspects each <code>Iterable</code>'s <code>Spliterator</code> to assess if the iteration
 can be guaranteed to be finite (see <a href="../../../reactor/core/publisher/Operators.html#onDiscardMultiple-java.util.Iterator-boolean-reactor.util.context.Context-"><code>Operators.onDiscardMultiple(Iterator, boolean, Context)</code></a>).
 Since the default Spliterator wraps the Iterator we can have two <code>Iterable.iterator()</code>
 calls per iterable. This second invocation is skipped on a <code>Collection</code> however, a type which is
 assumed to be always finite.
 <p>
 Note that unlike <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap(Function)</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap(Function)</code></a>, with Iterable there is
 no notion of eager vs lazy inner subscription. The content of the Iterables are all played sequentially.
 Thus <code>flatMapIterable</code> and <code>concatMapIterable</code> are equivalent offered as a discoverability
 improvement for users that explore the API with the concat vs flatMap expectation.

 <p><strong>Discard Support:</strong> Upon cancellation, this operator discards <code>T</code> elements it prefetched and, in
 some cases, attempts to discard remainder of the currently processed <code>Iterable</code> (if it can
 safely ensure the iterator is finite).
 Note that this means each <code>Iterable</code>'s <code>Iterable.iterator()</code> method could be invoked twice.

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 (including when fusion is enabled). Exceptions thrown by the consumer are passed to
 the <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>onErrorContinue(BiConsumer)</code></a> error consumer (the value consumer
 is not invoked, as the source element will be part of the sequence). The onNext
 signal is then propagated as normal.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N <code>Iterable</code></dd>
<dd><code>prefetch</code> - the number of values to request from the source upon subscription, to be transformed to <code>Iterable</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a concatenation of the values from the Iterables obtained from each element in this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="flatMapSequential-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapSequential</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;flatMapSequential(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapper)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, but merge them in
 the order of their source element.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator is eagerly
     subscribing to its inners (like flatMap).</li>
     <li><b>Ordering of the flattened values</b>: this operator queues elements from
     late inners until all elements from earlier inners have been emitted, thus emitting
     inner sequences as a whole, in an order that matches their source's order.</li>
     <li><b>Interleaving</b>: this operator does not let values from different inners
     interleave (similar looking result to concatMap, but due to queueing of values
     that would have been interleaved otherwise).</li>
 </ul>

 <p>
 That is to say, whenever a source element is emitted it is transformed to an inner
 <code>Publisher</code>. However, if such an early inner takes more time to complete than
 subsequent faster inners, the data from these faster inners will be queued until
 the earlier inner completes, so as to maintain source ordering.

 <p>
 <img class="marble" src="doc-files/marbles/flatMapSequential.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N sequences <code>Publisher</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="flatMapSequential-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapSequential</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;flatMapSequential(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapper,
                                           int&nbsp;maxConcurrency)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, but merge them in
 the order of their source element.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator is eagerly
     subscribing to its inners (like flatMap).</li>
     <li><b>Ordering of the flattened values</b>: this operator queues elements from
     late inners until all elements from earlier inners have been emitted, thus emitting
     inner sequences as a whole, in an order that matches their source's order.</li>
     <li><b>Interleaving</b>: this operator does not let values from different inners
     interleave (similar looking result to concatMap, but due to queueing of values
     that would have been interleaved otherwise).</li>
 </ul>

 <p>
 That is to say, whenever a source element is emitted it is transformed to an inner
 <code>Publisher</code>. However, if such an early inner takes more time to complete than
 subsequent faster inners, the data from these faster inners will be queued until
 the earlier inner completes, so as to maintain source ordering.

 <p>
 The concurrency argument allows to control how many merged <code>Publisher</code> can happen in parallel.

 <p>
 <img class="marble" src="doc-files/marbles/flatMapSequentialWithConcurrency.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N sequences <code>Publisher</code></dd>
<dd><code>maxConcurrency</code> - the maximum number of in-flight inner sequences</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="flatMapSequential-java.util.function.Function-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapSequential</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;flatMapSequential(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapper,
                                           int&nbsp;maxConcurrency,
                                           int&nbsp;prefetch)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, but merge them in
 the order of their source element.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator is eagerly
     subscribing to its inners (like flatMap).</li>
     <li><b>Ordering of the flattened values</b>: this operator queues elements from
     late inners until all elements from earlier inners have been emitted, thus emitting
     inner sequences as a whole, in an order that matches their source's order.</li>
     <li><b>Interleaving</b>: this operator does not let values from different inners
     interleave (similar looking result to concatMap, but due to queueing of values
     that would have been interleaved otherwise).</li>
 </ul>

 <p>
 That is to say, whenever a source element is emitted it is transformed to an inner
 <code>Publisher</code>. However, if such an early inner takes more time to complete than
 subsequent faster inners, the data from these faster inners will be queued until
 the earlier inner completes, so as to maintain source ordering.

 <p>
 The concurrency argument allows to control how many merged <code>Publisher</code>
 can happen in parallel. The prefetch argument allows to give an arbitrary prefetch
 size to the merged <code>Publisher</code>.

 <p>
 <img class="marble" src="doc-files/marbles/flatMapSequentialWithConcurrencyAndPrefetch.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N sequences <code>Publisher</code></dd>
<dd><code>maxConcurrency</code> - the maximum number of in-flight inner sequences</dd>
<dd><code>prefetch</code> - the maximum in-flight elements from each inner <code>Publisher</code> sequence</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="flatMapSequentialDelayError-java.util.function.Function-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatMapSequentialDelayError</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;flatMapSequentialDelayError(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;mapper,
                                                     int&nbsp;maxConcurrency,
                                                     int&nbsp;prefetch)</pre>
<div class="block">Transform the elements emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> asynchronously into Publishers,
 then flatten these inner publishers into a single <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, but merge them in
 the order of their source element.
 <p>
 There are three dimensions to this operator that can be compared with
 <a href="../../../reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-"><code>flatMap</code></a> and <a href="../../../reactor/core/publisher/Flux.html#concatMap-java.util.function.Function-"><code>concatMap</code></a>:
 <ul>
     <li><b>Generation of inners and subscription</b>: this operator is eagerly
     subscribing to its inners (like flatMap).</li>
     <li><b>Ordering of the flattened values</b>: this operator queues elements from
     late inners until all elements from earlier inners have been emitted, thus emitting
     inner sequences as a whole, in an order that matches their source's order.</li>
     <li><b>Interleaving</b>: this operator does not let values from different inners
     interleave (similar looking result to concatMap, but due to queueing of values
     that would have been interleaved otherwise).</li>
 </ul>

 <p>
 That is to say, whenever a source element is emitted it is transformed to an inner
 <code>Publisher</code>. However, if such an early inner takes more time to complete than
 subsequent faster inners, the data from these faster inners will be queued until
 the earlier inner completes, so as to maintain source ordering.

 <p>
 The concurrency argument allows to control how many merged <code>Publisher</code>
 can happen in parallel. The prefetch argument allows to give an arbitrary prefetch
 size to the merged <code>Publisher</code>. This variant will delay any error until after the
 rest of the flatMap backlog has been processed.

 <p>
 <img class="marble" src="doc-files/marbles/flatMapSequentialWithConcurrencyAndPrefetch.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the merged output sequence type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the <code>Function</code> to transform input sequence into N sequences <code>Publisher</code></dd>
<dd><code>maxConcurrency</code> - the maximum number of in-flight inner sequences</dd>
<dd><code>prefetch</code> - the maximum in-flight elements from each inner <code>Publisher</code> sequence</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a merged <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, subscribing early but keeping the original ordering</dd>
</dl>
</li>
</ul>
<a name="getPrefetch--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getPrefetch</h4>
<pre>public&nbsp;int&nbsp;getPrefetch()</pre>
<div class="block">The prefetch configuration of the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the prefetch configuration of the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, -1 if unspecified</dd>
</dl>
</li>
</ul>
<a name="groupBy-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre>public final&nbsp;&lt;K&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类">GroupedFlux</a>&lt;K,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;groupBy(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyMapper)</pre>
<div class="block">Divide this sequence into dynamically created <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> (or groups) for each
 unique key, as produced by the provided keyMapper <code>Function</code>. Note that
 groupBy works best with a low cardinality of groups, so chose your keyMapper
 function accordingly.

 <p>
 <img class="marble" src="doc-files/marbles/groupByWithKeyMapper.svg" alt="">

 <p>
 The groups need to be drained and consumed downstream for groupBy to work correctly.
 Notably when the criteria produces a large amount of groups, it can lead to hanging
 if the groups are not suitably consumed downstream (eg. due to a <code>flatMap</code>
 with a <code>maxConcurrency</code> parameter that is set too low).

 <p>
 Note that groups are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a specific group more than once: groups are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>K</code> - the key type extracted from each value of this sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keyMapper</code> - the key mapping <code>Function</code> that evaluates an incoming data and returns a key.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类"><code>GroupedFlux</code></a> grouped sequences</dd>
</dl>
</li>
</ul>
<a name="groupBy-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre>public final&nbsp;&lt;K&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类">GroupedFlux</a>&lt;K,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;groupBy(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyMapper,
                                                int&nbsp;prefetch)</pre>
<div class="block">Divide this sequence into dynamically created <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> (or groups) for each
 unique key, as produced by the provided keyMapper <code>Function</code>. Note that
 groupBy works best with a low cardinality of groups, so chose your keyMapper
 function accordingly.

 <p>
 <img class="marble" src="doc-files/marbles/groupByWithKeyMapper.svg" alt="">

 <p>
 The groups need to be drained and consumed downstream for groupBy to work correctly.
 Notably when the criteria produces a large amount of groups, it can lead to hanging
 if the groups are not suitably consumed downstream (eg. due to a <code>flatMap</code>
 with a <code>maxConcurrency</code> parameter that is set too low).

 <p>
 Note that groups are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a specific group more than once: groups are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>K</code> - the key type extracted from each value of this sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keyMapper</code> - the key mapping <code>Function</code> that evaluates an incoming data and returns a key.</dd>
<dd><code>prefetch</code> - the number of values to prefetch from the source</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类"><code>GroupedFlux</code></a> grouped sequences</dd>
</dl>
</li>
</ul>
<a name="groupBy-java.util.function.Function-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre>public final&nbsp;&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类">GroupedFlux</a>&lt;K,V&gt;&gt;&nbsp;groupBy(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyMapper,
                                                  java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueMapper)</pre>
<div class="block">Divide this sequence into dynamically created <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> (or groups) for each
 unique key, as produced by the provided keyMapper <code>Function</code>. Source elements
 are also mapped to a different value using the <code>valueMapper</code>. Note that
 groupBy works best with a low cardinality of groups, so chose your keyMapper
 function accordingly.

 <p>
 <img class="marble" src="doc-files/marbles/groupByWithKeyMapperAndValueMapper.svg" alt="">

 <p>
 The groups need to be drained and consumed downstream for groupBy to work correctly.
 Notably when the criteria produces a large amount of groups, it can lead to hanging
 if the groups are not suitably consumed downstream (eg. due to a <code>flatMap</code>
 with a <code>maxConcurrency</code> parameter that is set too low).

 <p>
 Note that groups are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a specific group more than once: groups are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>K</code> - the key type extracted from each value of this sequence</dd>
<dd><code>V</code> - the value type extracted from each value of this sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keyMapper</code> - the key mapping function that evaluates an incoming data and returns a key.</dd>
<dd><code>valueMapper</code> - the value mapping function that evaluates which data to extract for re-routing.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类"><code>GroupedFlux</code></a> grouped sequences</dd>
</dl>
</li>
</ul>
<a name="groupBy-java.util.function.Function-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupBy</h4>
<pre>public final&nbsp;&lt;K,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类">GroupedFlux</a>&lt;K,V&gt;&gt;&nbsp;groupBy(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends K&gt;&nbsp;keyMapper,
                                                  java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;valueMapper,
                                                  int&nbsp;prefetch)</pre>
<div class="block">Divide this sequence into dynamically created <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> (or groups) for each
 unique key, as produced by the provided keyMapper <code>Function</code>. Source elements
 are also mapped to a different value using the <code>valueMapper</code>. Note that
 groupBy works best with a low cardinality of groups, so chose your keyMapper
 function accordingly.

 <p>
 <img class="marble" src="doc-files/marbles/groupByWithKeyMapperAndValueMapper.svg" alt="">

 <p>
 The groups need to be drained and consumed downstream for groupBy to work correctly.
 Notably when the criteria produces a large amount of groups, it can lead to hanging
 if the groups are not suitably consumed downstream (eg. due to a <code>flatMap</code>
 with a <code>maxConcurrency</code> parameter that is set too low).

 <p>
 Note that groups are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a specific group more than once: groups are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>K</code> - the key type extracted from each value of this sequence</dd>
<dd><code>V</code> - the value type extracted from each value of this sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keyMapper</code> - the key mapping function that evaluates an incoming data and returns a key.</dd>
<dd><code>valueMapper</code> - the value mapping function that evaluates which data to extract for re-routing.</dd>
<dd><code>prefetch</code> - the number of values to prefetch from the source</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/GroupedFlux.html" title="reactor.core.publisher中的类"><code>GroupedFlux</code></a> grouped sequences</dd>
</dl>
</li>
</ul>
<a name="groupJoin-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupJoin</h4>
<pre>public final&nbsp;&lt;TRight,TLeftEnd,TRightEnd,R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;groupJoin(org.reactivestreams.Publisher&lt;? extends TRight&gt;&nbsp;other,
                                                             java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;TLeftEnd&gt;&gt;&nbsp;leftEnd,
                                                             java.util.function.Function&lt;? super TRight,? extends org.reactivestreams.Publisher&lt;TRightEnd&gt;&gt;&nbsp;rightEnd,
                                                             java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;TRight&gt;,? extends R&gt;&nbsp;resultSelector)</pre>
<div class="block">Map values from two Publishers into time windows and emit combination of values
 in case their windows overlap. The emitted elements are obtained by passing the
 value from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitting the value from the other
 <code>Publisher</code> to a <code>BiFunction</code>.
 <p>
 There are no guarantees in what order the items get combined when multiple items from
 one or both source Publishers overlap.
 <p>
 Unlike <a href="../../../reactor/core/publisher/Flux.html#join-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-"><code>join(org.reactivestreams.Publisher&lt;? extends TRight&gt;, java.util.function.Function&lt;? super T, ? extends org.reactivestreams.Publisher&lt;TLeftEnd&gt;&gt;, java.util.function.Function&lt;? super TRight, ? extends org.reactivestreams.Publisher&lt;TRightEnd&gt;&gt;, java.util.function.BiFunction&lt;? super T, ? super TRight, ? extends R&gt;)</code></a>, items from the second <code>Publisher</code> will be provided
 as a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> to the <code>resultSelector</code>.

 <p>
 <img class="marble" src="doc-files/marbles/groupJoin.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>TRight</code> - the type of the elements from the right <code>Publisher</code></dd>
<dd><code>TLeftEnd</code> - the type for this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> window signals</dd>
<dd><code>TRightEnd</code> - the type for the right <code>Publisher</code> window signals</dd>
<dd><code>R</code> - the combined result type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the other <code>Publisher</code> to correlate items with</dd>
<dd><code>leftEnd</code> - a function that returns a Publisher whose emissions indicate the
 time window for the source value to be considered</dd>
<dd><code>rightEnd</code> - a function that returns a Publisher whose emissions indicate the
 time window for the <code>right</code> Publisher value to be considered</dd>
<dd><code>resultSelector</code> - a function that takes an item emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and
 a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> representation of the overlapping item from the other <code>Publisher</code>
 and returns the value to be emitted by the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a joining <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#join-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-"><code>join(Publisher, Function, Function, BiFunction)</code></a></dd>
</dl>
</li>
</ul>
<a name="handle-java.util.function.BiConsumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>handle</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;handle(java.util.function.BiConsumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,<a href="../../../reactor/core/publisher/SynchronousSink.html" title="reactor.core.publisher中的接口">SynchronousSink</a>&lt;R&gt;&gt;&nbsp;handler)</pre>
<div class="block">Handle the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by calling a biconsumer with the
 output sink for each onNext. At most one <a href="../../../reactor/core/publisher/SynchronousSink.html#next-T-"><code>SynchronousSink.next(Object)</code></a>
 call must be performed and/or 0 or 1 <a href="../../../reactor/core/publisher/SynchronousSink.html#error-java.lang.Throwable-"><code>SynchronousSink.error(Throwable)</code></a> or
 <a href="../../../reactor/core/publisher/SynchronousSink.html#complete--"><code>SynchronousSink.complete()</code></a>.

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a> (including when
 fusion is enabled) when the <code>BiConsumer</code> throws an exception or if an error is signaled explicitly via
 <a href="../../../reactor/core/publisher/SynchronousSink.html#error-java.lang.Throwable-"><code>SynchronousSink.error(Throwable)</code></a>.
 <p>
 When the <a href="https://github.com/micrometer-metrics/context-propagation">context-propagation library</a>
 is available at runtime and the downstream <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a> is not empty, this operator implicitly uses the
 library to restore thread locals around the handler <code>BiConsumer</code>. Typically, this would be done in conjunction
 with the use of <a href="../../../reactor/core/publisher/Flux.html#contextCapture--"><code>contextCapture()</code></a> operator down the chain.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the transformed type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>handler</code> - the handling <code>BiConsumer</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a transformed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="hasElement-java.lang.Object-">
<!--   -->
</a><a name="hasElement-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasElement</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Boolean&gt;&nbsp;hasElement(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;value)</pre>
<div class="block">Emit a single boolean true if any of the elements of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence is
 equal to the provided value.
 <p>
 The implementation uses short-circuit logic and completes with true if
 an element matches the value.

 <p>
 <img class="marble" src="doc-files/marbles/hasElementForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>value</code> - constant compared to incoming signals</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with <code>true</code> if any element is equal to a given value and <code>false</code>
 otherwise</dd>
</dl>
</li>
</ul>
<a name="hasElements--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasElements</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Boolean&gt;&nbsp;hasElements()</pre>
<div class="block">Emit a single boolean true if this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence has at least one element.
 <p>
 The implementation uses short-circuit logic and completes with true on onNext.

 <p>
 <img class="marble" src="doc-files/marbles/hasElements.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> with <code>true</code> if any value is emitted and <code>false</code>
 otherwise</dd>
</dl>
</li>
</ul>
<a name="hide--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hide</h4>
<pre>public&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;hide()</pre>
<div class="block">Hides the identities of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> instance.
 <p>The main purpose of this operator is to prevent certain identity-based
 optimizations from happening, mostly for diagnostic purposes.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> preventing <code>Publisher</code> / <code>Subscription</code> based Reactor optimizations</dd>
</dl>
</li>
</ul>
<a name="index--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>index</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;java.lang.Long,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;index()</pre>
<div class="block">Keep information about the order in which source values were received by
 indexing them with a 0-based incrementing long, returning a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 of <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2<(index, value)></code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/index.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an indexed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with each source value combined with its 0-based index.</dd>
</dl>
</li>
</ul>
<a name="index-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>index</h4>
<pre>public final&nbsp;&lt;I&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;I&gt;&nbsp;index(java.util.function.BiFunction&lt;? super java.lang.Long,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends I&gt;&nbsp;indexMapper)</pre>
<div class="block">Keep information about the order in which source values were received by
 indexing them internally with a 0-based incrementing long then combining this
 information with the source value into a <code>I</code> using the provided <code>BiFunction</code>,
 returning a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux&lt;I&gt;</code></a>.
 <p>
 Typical usage would be to produce a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a> similar to <a href="../../../reactor/core/publisher/Flux.html#index--"><code>index()</code></a>, but
 1-based instead of 0-based:
 <p>
 <code>index((i, v) -&gt; Tuples.of(i+1, v))</code>
 <p>
 <img class="marble" src="doc-files/marbles/indexWithMapper.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>indexMapper</code> - the <code>BiFunction</code> to use to combine elements and their index.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an indexed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with each source value combined with its computed index.</dd>
</dl>
</li>
</ul>
<a name="ignoreElements--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ignoreElements</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;ignoreElements()</pre>
<div class="block">Ignores onNext signals (dropping them) and only propagate termination events.

 <p>
 <img class="marble" src="doc-files/marbles/ignoreElementsForFlux.svg" alt="">
 <p>

 <p><strong>Discard Support:</strong> This operator discards the upstream's elements.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new empty <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> representing the completion of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</dd>
</dl>
</li>
</ul>
<a name="join-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>join</h4>
<pre>public final&nbsp;&lt;TRight,TLeftEnd,TRightEnd,R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;join(org.reactivestreams.Publisher&lt;? extends TRight&gt;&nbsp;other,
                                                        java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;TLeftEnd&gt;&gt;&nbsp;leftEnd,
                                                        java.util.function.Function&lt;? super TRight,? extends org.reactivestreams.Publisher&lt;TRightEnd&gt;&gt;&nbsp;rightEnd,
                                                        java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super TRight,? extends R&gt;&nbsp;resultSelector)</pre>
<div class="block">Combine values from two Publishers in case their windows overlap. Each incoming
 value triggers a creation of a new Publisher via the given <code>Function</code>. If the
 Publisher signals its first value or completes, the time windows for the original
 element is immediately closed. The emitted elements are obtained by passing the
 values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and the other <code>Publisher</code> to a <code>BiFunction</code>.
 <p>
 There are no guarantees in what order the items get combined when multiple items from
 one or both source Publishers overlap.

 <p>
 <img class="marble" src="doc-files/marbles/join.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>TRight</code> - the type of the elements from the right <code>Publisher</code></dd>
<dd><code>TLeftEnd</code> - the type for this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> window signals</dd>
<dd><code>TRightEnd</code> - the type for the right <code>Publisher</code> window signals</dd>
<dd><code>R</code> - the combined result type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the other <code>Publisher</code> to correlate items with</dd>
<dd><code>leftEnd</code> - a function that returns a Publisher whose emissions indicate the
 time window for the source value to be considered</dd>
<dd><code>rightEnd</code> - a function that returns a Publisher whose emissions indicate the
 time window for the <code>right</code> Publisher value to be considered</dd>
<dd><code>resultSelector</code> - a function that takes an item emitted by each Publisher and returns the
 value to be emitted by the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a joining <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#groupJoin-org.reactivestreams.Publisher-java.util.function.Function-java.util.function.Function-java.util.function.BiFunction-"><code>groupJoin(Publisher, Function, Function, BiFunction)</code></a></dd>
</dl>
</li>
</ul>
<a name="last--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>last</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;last()</pre>
<div class="block">获取序列最后一个元素，如果序列为空抛出 <code>NoSuchElementException</code>
 <p>
 Emit the last element observed before complete signal as a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>, or emit
 <code>NoSuchElementException</code> error if the source was empty.
 For a passive version use <a href="../../../reactor/core/publisher/Flux.html#takeLast-int-"><code>takeLast(int)</code></a>

 <p>
 <img class="marble" src="doc-files/marbles/last.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements before the last.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> with the last value in this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="last-java.lang.Object-">
<!--   -->
</a><a name="last-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>last</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;last(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;defaultValue)</pre>
<div class="block">Emit the last element observed before complete signal as a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>, or emit
 the <code>defaultValue</code> if the source was empty.
 For a passive version use <a href="../../../reactor/core/publisher/Flux.html#takeLast-int-"><code>takeLast(int)</code></a>

 <p>
 <img class="marble" src="doc-files/marbles/lastWithDefault.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements before the last.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>defaultValue</code> - a single fallback item if this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is empty</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> with the last value in this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="limitRate-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitRate</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;limitRate(int&nbsp;prefetchRate)</pre>
<div class="block">Ensure that backpressure signals from downstream subscribers are split into batches
 capped at the provided <code>prefetchRate</code> when propagated upstream, effectively
 rate limiting the upstream <code>Publisher</code>.
 <p>
 Note that this is an upper bound, and that this operator uses a prefetch-and-replenish
 strategy, requesting a replenishing amount when 75% of the prefetch amount has been
 emitted.
 <p>
 Typically used for scenarios where consumer(s) request a large amount of data
 (eg. <code>Long.MAX_VALUE</code>) but the data source behaves better or can be optimized
 with smaller requests (eg. database paging, etc...). All data is still processed,
 unlike with <a href="../../../reactor/core/publisher/Flux.html#take-long-"><code>take(long)</code></a> which will cap the grand total request
 amount.
 <p>
 Equivalent to <code>flux.publishOn(Schedulers.immediate(), prefetchRate).subscribe() </code>.
 Note that the <code>prefetchRate</code> is an upper bound, and that this operator uses a
 prefetch-and-replenish strategy, requesting a replenishing amount when 75% of the
 prefetch amount has been emitted.
 <p>
 <img class="marble" src="doc-files/marbles/limitRate.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>prefetchRate</code> - the limit to apply to downstream's backpressure</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> limiting downstream's backpressure</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#publishOn-reactor.core.scheduler.Scheduler-int-"><code>publishOn(Scheduler, int)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#take-long-"><code>take(long)</code></a></dd>
</dl>
</li>
</ul>
<a name="limitRate-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitRate</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;limitRate(int&nbsp;highTide,
                               int&nbsp;lowTide)</pre>
<div class="block">Ensure that backpressure signals from downstream subscribers are split into batches
 capped at the provided <code>highTide</code> first, then replenishing at the provided
 <code>lowTide</code>, effectively rate limiting the upstream <code>Publisher</code>.
 <p>
 Note that this is an upper bound, and that this operator uses a prefetch-and-replenish
 strategy, requesting a replenishing amount when 75% of the prefetch amount has been
 emitted.
 <p>
 Typically used for scenarios where consumer(s) request a large amount of data
 (eg. <code>Long.MAX_VALUE</code>) but the data source behaves better or can be optimized
 with smaller requests (eg. database paging, etc...). All data is still processed,
 unlike with <a href="../../../reactor/core/publisher/Flux.html#take-long-"><code>take(long)</code></a> which will cap the grand total request
 amount.
 <p>
 Similar to <code>flux.publishOn(Schedulers.immediate(), prefetchRate).subscribe() </code>,
 except with a customized "low tide" instead of the default 75%.
 Note that the smaller the lowTide is, the higher the potential for concurrency
 between request and data production. And thus the more extraneous replenishment
 requests this operator could make. For example, for a global downstream
 request of 14, with a highTide of 10 and a lowTide of 2, the operator would perform
 low tide requests (<code>request(2)</code>) seven times in a row, whereas with the default
 lowTide of 8 it would only perform one low tide request (<code>request(8)</code>).
 Using a <code>lowTide</code> equal to <code>highTide</code> reverts to the default 75% strategy,
 while using a <code>lowTide</code> of 0 disables the lowTide, resulting in
 all requests strictly adhering to the highTide.
 <p>
 <img class="marble" src="doc-files/marbles/limitRateWithHighAndLowTide.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>highTide</code> - the initial request amount</dd>
<dd><code>lowTide</code> - the subsequent (or replenishing) request amount, 0 to
 disable early replenishing, highTide to revert to a 75% replenish strategy.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> limiting downstream's backpressure and customizing the
 replenishment request amount</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#publishOn-reactor.core.scheduler.Scheduler-int-"><code>publishOn(Scheduler, int)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#take-long-"><code>take(long)</code></a></dd>
</dl>
</li>
</ul>
<a name="limitRequest-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>limitRequest</h4>
<pre>@Deprecated
public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;limitRequest(long&nbsp;n)</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">replace with <a href="../../../reactor/core/publisher/Flux.html#take-long-boolean-"><code>take(n, true)</code></a> in 3.4.x, then <a href="../../../reactor/core/publisher/Flux.html#take-long-"><code>take(long)</code></a> in 3.5.0.
 To be removed in 3.6.0 at the earliest. See https://github.com/reactor/reactor-core/issues/2339</span></div>
<div class="block">Take only the first N values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, if available.
 Furthermore, ensure that the total amount requested upstream is capped at <code>n</code>.
 If n is zero, the source isn't even subscribed to and the operator completes immediately
 upon subscription.
 <p>
 <img class="marble" src="doc-files/marbles/takeLimitRequestTrue.svg" alt="">
 <p>
 Backpressure signals from downstream subscribers are smaller than the cap are
 propagated as is, but if they would cause the total requested amount to go over the
 cap, they are reduced to the minimum value that doesn't go over.
 <p>
 As a result, this operator never let the upstream produce more elements than the
 cap.
 Typically useful for cases where a race between request and cancellation can lead the upstream to
 producing a lot of extraneous data, and such a production is undesirable (e.g.
 a source that would send the extraneous data over the network).</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>n</code> - the number of elements to emit from this flux, which is also the backpressure
 cap for all of downstream's request</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <code>n</code> elements from the source, that requests AT MOST <code>n</code> from upstream in total.</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#take-long-"><code>take(long)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#take-long-boolean-"><code>take(long, boolean)</code></a></dd>
</dl>
</li>
</ul>
<a name="log--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>log</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;log()</pre>
<div class="block">Observe all Reactive Streams signals and trace them using <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a> support.
 Default will use <code>Level.INFO</code> and <code>java.util.logging</code>.
 If SLF4J is available, it will be used instead.
 <p>
 <img class="marble" src="doc-files/marbles/logForFlux.svg" alt="">
 <p>
 The default log category will be "reactor.Flux.", followed by a suffix generated from
 the source operator, e.g. "reactor.Flux.Map".</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that logs signals</dd>
</dl>
</li>
</ul>
<a name="log-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>log</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;log(java.lang.String&nbsp;category)</pre>
<div class="block">Observe all Reactive Streams signals and trace them using <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a> support.
 Default will use <code>Level.INFO</code> and <code>java.util.logging</code>.
 If SLF4J is available, it will be used instead.
 <p>
 <img class="marble" src="doc-files/marbles/logForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>category</code> - to be mapped into logger configuration (e.g. org.springframework
 .reactor). If category ends with "." like "reactor.", a generated operator
 suffix will be added, e.g. "reactor.Flux.Map".</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that logs signals</dd>
</dl>
</li>
</ul>
<a name="log-java.lang.String-java.util.logging.Level-reactor.core.publisher.SignalType...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>log</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;log(<a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                         java.lang.String&nbsp;category,
                         java.util.logging.Level&nbsp;level,
                         <a href="../../../reactor/core/publisher/SignalType.html" title="reactor.core.publisher中的枚举">SignalType</a>...&nbsp;options)</pre>
<div class="block">Observe Reactive Streams signals matching the passed filter <code>options</code> and
 trace them using <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a> support. Default will use <code>Level.INFO</code> and
 <code>java.util.logging</code>. If SLF4J is available, it will be used instead.
 <p>
 Options allow fine grained filtering of the traced signal, for instance to only
 capture onNext and onError:
 <pre>
     flux.log("category", Level.INFO, SignalType.ON_NEXT, SignalType.ON_ERROR)
 </pre>
 <p>
 <img class="marble" src="doc-files/marbles/logForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>category</code> - to be mapped into logger configuration (e.g. org.springframework
 .reactor). If category ends with "." like "reactor.", a generated operator
 suffix will be added, e.g. "reactor.Flux.Map".</dd>
<dd><code>level</code> - the <code>Level</code> to enforce for this tracing Flux (only FINEST, FINE,
 INFO, WARNING and SEVERE are taken into account)</dd>
<dd><code>options</code> - a vararg <a href="../../../reactor/core/publisher/SignalType.html" title="reactor.core.publisher中的枚举"><code>SignalType</code></a> option to filter log messages</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that logs signals</dd>
</dl>
</li>
</ul>
<a name="log-java.lang.String-java.util.logging.Level-boolean-reactor.core.publisher.SignalType...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>log</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;log(<a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                         java.lang.String&nbsp;category,
                         java.util.logging.Level&nbsp;level,
                         boolean&nbsp;showOperatorLine,
                         <a href="../../../reactor/core/publisher/SignalType.html" title="reactor.core.publisher中的枚举">SignalType</a>...&nbsp;options)</pre>
<div class="block">Observe Reactive Streams signals matching the passed filter <code>options</code> and
 trace them using <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a> support. Default will use <code>Level.INFO</code> and
 <code>java.util.logging</code>. If SLF4J is available, it will be used instead.
 <p>
 Options allow fine grained filtering of the traced signal, for instance to only
 capture onNext and onError:
 <pre>
     flux.log("category", Level.INFO, SignalType.ON_NEXT, SignalType.ON_ERROR)
 </pre>
 <p>
 <img class="marble" src="doc-files/marbles/logForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>category</code> - to be mapped into logger configuration (e.g. org.springframework
 .reactor). If category ends with "." like "reactor.", a generated operator
 suffix will be added, e.g. "reactor.Flux.Map".</dd>
<dd><code>level</code> - the <code>Level</code> to enforce for this tracing Flux (only FINEST, FINE,
 INFO, WARNING and SEVERE are taken into account)</dd>
<dd><code>showOperatorLine</code> - capture the current stack to display operator class/line number.</dd>
<dd><code>options</code> - a vararg <a href="../../../reactor/core/publisher/SignalType.html" title="reactor.core.publisher中的枚举"><code>SignalType</code></a> option to filter log messages</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that logs signals</dd>
</dl>
</li>
</ul>
<a name="log-reactor.util.Logger-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>log</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;log(<a href="../../../reactor/util/Logger.html" title="reactor.util中的接口">Logger</a>&nbsp;logger)</pre>
<div class="block">Observe Reactive Streams signals matching the passed filter <code>options</code> and
 trace them using a specific user-provided <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a>, at <code>Level.INFO</code> level.
 <p>
 <img class="marble" src="doc-files/marbles/logForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>logger</code> - the <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a> to use, instead of resolving one through a category.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that logs signals</dd>
</dl>
</li>
</ul>
<a name="log-reactor.util.Logger-java.util.logging.Level-boolean-reactor.core.publisher.SignalType...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>log</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;log(<a href="../../../reactor/util/Logger.html" title="reactor.util中的接口">Logger</a>&nbsp;logger,
                         java.util.logging.Level&nbsp;level,
                         boolean&nbsp;showOperatorLine,
                         <a href="../../../reactor/core/publisher/SignalType.html" title="reactor.core.publisher中的枚举">SignalType</a>...&nbsp;options)</pre>
<div class="block">Observe Reactive Streams signals matching the passed filter <code>options</code> and
 trace them using a specific user-provided <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a>, at the given <code>Level</code>.
 <p>
 Options allow fine grained filtering of the traced signal, for instance to only
 capture onNext and onError:
 <pre>
     flux.log(myCustomLogger, Level.INFO, SignalType.ON_NEXT, SignalType.ON_ERROR)
 </pre>
 <p>
 <img class="marble" src="doc-files/marbles/logForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>logger</code> - the <a href="../../../reactor/util/Logger.html" title="reactor.util中的接口"><code>Logger</code></a> to use, instead of resolving one through a category.</dd>
<dd><code>level</code> - the <code>Level</code> to enforce for this tracing Flux (only FINEST, FINE,
 INFO, WARNING and SEVERE are taken into account)</dd>
<dd><code>showOperatorLine</code> - capture the current stack to display operator class/line number (default in overload is false).</dd>
<dd><code>options</code> - a vararg <a href="../../../reactor/core/publisher/SignalType.html" title="reactor.core.publisher中的枚举"><code>SignalType</code></a> option to filter log messages</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that logs signals</dd>
</dl>
</li>
</ul>
<a name="map-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>map</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;map(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;mapper)</pre>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by applying a synchronous function
 to each item.
 <p>
 <img class="marble" src="doc-files/marbles/mapForFlux.svg" alt="">

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 (including when fusion is enabled). Exceptions thrown by the mapper then cause the
 source value to be dropped and a new element (<code>request(1)</code>) being requested
 from upstream.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the transformed type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the synchronous transforming <code>Function</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a transformed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="mapNotNull-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mapNotNull</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;mapNotNull(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;mapper)</pre>
<div class="block">Transform the items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by applying a synchronous function
 to each item, which may produce <code>null</code> values. In that case, no value is emitted.
 This operator effectively behaves like <a href="../../../reactor/core/publisher/Flux.html#map-java.util.function.Function-"><code>map(Function)</code></a> followed by <a href="../../../reactor/core/publisher/Flux.html#filter-java.util.function.Predicate-"><code>filter(Predicate)</code></a>
 although <code>null</code> is not a supported value, so it can't be filtered out.

 <p>
 <img class="marble" src="doc-files/marbles/mapNotNullForFlux.svg" alt="">

 <p><strong>Error Mode Support:</strong> This operator supports <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>resuming on errors</code></a>
 (including when fusion is enabled). Exceptions thrown by the mapper then cause the
 source value to be dropped and a new element (<code>request(1)</code>) being requested
 from upstream.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the transformed type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the synchronous transforming <code>Function</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a transformed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="materialize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>materialize</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口">Signal</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;materialize()</pre>
<div class="block">Transform incoming onNext, onError and onComplete signals into <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a> instances,
 materializing these signals.
 Since the error is materialized as a <code>Signal</code>, the propagation will be stopped and onComplete will be
 emitted. Complete signal will first emit a <code>Signal.complete()</code> and then effectively complete the flux.
 All these <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a> have a <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> associated to them.

 <p>
 <img class="marble" src="doc-files/marbles/materializeForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of materialized <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#dematerialize--"><code>dematerialize()</code></a></dd>
</dl>
</li>
</ul>
<a name="mergeOrderedWith-org.reactivestreams.Publisher-java.util.Comparator-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeOrderedWith</h4>
<pre>@Deprecated
public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;mergeOrderedWith(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;other,
                                                   java.util.Comparator&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;otherComparator)</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">Use <a href="../../../reactor/core/publisher/Flux.html#mergeComparingWith-org.reactivestreams.Publisher-java.util.Comparator-"><code>mergeComparingWith(Publisher, Comparator)</code></a> instead
 (with the caveat that it defaults to NOT delaying errors, unlike this operator).
 To be removed in 3.6.0 at the earliest.</span></div>
<div class="block">Merge data from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and a <code>Publisher</code> into a reordered merge
 sequence, by picking the smallest value from each sequence as defined by a provided
 <code>Comparator</code>. Note that subsequent calls are combined, and their comparators are
 in lexicographic order as defined by <code>Comparator.thenComparing(Comparator)</code>.
 <p>
 The combination step is avoided if the two <code>Comparators</code> are
 <code>equal</code> (which can easily be achieved by using the
 same reference, and is also always true of <code>Comparator.naturalOrder()</code>).
 <p>
 Note that merge is tailored to work with asynchronous sources or finite sources. When dealing with
 an infinite source that doesn't already publish on a dedicated Scheduler, you must isolate that source
 in its own Scheduler, as merge would otherwise attempt to drain it before subscribing to
 another source.
 <p>
 Note that it is delaying errors until all data is consumed.
 <p>
 <img class="marble" src="doc-files/marbles/mergeComparingWith.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the <code>Publisher</code> to merge with</dd>
<dd><code>otherComparator</code> - the <code>Comparator</code> to use for merging</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares latest values from the given publisher
 and this flux, using the smallest value and replenishing the source that produced it</dd>
</dl>
</li>
</ul>
<a name="mergeComparingWith-org.reactivestreams.Publisher-java.util.Comparator-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeComparingWith</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;mergeComparingWith(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;other,
                                        java.util.Comparator&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;otherComparator)</pre>
<div class="block">Merge data from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and a <code>Publisher</code> into a reordered merge
 sequence, by picking the smallest value from each sequence as defined by a provided
 <code>Comparator</code>. Note that subsequent calls are combined, and their comparators are
 in lexicographic order as defined by <code>Comparator.thenComparing(Comparator)</code>.
 <p>
 The combination step is avoided if the two <code>Comparators</code> are
 <code>equal</code> (which can easily be achieved by using the
 same reference, and is also always true of <code>Comparator.naturalOrder()</code>).
 <p>
 Note that merge is tailored to work with asynchronous sources or finite sources. When dealing with
 an infinite source that doesn't already publish on a dedicated Scheduler, you must isolate that source
 in its own Scheduler, as merge would otherwise attempt to drain it before subscribing to
 another source.
 <p>
 <img class="marble" src="doc-files/marbles/mergeComparingWith.svg" alt="">
 <p>
 mergeComparingWith doesn't delay errors by default, but it will inherit the delayError
 behavior of a mergeComparingDelayError directly above it.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the <code>Publisher</code> to merge with</dd>
<dd><code>otherComparator</code> - the <code>Comparator</code> to use for merging</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that compares latest values from the given publisher
 and this flux, using the smallest value and replenishing the source that produced it</dd>
</dl>
</li>
</ul>
<a name="mergeWith-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mergeWith</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;mergeWith(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;other)</pre>
<div class="block">Merge data from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and a <code>Publisher</code> into an interleaved merged
 sequence. Unlike <a href="../../../reactor/core/publisher/Flux.html#concatWith-org.reactivestreams.Publisher-"><code>concat</code></a>, inner sources are subscribed
 to eagerly.
 <p>
 <img class="marble" src="doc-files/marbles/mergeWithForFlux.svg" alt="">
 <p>
 Note that merge is tailored to work with asynchronous sources or finite sources. When dealing with
 an infinite source that doesn't already publish on a dedicated Scheduler, you must isolate that source
 in its own Scheduler, as merge would otherwise attempt to drain it before subscribing to
 another source.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the <code>Publisher</code> to merge with</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="metrics--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>metrics</h4>
<pre>@Deprecated
public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;metrics()</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">Prefer using the <a href="../../../reactor/core/publisher/Flux.html#tap-reactor.core.observability.SignalListenerFactory-"><code>tap(SignalListenerFactory)</code></a> with the <a href="../../../reactor/core/observability/SignalListenerFactory.html" title="reactor.core.observability中的接口"><code>SignalListenerFactory</code></a> provided by
 the new reactor-core-micrometer module. To be removed in 3.6.0 at the earliest.</span></div>
<div class="block">Activate metrics for this sequence, provided there is an instrumentation facade
 on the classpath (otherwise this method is a pure no-op).
 <p>
 Metrics are gathered on <code>Subscriber</code> events, and it is recommended to also
 <a href="../../../reactor/core/publisher/Flux.html#name-java.lang.String-"><code>name</code></a> (and optionally <a href="../../../reactor/core/publisher/Flux.html#tag-java.lang.String-java.lang.String-"><code>tag</code></a>) the
 sequence.
 <p>
 The name serves as a prefix in the reported metrics names. In case no name has been provided, the default name "reactor" will be applied.
 <p>
 The <code>MeterRegistry</code> used by reactor can be configured via
 <a href="../../../reactor/util/Metrics.MicrometerConfiguration.html#useRegistry-io.micrometer.core.instrument.MeterRegistry-"><code>Metrics.MicrometerConfiguration.useRegistry(MeterRegistry)</code></a>
 prior to using this operator, the default being
 <code>Metrics.globalRegistry</code>.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an instrumented <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#name-java.lang.String-"><code>name(String)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#tag-java.lang.String-java.lang.String-"><code>tag(String, String)</code></a></dd>
</dl>
</li>
</ul>
<a name="name-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>name</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;name(java.lang.String&nbsp;name)</pre>
<div class="block">Give a name to this sequence, which can be retrieved using <a href="../../../reactor/core/Scannable.html#name--"><code>Scannable.name()</code></a>
 as long as this is the first reachable <a href="../../../reactor/core/Scannable.html#parents--"><code>Scannable.parents()</code></a>.
 <p>
 The name is typically visible at assembly time by the <a href="../../../reactor/core/publisher/Flux.html#tap-reactor.core.observability.SignalListenerFactory-"><code>tap(SignalListenerFactory)</code></a> operator,
 which could for example be configured with a metrics listener using the name as a prefix for meters' id.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>name</code> - a name for the sequence</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the same sequence, but bearing a name</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#metrics--"><code>metrics()</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#tag-java.lang.String-java.lang.String-"><code>tag(String, String)</code></a></dd>
</dl>
</li>
</ul>
<a name="next--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>next</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;next()</pre>
<div class="block">仅将Flux发出的第一个元素发布到新的Mono中。如果在空的Flux上调用，则发出一个空的Mono
 <p>
 Emit only the first item emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, into a new <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>.
 If called on an empty <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, emits an empty <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/next.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> emitting the first value in this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="ofType-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ofType</h4>
<pre>public final&nbsp;&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;U&gt;&nbsp;ofType(java.lang.Class&lt;U&gt;&nbsp;clazz)</pre>
<div class="block">Evaluate each accepted value against the given <code>Class</code> type. If the
 value matches the type, it is passed into the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>. Otherwise
 the value is ignored and a request of 1 is emitted.

 <p>
 <img class="marble" src="doc-files/marbles/ofTypeForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>clazz</code> - the <code>Class</code> type to test values against</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> filtered on items of the requested type</dd>
</dl>
</li>
</ul>
<a name="onBackpressureBuffer--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onBackpressureBuffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBackpressureBuffer()</pre>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park the
 observed elements if not enough demand is requested downstream. Errors will be
 delayed until the buffer gets consumed.

 <p>
 <img class="marble" src="doc-files/marbles/onBackpressureBuffer.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the buffered overflow elements upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a backpressured <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that buffers with unbounded capacity</dd>
</dl>
</li>
</ul>
<a name="onBackpressureBuffer-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onBackpressureBuffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBackpressureBuffer(int&nbsp;maxSize)</pre>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park up to
 <code>maxSize</code> elements when not enough demand is requested downstream.
 The first element past this buffer to arrive out of sync with the downstream
 subscriber's demand (the "overflowing" element) immediately triggers an overflow
 error and cancels the source.
 The <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is going to terminate with an overflow error, but this error is
 delayed, which lets the subscriber make more requests for the content of the buffer.
 <p>
 <img class="marble" src="doc-files/marbles/onBackpressureBufferWithMaxSize.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the buffered overflow elements upon cancellation or error triggered by a data signal,
 as well as elements that are rejected by the buffer due to <code>maxSize</code>.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - maximum number of elements overflowing request before the source is cancelled</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a backpressured <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that buffers with bounded capacity</dd>
</dl>
</li>
</ul>
<a name="onBackpressureBuffer-int-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onBackpressureBuffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBackpressureBuffer(int&nbsp;maxSize,
                                          java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onOverflow)</pre>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park up to
 <code>maxSize</code> elements when not enough demand is requested downstream.
 The first element past this buffer to arrive out of sync with the downstream
 subscriber's demand (the "overflowing" element) is immediately passed to a
 <code>Consumer</code> and the source is cancelled.
 The <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is going to terminate with an overflow error, but this error is
 delayed, which lets the subscriber make more requests for the content of the buffer.
 <p>
 Note that should the cancelled source produce further overflowing elements, these
 would be passed to the <a href="../../../reactor/core/publisher/Hooks.html#onNextDropped-java.util.function.Consumer-"><code>onNextDropped hook</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/onBackpressureBufferWithMaxSizeConsumer.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the buffered overflow elements upon cancellation or error triggered by a data signal,
 as well as elements that are rejected by the buffer due to <code>maxSize</code> (even though
 they are passed to the <code>onOverflow</code> <code>Consumer</code> first).</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - maximum number of elements overflowing request before callback is called and source is cancelled</dd>
<dd><code>onOverflow</code> - callback to invoke on overflow</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a backpressured <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that buffers with a bounded capacity</dd>
</dl>
</li>
</ul>
<a name="onBackpressureBuffer-int-reactor.core.publisher.BufferOverflowStrategy-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onBackpressureBuffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBackpressureBuffer(int&nbsp;maxSize,
                                          <a href="../../../reactor/core/publisher/BufferOverflowStrategy.html" title="reactor.core.publisher中的枚举">BufferOverflowStrategy</a>&nbsp;bufferOverflowStrategy)</pre>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park the observed
 elements if not enough demand is requested downstream, within a <code>maxSize</code>
 limit. Over that limit, the overflow strategy is applied (see <a href="../../../reactor/core/publisher/BufferOverflowStrategy.html" title="reactor.core.publisher中的枚举"><code>BufferOverflowStrategy</code></a>).
 <p>
 Note that for the <a href="../../../reactor/core/publisher/BufferOverflowStrategy.html#ERROR"><code>ERROR</code></a> strategy, the overflow
 error will be delayed after the current backlog is consumed.

 <p>
 <img class="marble" src="doc-files/marbles/onBackpressureBufferWithMaxSizeStrategyDropOldest.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the buffered overflow elements upon cancellation or error triggered by a data signal,
 as well as elements that are rejected by the buffer due to <code>maxSize</code> (even though
 they are passed to the <code>bufferOverflowStrategy</code> first).</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - maximum buffer backlog size before overflow strategy is applied</dd>
<dd><code>bufferOverflowStrategy</code> - strategy to apply to overflowing elements</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a backpressured <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that buffers up to a capacity then applies an
 overflow strategy</dd>
</dl>
</li>
</ul>
<a name="onBackpressureBuffer-int-java.util.function.Consumer-reactor.core.publisher.BufferOverflowStrategy-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onBackpressureBuffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBackpressureBuffer(int&nbsp;maxSize,
                                          java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBufferOverflow,
                                          <a href="../../../reactor/core/publisher/BufferOverflowStrategy.html" title="reactor.core.publisher中的枚举">BufferOverflowStrategy</a>&nbsp;bufferOverflowStrategy)</pre>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park the observed
 elements if not enough demand is requested downstream, within a <code>maxSize</code>
 limit. Over that limit, the overflow strategy is applied (see <a href="../../../reactor/core/publisher/BufferOverflowStrategy.html" title="reactor.core.publisher中的枚举"><code>BufferOverflowStrategy</code></a>).
 <p>
 A <code>Consumer</code> is immediately invoked when there is an overflow, receiving the
 value that was discarded because of the overflow (which can be different from the
 latest element emitted by the source in case of a
 <a href="../../../reactor/core/publisher/BufferOverflowStrategy.html#DROP_LATEST"><code>DROP_LATEST</code></a> strategy).

 <p>
 Note that for the <a href="../../../reactor/core/publisher/BufferOverflowStrategy.html#ERROR"><code>ERROR</code></a> strategy, the overflow
 error will be delayed after the current backlog is consumed. The consumer is still
 invoked immediately.

 <p>
 <img class="marble" src="doc-files/marbles/onBackpressureBufferWithMaxSizeStrategyDropOldest.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the buffered overflow elements upon cancellation or error triggered by a data signal,
 as well as elements that are rejected by the buffer due to <code>maxSize</code> (even though
 they are passed to the <code>onOverflow</code> <code>Consumer</code> AND the <code>bufferOverflowStrategy</code> first).</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - maximum buffer backlog size before overflow callback is called</dd>
<dd><code>onBufferOverflow</code> - callback to invoke on overflow</dd>
<dd><code>bufferOverflowStrategy</code> - strategy to apply to overflowing elements</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a backpressured <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that buffers up to a capacity then applies an
 overflow strategy</dd>
</dl>
</li>
</ul>
<a name="onBackpressureBuffer-java.time.Duration-int-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onBackpressureBuffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBackpressureBuffer(java.time.Duration&nbsp;ttl,
                                          int&nbsp;maxSize,
                                          java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBufferEviction)</pre>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park the observed
 elements if not enough demand is requested downstream, within a <code>maxSize</code>
 limit and for a maximum <code>Duration</code> of <code>ttl</code> (as measured on the
 <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel Scheduler</code></a>). Over that limit, oldest
 elements from the source are dropped.
 <p>
 Elements evicted based on the TTL are passed to a cleanup <code>Consumer</code>, which
 is also immediately invoked when there is an overflow.

 <p>
 <img class="marble" src="doc-files/marbles/onBackpressureBufferWithDurationAndMaxSize.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards its internal buffer of elements that overflow,
 after having applied the <code>onBufferEviction</code> handler.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>ttl</code> - maximum <code>Duration</code> for which an element is kept in the backlog</dd>
<dd><code>maxSize</code> - maximum buffer backlog size before overflow callback is called</dd>
<dd><code>onBufferEviction</code> - callback to invoke once TTL is reached or on overflow</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a backpressured <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that buffers with a TTL and up to a capacity then applies an
 overflow strategy</dd>
</dl>
</li>
</ul>
<a name="onBackpressureBuffer-java.time.Duration-int-java.util.function.Consumer-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onBackpressureBuffer</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBackpressureBuffer(java.time.Duration&nbsp;ttl,
                                          int&nbsp;maxSize,
                                          java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBufferEviction,
                                          <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</pre>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or park the observed
 elements if not enough demand is requested downstream, within a <code>maxSize</code>
 limit and for a maximum <code>Duration</code> of <code>ttl</code> (as measured on the provided
 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>). Over that limit, oldest elements from the source are dropped.
 <p>
 Elements evicted based on the TTL are passed to a cleanup <code>Consumer</code>, which
 is also immediately invoked when there is an overflow.

 <p>
 <img class="marble" src="doc-files/marbles/onBackpressureBufferWithDurationAndMaxSize.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards its internal buffer of elements that overflow,
 after having applied the <code>onBufferEviction</code> handler.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>ttl</code> - maximum <code>Duration</code> for which an element is kept in the backlog</dd>
<dd><code>maxSize</code> - maximum buffer backlog size before overflow callback is called</dd>
<dd><code>onBufferEviction</code> - callback to invoke once TTL is reached or on overflow</dd>
<dd><code>scheduler</code> - the scheduler on which to run the timeout check</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a backpressured <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that buffers with a TTL and up to a capacity then applies an
 overflow strategy</dd>
</dl>
</li>
</ul>
<a name="onBackpressureDrop--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onBackpressureDrop</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBackpressureDrop()</pre>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or drop
 the observed elements if not enough demand is requested downstream.

 <p>
 <img class="marble" src="doc-files/marbles/onBackpressureDrop.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that it drops.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a backpressured <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that drops overflowing elements</dd>
</dl>
</li>
</ul>
<a name="onBackpressureDrop-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onBackpressureDrop</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBackpressureDrop(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onDropped)</pre>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or drop and
 notify dropping <code>Consumer</code> with the observed elements if not enough demand
 is requested downstream.

 <p>
 <img class="marble" src="doc-files/marbles/onBackpressureDropWithConsumer.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that it drops after having passed
 them to the provided <code>onDropped</code> handler.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>onDropped</code> - the Consumer called when a value gets dropped due to lack of downstream requests</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a backpressured <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that drops overflowing elements</dd>
</dl>
</li>
</ul>
<a name="onBackpressureError--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onBackpressureError</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBackpressureError()</pre>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or emit onError
 fom <a href="../../../reactor/core/Exceptions.html#failWithOverflow--"><code>Exceptions.failWithOverflow()</code></a> if not enough demand is requested
 downstream.

 <p>
 <img class="marble" src="doc-files/marbles/onBackpressureError.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that it drops, after having propagated
 the error.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a backpressured <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that errors on overflowing elements</dd>
</dl>
</li>
</ul>
<a name="onBackpressureLatest--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onBackpressureLatest</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onBackpressureLatest()</pre>
<div class="block">Request an unbounded demand and push to the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, or only keep
 the most recent observed item if not enough demand is requested downstream.

 <p>
 <img class="marble" src="doc-files/marbles/onBackpressureLatest.svg" alt="">
 <p>
 <p><strong>Discard Support:</strong> Each time a new element comes in (the new "latest"), this operator
 discards the previously retained element.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a backpressured <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will only keep a reference to the last observed item</dd>
</dl>
</li>
</ul>
<a name="onErrorComplete--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorComplete</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorComplete()</pre>
<div class="block">Simply complete the sequence by replacing an <code>onError signal</code>
 with an <code>onComplete signal</code>. All other signals are propagated as-is.

 <p>
 <img class="marble" src="doc-files/marbles/onErrorCompleteForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> falling back on completion when an onError occurs</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#onErrorReturn-T-"><code>onErrorReturn(Object)</code></a></dd>
</dl>
</li>
</ul>
<a name="onErrorComplete-java.lang.Class-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorComplete</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorComplete(java.lang.Class&lt;? extends java.lang.Throwable&gt;&nbsp;type)</pre>
<div class="block">Simply complete the sequence by replacing an <code>onError signal</code>
 with an <code>onComplete signal</code> if the error matches the given
 <code>Class</code>. All other signals, including non-matching onError, are propagated as-is.

 <p>
 <img class="marble" src="doc-files/marbles/onErrorCompleteForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> falling back on completion when a matching error occurs</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-"><code>onErrorReturn(Class, Object)</code></a></dd>
</dl>
</li>
</ul>
<a name="onErrorComplete-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorComplete</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorComplete(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate)</pre>
<div class="block">Simply complete the sequence by replacing an <code>onError signal</code>
 with an <code>onComplete signal</code> if the error matches the given
 <code>Predicate</code>. All other signals, including non-matching onError, are propagated as-is.

 <p>
 <img class="marble" src="doc-files/marbles/onErrorCompleteForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> falling back on completion when a matching error occurs</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#onErrorReturn-java.util.function.Predicate-T-"><code>onErrorReturn(Predicate, Object)</code></a></dd>
</dl>
</li>
</ul>
<a name="onErrorContinue-java.util.function.BiConsumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorContinue</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorContinue(java.util.function.BiConsumer&lt;java.lang.Throwable,java.lang.Object&gt;&nbsp;errorConsumer)</pre>
<div class="block">Let compatible operators <strong>upstream</strong> recover from errors by dropping the
 incriminating element from the sequence and continuing with subsequent elements.
 The recovered error and associated value are notified via the provided <code>BiConsumer</code>.
 Alternatively, throwing from that biconsumer will propagate the thrown exception downstream
 in place of the original error, which is added as a suppressed exception to the new one.
 <p>
 <img class="marble" src="doc-files/marbles/onErrorContinue.svg" alt="">
 <p>
 Note that onErrorContinue() is a specialist operator that can make the behaviour of your
 reactive chain unclear. It operates on upstream, not downstream operators, it requires specific
 operator support to work, and the scope can easily propagate upstream into library code
 that didn't anticipate it (resulting in unintended behaviour.)
 <p>
 In most cases, you should instead handle the error inside the specific function which may cause
 it. Specifically, on each inner publisher you can use <code>doOnError</code> to log the error, and
 <code>onErrorResume(e -&gt; Mono.empty())</code> to drop erroneous elements:
 <p>
 <pre>
 .flatMap(id -> repository.retrieveById(id)
                          .doOnError(System.err::println)
                          .onErrorResume(e -> Mono.empty()))
 </pre>
 <p>
 This has the advantage of being much clearer, has no ambiguity with regards to operator support,
 and cannot leak upstream.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>errorConsumer</code> - a <code>BiConsumer</code> fed with errors matching the predicate and the value
 that triggered the error.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that attempts to continue processing on errors.</dd>
</dl>
</li>
</ul>
<a name="onErrorContinue-java.lang.Class-java.util.function.BiConsumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorContinue</h4>
<pre>public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorContinue(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                     java.util.function.BiConsumer&lt;java.lang.Throwable,java.lang.Object&gt;&nbsp;errorConsumer)</pre>
<div class="block">Let compatible operators <strong>upstream</strong> recover from errors by dropping the
 incriminating element from the sequence and continuing with subsequent elements.
 Only errors matching the specified <code>type</code> are recovered from.
 The recovered error and associated value are notified via the provided <code>BiConsumer</code>.
 Alternatively, throwing from that biconsumer will propagate the thrown exception downstream
 in place of the original error, which is added as a suppressed exception to the new one.
 <p>
 <img class="marble" src="doc-files/marbles/onErrorContinueWithClassPredicate.svg" alt="">
 <p>
 Note that onErrorContinue() is a specialist operator that can make the behaviour of your
 reactive chain unclear. It operates on upstream, not downstream operators, it requires specific
 operator support to work, and the scope can easily propagate upstream into library code
 that didn't anticipate it (resulting in unintended behaviour.)
 <p>
 In most cases, you should instead handle the error inside the specific function which may cause
 it. Specifically, on each inner publisher you can use <code>doOnError</code> to log the error, and
 <code>onErrorResume(e -&gt; Mono.empty())</code> to drop erroneous elements:
 <p>
 <pre>
 .flatMap(id -> repository.retrieveById(id)
                          .doOnError(MyException.class, System.err::println)
                          .onErrorResume(MyException.class, e -> Mono.empty()))
 </pre>
 <p>
 This has the advantage of being much clearer, has no ambiguity with regards to operator support,
 and cannot leak upstream.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>type</code> - the <code>Class</code> of <code>Exception</code> that are resumed from.</dd>
<dd><code>errorConsumer</code> - a <code>BiConsumer</code> fed with errors matching the <code>Class</code>
 and the value that triggered the error.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that attempts to continue processing on some errors.</dd>
</dl>
</li>
</ul>
<a name="onErrorContinue-java.util.function.Predicate-java.util.function.BiConsumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorContinue</h4>
<pre>public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorContinue(java.util.function.Predicate&lt;E&gt;&nbsp;errorPredicate,
                                                                     java.util.function.BiConsumer&lt;java.lang.Throwable,java.lang.Object&gt;&nbsp;errorConsumer)</pre>
<div class="block">Let compatible operators <strong>upstream</strong> recover from errors by dropping the
 incriminating element from the sequence and continuing with subsequent elements.
 Only errors matching the <code>Predicate</code> are recovered from (note that this
 predicate can be applied several times and thus must be idempotent).
 The recovered error and associated value are notified via the provided <code>BiConsumer</code>.
 Alternatively, throwing from that biconsumer will propagate the thrown exception downstream
 in place of the original error, which is added as a suppressed exception to the new one.
 <p>
 <img class="marble" src="doc-files/marbles/onErrorContinueWithPredicate.svg" alt="">
 <p>
 Note that onErrorContinue() is a specialist operator that can make the behaviour of your
 reactive chain unclear. It operates on upstream, not downstream operators, it requires specific
 operator support to work, and the scope can easily propagate upstream into library code
 that didn't anticipate it (resulting in unintended behaviour.)
 <p>
 In most cases, you should instead handle the error inside the specific function which may cause
 it. Specifically, on each inner publisher you can use <code>doOnError</code> to log the error, and
 <code>onErrorResume(e -&gt; Mono.empty())</code> to drop erroneous elements:
 <p>
 <pre>
 .flatMap(id -> repository.retrieveById(id)
                          .doOnError(errorPredicate, System.err::println)
                          .onErrorResume(errorPredicate, e -> Mono.empty()))
 </pre>
 <p>
 This has the advantage of being much clearer, has no ambiguity with regards to operator support,
 and cannot leak upstream.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>errorPredicate</code> - a <code>Predicate</code> used to filter which errors should be resumed from.
 This MUST be idempotent, as it can be used several times.</dd>
<dd><code>errorConsumer</code> - a <code>BiConsumer</code> fed with errors matching the predicate and the value
 that triggered the error.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that attempts to continue processing on some errors.</dd>
</dl>
</li>
</ul>
<a name="onErrorStop--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorStop</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorStop()</pre>
<div class="block">If an <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>onErrorContinue(BiConsumer)</code></a> variant has been used downstream, reverts
 to the default 'STOP' mode where errors are terminal events upstream. It can be
 used for easier scoping of the on next failure strategy or to override the
 inherited strategy in a sub-stream (for example in a flatMap). It has no effect if
 <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>onErrorContinue(BiConsumer)</code></a> has not been used downstream.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that terminates on errors, even if <a href="../../../reactor/core/publisher/Flux.html#onErrorContinue-java.util.function.BiConsumer-"><code>onErrorContinue(BiConsumer)</code></a>
 was used downstream</dd>
</dl>
</li>
</ul>
<a name="onErrorMap-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorMap(java.util.function.Function&lt;? super java.lang.Throwable,? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform any error emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by synchronously applying a function to it.

 <p>
 <img class="marble" src="doc-files/marbles/onErrorMapForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>mapper</code> - the error transforming <code>Function</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that transforms source errors to other errors</dd>
</dl>
</li>
</ul>
<a name="onErrorMap-java.lang.Class-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre>public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorMap(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                java.util.function.Function&lt;? super E,? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform an error emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by synchronously applying a function
 to it if the error matches the given type. Otherwise let the error pass through.
 <p>
 <img class="marble" src="doc-files/marbles/onErrorMapWithClassPredicateForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>E</code> - the error type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>type</code> - the class of the exception type to react to</dd>
<dd><code>mapper</code> - the error transforming <code>Function</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that transforms some source errors to other errors</dd>
</dl>
</li>
</ul>
<a name="onErrorMap-java.util.function.Predicate-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorMap</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorMap(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                                java.util.function.Function&lt;? super java.lang.Throwable,? extends java.lang.Throwable&gt;&nbsp;mapper)</pre>
<div class="block">Transform an error emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by synchronously applying a function
 to it if the error matches the given predicate. Otherwise let the error pass through.
 <p>
 <img class="marble" src="doc-files/marbles/onErrorMapWithPredicateForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>predicate</code> - the error predicate</dd>
<dd><code>mapper</code> - the error transforming <code>Function</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that transforms some source errors to other errors</dd>
</dl>
</li>
</ul>
<a name="onErrorResume-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorResume(java.util.function.Function&lt;? super java.lang.Throwable,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;fallback)</pre>
<div class="block">Subscribe to a returned fallback publisher when any error occurs, using a function to
 choose the fallback depending on the error.

 <p>
 <img class="marble" src="doc-files/marbles/onErrorResumeForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>fallback</code> - the function to choose the fallback to an alternative <code>Publisher</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> falling back upon source onError</dd>
</dl>
</li>
</ul>
<a name="onErrorResume-java.lang.Class-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre>public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorResume(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                   java.util.function.Function&lt;? super E,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;fallback)</pre>
<div class="block">Subscribe to a fallback publisher when an error matching the given type
 occurs, using a function to choose the fallback depending on the error.
 <p>
 <img class="marble" src="doc-files/marbles/onErrorResumeForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>E</code> - the error type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>type</code> - the error type to match</dd>
<dd><code>fallback</code> - the function to choose the fallback to an alternative <code>Publisher</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> falling back upon source onError</dd>
</dl>
</li>
</ul>
<a name="onErrorResume-java.util.function.Predicate-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorResume</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorResume(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                                   java.util.function.Function&lt;? super java.lang.Throwable,? extends org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;fallback)</pre>
<div class="block">Subscribe to a fallback publisher when an error matching a given predicate
 occurs.
 <p>
 <img class="marble" src="doc-files/marbles/onErrorResumeForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>predicate</code> - the error predicate to match</dd>
<dd><code>fallback</code> - the function to choose the fallback to an alternative <code>Publisher</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> falling back upon source onError</dd>
</dl>
</li>
</ul>
<a name="onErrorReturn-java.lang.Object-">
<!--   -->
</a><a name="onErrorReturn-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorReturn</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorReturn(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;fallbackValue)</pre>
<div class="block">Simply emit a captured fallback value when any error is observed on this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/onErrorReturnForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>fallbackValue</code> - the value to emit if an error occurs</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new falling back <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#onErrorComplete--"><code>onErrorComplete()</code></a></dd>
</dl>
</li>
</ul>
<a name="onErrorReturn-java.lang.Class-java.lang.Object-">
<!--   -->
</a><a name="onErrorReturn-java.lang.Class-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorReturn</h4>
<pre>public final&nbsp;&lt;E extends java.lang.Throwable&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorReturn(java.lang.Class&lt;E&gt;&nbsp;type,
                                                                   <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;fallbackValue)</pre>
<div class="block">Simply emit a captured fallback value when an error of the specified type is
 observed on this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/onErrorReturnForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>E</code> - the error type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>type</code> - the error type to match</dd>
<dd><code>fallbackValue</code> - the value to emit if an error occurs that matches the type</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new falling back <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#onErrorComplete-java.lang.Class-"><code>onErrorComplete(Class)</code></a></dd>
</dl>
</li>
</ul>
<a name="onErrorReturn-java.util.function.Predicate-java.lang.Object-">
<!--   -->
</a><a name="onErrorReturn-java.util.function.Predicate-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onErrorReturn</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onErrorReturn(java.util.function.Predicate&lt;? super java.lang.Throwable&gt;&nbsp;predicate,
                                   <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;fallbackValue)</pre>
<div class="block">Simply emit a captured fallback value when an error matching the given predicate is
 observed on this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.
 <p>
 <img class="marble" src="doc-files/marbles/onErrorReturnForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>predicate</code> - the error predicate to match</dd>
<dd><code>fallbackValue</code> - the value to emit if an error occurs that matches the predicate</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new falling back <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#onErrorComplete-java.util.function.Predicate-"><code>onErrorComplete(Predicate)</code></a></dd>
</dl>
</li>
</ul>
<a name="onTerminateDetach--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>onTerminateDetach</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;onTerminateDetach()</pre>
<div class="block">Detaches both the child <code>Subscriber</code> and the <code>Subscription</code> on
 termination or cancellation.
 <p>This is an advanced interoperability operator that should help with odd
 retention scenarios when running with non-reactor <code>Subscriber</code>.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a detachable <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="or-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>or</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;or(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;other)</pre>
<div class="block">Pick the first <code>Publisher</code> between this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and another publisher
 to emit any signal (onNext/onError/onComplete) and replay all signals from that
 <code>Publisher</code>, effectively behaving like the fastest of these competing sources.

 <p>
 <img class="marble" src="doc-files/marbles/orForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the <code>Publisher</code> to race with</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the fastest sequence</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#firstWithSignal-org.reactivestreams.Publisher...-"><code>firstWithSignal(org.reactivestreams.Publisher&lt;? extends I&gt;...)</code></a></dd>
</dl>
</li>
</ul>
<a name="parallel--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallel</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/ParallelFlux.html" title="reactor.core.publisher中的类">ParallelFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;parallel()</pre>
<div class="block">Prepare this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by dividing data on a number of 'rails' matching the
 number of CPU cores, in a round-robin fashion. Note that to actually perform the
 work in parallel, you should call <a href="../../../reactor/core/publisher/ParallelFlux.html#runOn-reactor.core.scheduler.Scheduler-"><code>ParallelFlux.runOn(Scheduler)</code></a> afterward.

 <p>
 <img class="marble" src="doc-files/marbles/parallel.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/ParallelFlux.html" title="reactor.core.publisher中的类"><code>ParallelFlux</code></a> instance</dd>
</dl>
</li>
</ul>
<a name="parallel-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallel</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/ParallelFlux.html" title="reactor.core.publisher中的类">ParallelFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;parallel(int&nbsp;parallelism)</pre>
<div class="block">Prepare this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by dividing data on a number of 'rails' matching the
 provided <code>parallelism</code> parameter, in a round-robin fashion. Note that to
 actually perform the work in parallel, you should call <a href="../../../reactor/core/publisher/ParallelFlux.html#runOn-reactor.core.scheduler.Scheduler-"><code>ParallelFlux.runOn(Scheduler)</code></a>
 afterward.

 <p>
 <img class="marble" src="doc-files/marbles/parallel.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>parallelism</code> - the number of parallel rails</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/ParallelFlux.html" title="reactor.core.publisher中的类"><code>ParallelFlux</code></a> instance</dd>
</dl>
</li>
</ul>
<a name="parallel-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parallel</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/ParallelFlux.html" title="reactor.core.publisher中的类">ParallelFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;parallel(int&nbsp;parallelism,
                                      int&nbsp;prefetch)</pre>
<div class="block">Prepare this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by dividing data on a number of 'rails' matching the
 provided <code>parallelism</code> parameter, in a round-robin fashion and using a
 custom prefetch amount and queue for dealing with the source <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>'s values.
 Note that to actually perform the work in parallel, you should call
 <a href="../../../reactor/core/publisher/ParallelFlux.html#runOn-reactor.core.scheduler.Scheduler-"><code>ParallelFlux.runOn(Scheduler)</code></a> afterward.

 <p>
 <img class="marble" src="doc-files/marbles/parallel.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>parallelism</code> - the number of parallel rails</dd>
<dd><code>prefetch</code> - the number of values to prefetch from the source</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/ParallelFlux.html" title="reactor.core.publisher中的类"><code>ParallelFlux</code></a> instance</dd>
</dl>
</li>
</ul>
<a name="publish--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publish</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;publish()</pre>
<div class="block">Prepare a <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a> which shares this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence and
 dispatches values to subscribers in a backpressure-aware manner. Prefetch will
 default to <a href="../../../reactor/util/concurrent/Queues.html#SMALL_BUFFER_SIZE"><code>Queues.SMALL_BUFFER_SIZE</code></a>. This will effectively turn
 any type of sequence into a hot sequence.
 <p>
 Backpressure will be coordinated on <code>Subscription.request(long)</code> and if any
 <code>Subscriber</code> is missing demand (requested = 0), multicast will pause
 pushing/pulling.
 <p>
 <img class="marble" src="doc-files/marbles/publish.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a></dd>
</dl>
</li>
</ul>
<a name="publish-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publish</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;publish(int&nbsp;prefetch)</pre>
<div class="block">Prepare a <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a> which shares this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence and
 dispatches values to subscribers in a backpressure-aware manner. This will
 effectively turn any type of sequence into a hot sequence.
 <p>
 Backpressure will be coordinated on <code>Subscription.request(long)</code> and if any
 <code>Subscriber</code> is missing demand (requested = 0), multicast will pause
 pushing/pulling.
 <p>
 <img class="marble" src="doc-files/marbles/publish.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>prefetch</code> - bounded requested demand</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a></dd>
</dl>
</li>
</ul>
<a name="publish-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publish</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;publish(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;transform)</pre>
<div class="block">Shares a sequence for the duration of a function that may transform it and
 consume it as many times as necessary without causing multiple subscriptions
 to the upstream.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the output value type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>transform</code> - the transformation function</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="publish-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publish</h4>
<pre>public final&nbsp;&lt;R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;publish(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,? extends org.reactivestreams.Publisher&lt;? extends R&gt;&gt;&nbsp;transform,
                                 int&nbsp;prefetch)</pre>
<div class="block">Shares a sequence for the duration of a function that may transform it and
 consume it as many times as necessary without causing multiple subscriptions
 to the upstream.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>R</code> - the output value type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>transform</code> - the transformation function</dd>
<dd><code>prefetch</code> - the request size</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="publishNext--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishNext</h4>
<pre>@Deprecated
public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;publishNext()</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">use <a href="../../../reactor/core/publisher/Flux.html#shareNext--"><code>shareNext()</code></a> instead, or use `publish().next()` if you need
 to `<a href="../../../reactor/core/publisher/ConnectableFlux.html#connect--"><code>connect()</code></a>. To be removed in 3.5.0</span></div>
<div class="block">Prepare a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> which shares this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence and dispatches the
 first observed item to subscribers in a backpressure-aware manner.
 This will effectively turn any type of sequence into a hot sequence when the first
 <code>Subscriber</code> subscribes.
 <p>
 <img class="marble" src="doc-files/marbles/publishNext.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a></dd>
</dl>
</li>
</ul>
<a name="publishOn-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishOn</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;publishOn(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</pre>
<div class="block">Run onNext, onComplete and onError on a supplied <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>
 <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Worker</code></a>.
 <p>
 This operator influences the threading context where the rest of the operators in
 the chain below it will execute, up to a new occurrence of <code>publishOn</code>.
 <p>
 <img class="marble" src="doc-files/marbles/publishOnForFlux.svg" alt="">
 <p>
 Typically used for fast publisher, slow consumer(s) scenarios.
 <blockquote><pre>
 <code> flux.publishOn(Schedulers.single()).subscribe() </code>
 </pre></blockquote>

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>scheduler</code> - a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> providing the <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> where to publish</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> producing asynchronously on a given <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a></dd>
</dl>
</li>
</ul>
<a name="publishOn-reactor.core.scheduler.Scheduler-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishOn</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;publishOn(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler,
                               int&nbsp;prefetch)</pre>
<div class="block">Run onNext, onComplete and onError on a supplied <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>
 <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a>.
 <p>
 This operator influences the threading context where the rest of the operators in
 the chain below it will execute, up to a new occurrence of <code>publishOn</code>.
 <p>
 <img class="marble" src="doc-files/marbles/publishOnForFlux.svg" alt="">
 <p>
 Typically used for fast publisher, slow consumer(s) scenarios.
 <blockquote><pre>
 <code> flux.publishOn(Schedulers.single()).subscribe() </code>
 </pre></blockquote>

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>scheduler</code> - a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> providing the <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> where to publish</dd>
<dd><code>prefetch</code> - the asynchronous boundary capacity</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> producing asynchronously</dd>
</dl>
</li>
</ul>
<a name="publishOn-reactor.core.scheduler.Scheduler-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>publishOn</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;publishOn(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler,
                               boolean&nbsp;delayError,
                               int&nbsp;prefetch)</pre>
<div class="block">Run onNext, onComplete and onError on a supplied <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>
 <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a>.
 <p>
 This operator influences the threading context where the rest of the operators in
 the chain below it will execute, up to a new occurrence of <code>publishOn</code>.
 <p>
 <img class="marble" src="doc-files/marbles/publishOnForFlux.svg" alt="">
 <p>
 Typically used for fast publisher, slow consumer(s) scenarios.
 <blockquote><pre>
 <code> flux.publishOn(Schedulers.single()).subscribe() </code>
 </pre></blockquote>

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>scheduler</code> - a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> providing the <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> where to publish</dd>
<dd><code>delayError</code> - should the buffer be consumed before forwarding any error</dd>
<dd><code>prefetch</code> - the asynchronous boundary capacity</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> producing asynchronously</dd>
</dl>
</li>
</ul>
<a name="reduce-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;reduce(java.util.function.BiFunction&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;aggregator)</pre>
<div class="block">将一个 <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> 规约为一个 <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>
 <p>
 Reduce the values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into a single object of the same
 type than the emitted items. Reduction is performed using a <code>BiFunction</code> that
 takes the intermediate result of the reduction and the current value and returns
 the next intermediate value of the reduction. Note, <code>BiFunction</code> will not
 be invoked for a sequence with 0 or 1 elements. In case of one element's
 sequence, the result will be directly sent to the subscriber.

 <p>
 <img class="marble" src="doc-files/marbles/reduceWithSameReturnType.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the internally accumulated value upon cancellation or error.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>aggregator</code> - the reducing <code>BiFunction</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a reduced <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="reduce-java.lang.Object-java.util.function.BiFunction-">
<!--   -->
</a><a name="reduce-A-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduce</h4>
<pre>public final&nbsp;&lt;A&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;A&gt;&nbsp;reduce(A&nbsp;initial,
                                java.util.function.BiFunction&lt;A,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,A&gt;&nbsp;accumulator)</pre>
<div class="block">Reduce the values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into a single object matching the
 type of a seed value. Reduction is performed using a <code>BiFunction</code> that
 takes the intermediate result of the reduction and the current value and returns
 the next intermediate value of the reduction. First element is paired with the seed
 value, initial.

 <p>
 <img class="marble" src="doc-files/marbles/reduce.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the internally accumulated value upon cancellation or error.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>A</code> - the type of the seed and the reduced object</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>accumulator</code> - the reducing <code>BiFunction</code></dd>
<dd><code>initial</code> - the seed, the initial leftmost argument to pass to the reducing <code>BiFunction</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a reduced <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="reduceWith-java.util.function.Supplier-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reduceWith</h4>
<pre>public final&nbsp;&lt;A&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;A&gt;&nbsp;reduceWith(java.util.function.Supplier&lt;A&gt;&nbsp;initial,
                                    java.util.function.BiFunction&lt;A,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,A&gt;&nbsp;accumulator)</pre>
<div class="block">Reduce the values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into a single object matching the
 type of a lazily supplied seed value. Reduction is performed using a
 <code>BiFunction</code> that takes the intermediate result of the reduction and the
 current value and returns the next intermediate value of the reduction. First
 element is paired with the seed value, supplied via initial.

 <p>
 <img class="marble" src="doc-files/marbles/reduceWith.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards the internally accumulated value upon cancellation or error.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>A</code> - the type of the seed and the reduced object</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>accumulator</code> - the reducing <code>BiFunction</code></dd>
<dd><code>initial</code> - a <code>Supplier</code> of the seed, called on subscription and passed to the the reducing <code>BiFunction</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a reduced <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="repeat--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;repeat()</pre>
<div class="block">Repeatedly and indefinitely subscribe to the source upon completion of the
 previous subscription.

 <p>
 <img class="marble" src="doc-files/marbles/repeatForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an indefinitely repeated <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> on onComplete</dd>
</dl>
</li>
</ul>
<a name="repeat-java.util.function.BooleanSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;repeat(java.util.function.BooleanSupplier&nbsp;predicate)</pre>
<div class="block">Repeatedly subscribe to the source if the predicate returns true after completion of the previous subscription.

 <p>
 <img class="marble" src="doc-files/marbles/repeatWithPredicateForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>predicate</code> - the boolean to evaluate on onComplete.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that repeats on onComplete while the predicate matches</dd>
</dl>
</li>
</ul>
<a name="repeat-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;repeat(long&nbsp;numRepeat)</pre>
<div class="block">Repeatedly subscribe to the source <code>numRepeat</code> times. This results in
 <code>numRepeat + 1</code> total subscriptions to the original source. As a consequence,
 using 0 plays the original sequence once.

 <p>
 <img class="marble" src="doc-files/marbles/repeatWithAttemptsForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>numRepeat</code> - the number of times to re-subscribe on onComplete (positive, or 0 for original sequence only)</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that repeats on onComplete, up to the specified number of repetitions</dd>
</dl>
</li>
</ul>
<a name="repeat-long-java.util.function.BooleanSupplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeat</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;repeat(long&nbsp;numRepeat,
                            java.util.function.BooleanSupplier&nbsp;predicate)</pre>
<div class="block">Repeatedly subscribe to the source if the predicate returns true after completion of the previous
 subscription. A specified maximum of repeat will limit the number of re-subscribe.

 <p>
 <img class="marble" src="doc-files/marbles/repeatWithAttemptsAndPredicateForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>numRepeat</code> - the number of times to re-subscribe on complete (positive, or 0 for original sequence only)</dd>
<dd><code>predicate</code> - the boolean to evaluate on onComplete</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that repeats on onComplete while the predicate matches,
 up to the specified number of repetitions</dd>
</dl>
</li>
</ul>
<a name="repeatWhen-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>repeatWhen</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;repeatWhen(java.util.function.Function&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;java.lang.Long&gt;,? extends org.reactivestreams.Publisher&lt;?&gt;&gt;&nbsp;repeatFactory)</pre>
<div class="block">Repeatedly subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> when a companion sequence emits elements in
 response to the flux completion signal. Any terminal signal from the companion
 sequence will terminate the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the same signal immediately.
 <p>If the companion sequence signals when this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is active, the repeat
 attempt is suppressed.
 <p>
 <img class="marble" src="doc-files/marbles/repeatWhenForFlux.svg" alt="">
 <p>
 Note that if the companion <code>Publisher</code> created by the <code>repeatFactory</code>
 emits <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> as trigger objects, these <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> will be merged with
 the previous Context:
 <pre><code>
 .repeatWhen(emittedEachAttempt -> emittedEachAttempt.handle((lastEmitted, sink) -> {
            Context ctx = sink.currentContext();
            int rl = ctx.getOrDefault("repeatsLeft", 0);
            if (rl > 0) {
                    sink.next(Context.of(
                        "repeatsLeft", rl - 1,
                        "emitted", lastEmitted
                    ));
            } else {
                sink.error(new IllegalStateException("repeats exhausted"));
            }
 }))
 </code></pre></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>repeatFactory</code> - the <code>Function</code> that returns the associated <code>Publisher</code>
 companion, given a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that signals each onComplete as a <code>Long</code>
 representing the number of source elements emitted in the latest attempt.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that repeats on onComplete when the companion <code>Publisher</code> produces an
 onNext signal</dd>
</dl>
</li>
</ul>
<a name="replay--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replay</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;replay()</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a hot source and cache last emitted signals for further <code>Subscriber</code>. Will
 retain an unbounded amount of onNext signals. Completion and Error will also be
 replayed.
 <p>
 <img class="marble" src="doc-files/marbles/replay.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a></dd>
</dl>
</li>
</ul>
<a name="replay-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replay</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;replay(int&nbsp;history)</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a connectable hot source and cache last emitted
 signals for further <code>Subscriber</code>.
 Will retain up to the given history size onNext signals. Completion and Error will also be
 replayed.
 <p>
     Note that <code>replay(0)</code> will only cache the terminal signal without
     expiration.

 <p>
     Re-connects are not supported.
 <p>
 <img class="marble" src="doc-files/marbles/replayWithHistory.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>history</code> - number of events retained in history excluding complete and
 error</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a></dd>
</dl>
</li>
</ul>
<a name="replay-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replay</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;replay(java.time.Duration&nbsp;ttl)</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a connectable hot source and cache last emitted signals
 for further <code>Subscriber</code>. Will retain each onNext up to the given per-item
 expiry timeout.
 <p>
   Completion and Error will also be replayed until <code>ttl</code> triggers in which case
   the next <code>Subscriber</code> will start over a new subscription

 <p>
 <img class="marble" src="doc-files/marbles/replayWithTtl.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>ttl</code> - Per-item and post termination timeout duration</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a></dd>
</dl>
</li>
</ul>
<a name="replay-int-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replay</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;replay(int&nbsp;history,
                                       java.time.Duration&nbsp;ttl)</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a connectable hot source and cache last emitted signals
 for further <code>Subscriber</code>. Will retain up to the given history size onNext
 signals with a per-item ttl.
 <p>
   Completion and Error will also be replayed until <code>ttl</code> triggers in which case
   the next <code>Subscriber</code> will start over a new subscription

 <p>
 <img class="marble" src="doc-files/marbles/replayWithHistoryAndTtl.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>history</code> - number of events retained in history excluding complete and error</dd>
<dd><code>ttl</code> - Per-item and post termination timeout duration</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a></dd>
</dl>
</li>
</ul>
<a name="replay-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replay</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;replay(java.time.Duration&nbsp;ttl,
                                       <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a connectable hot source and cache last emitted signals
 for further <code>Subscriber</code>. Will retain onNext signal for up to the given
 <code>Duration</code> with a per-item ttl.
 <p>
   Completion and Error will also be replayed until <code>ttl</code> triggers in which case
   the next <code>Subscriber</code> will start over a new subscription
 <p>
 <img class="marble" src="doc-files/marbles/replayWithTtl.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>ttl</code> - Per-item and post termination timeout duration</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to read current time from</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a></dd>
</dl>
</li>
</ul>
<a name="replay-int-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replay</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类">ConnectableFlux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;replay(int&nbsp;history,
                                       java.time.Duration&nbsp;ttl,
                                       <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Turn this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a connectable hot source and cache last emitted signals
 for further <code>Subscriber</code>. Will retain up to the given history size onNext
 signals with a per-item ttl.
 <p>
   Completion and Error will also be replayed until <code>ttl</code> triggers in which case
   the next <code>Subscriber</code> will start over a new subscription
 <p>
 <img class="marble" src="doc-files/marbles/replayWithHistoryAndTtl.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>history</code> - number of events retained in history excluding complete and error</dd>
<dd><code>ttl</code> - Per-item and post termination timeout duration</dd>
<dd><code>timer</code> - a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to read current time from</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a replaying <a href="../../../reactor/core/publisher/ConnectableFlux.html" title="reactor.core.publisher中的类"><code>ConnectableFlux</code></a></dd>
</dl>
</li>
</ul>
<a name="retry--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;retry()</pre>
<div class="block">Re-subscribes to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence if it signals any error, indefinitely.
 <p>
 <img class="marble" src="doc-files/marbles/retryForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that retries on onError</dd>
</dl>
</li>
</ul>
<a name="retry-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retry</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;retry(long&nbsp;numRetries)</pre>
<div class="block">Re-subscribes to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence if it signals any error, for a fixed
 number of times.
 <p>
 Note that passing Long.MAX_VALUE is treated as infinite retry.
 <p>
 <img class="marble" src="doc-files/marbles/retryWithAttemptsForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>numRetries</code> - the number of times to tolerate an error</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that retries on onError up to the specified number of retry attempts.</dd>
</dl>
</li>
</ul>
<a name="retryWhen-reactor.util.retry.Retry-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>retryWhen</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;retryWhen(<a href="../../../reactor/util/retry/Retry.html" title="reactor.util.retry中的类">Retry</a>&nbsp;retrySpec)</pre>
<div class="block">Retries this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> in response to signals emitted by a companion <code>Publisher</code>.
 The companion is generated by the provided <a href="../../../reactor/util/retry/Retry.html" title="reactor.util.retry中的类"><code>Retry</code></a> instance, see <a href="../../../reactor/util/retry/Retry.html#max-long-"><code>Retry.max(long)</code></a>, <a href="../../../reactor/util/retry/Retry.html#maxInARow-long-"><code>Retry.maxInARow(long)</code></a>
 and <a href="../../../reactor/util/retry/Retry.html#backoff-long-java.time.Duration-"><code>Retry.backoff(long, Duration)</code></a> for readily available strategy builders.
 <p>
 The operator generates a base for the companion, a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/util/retry/Retry.RetrySignal.html" title="reactor.util.retry中的接口"><code>Retry.RetrySignal</code></a>
 which each give metadata about each retryable failure whenever this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> signals an error. The final companion
 should be derived from that base companion and emit data in response to incoming onNext (although it can emit less
 elements, or delay the emissions).
 <p>
 Terminal signals in the companion terminate the sequence with the same signal, so emitting an <code>Subscriber.onError(Throwable)</code>
 will fail the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with that same error.
 <p>
 <img class="marble" src="doc-files/marbles/retryWhenSpecForFlux.svg" alt="">
 <p>
 Note that the <a href="../../../reactor/util/retry/Retry.RetrySignal.html" title="reactor.util.retry中的接口"><code>Retry.RetrySignal</code></a> state can be
 transient and change between each source
 <code>onError</code> or
 <code>onNext</code>. If processed with a delay,
 this could lead to the represented state being out of sync with the state at which the retry
 was evaluated. Map it to <a href="../../../reactor/util/retry/Retry.RetrySignal.html#copy--"><code>Retry.RetrySignal.copy()</code></a>
 right away to mediate this.
 <p>
 Note that if the companion <code>Publisher</code> created by the <code>whenFactory</code>
 emits <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> as trigger objects, these <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> will be merged with
 the previous Context:
 <blockquote><pre>
 <code>
 Retry customStrategy = Retry.from(companion -&gt; companion.handle((retrySignal, sink) -&gt; {
 	    Context ctx = sink.currentContext();
 	    int rl = ctx.getOrDefault("retriesLeft", 0);
 	    if (rl &gt; 0) {
		    sink.next(Context.of(
		        "retriesLeft", rl - 1,
		        "lastError", retrySignal.failure()
		    ));
 	    } else {
 	        sink.error(Exceptions.retryExhausted("retries exhausted", retrySignal.failure()));
 	    }
 }));
 Flux&lt;T&gt; retried = originalFlux.retryWhen(customStrategy);
 </code></pre>
 </blockquote></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>retrySpec</code> - the <a href="../../../reactor/util/retry/Retry.html" title="reactor.util.retry中的类"><code>Retry</code></a> strategy that will generate the companion <code>Publisher</code>,
 given a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that signals each onError as a <a href="../../../reactor/util/retry/Retry.RetrySignal.html" title="reactor.util.retry中的接口"><code>Retry.RetrySignal</code></a>.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that retries on onError when a companion <code>Publisher</code> produces an onNext signal</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/util/retry/Retry.html#max-long-"><code>Retry.max(long)</code></a>, 
<a href="../../../reactor/util/retry/Retry.html#maxInARow-long-"><code>Retry.maxInARow(long)</code></a>, 
<a href="../../../reactor/util/retry/Retry.html#backoff-long-java.time.Duration-"><code>Retry.backoff(long, Duration)</code></a></dd>
</dl>
</li>
</ul>
<a name="sample-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sample</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;sample(java.time.Duration&nbsp;timespan)</pre>
<div class="block">Sample this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by periodically emitting an item corresponding to that
 <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> latest emitted value within the periodical time window.
 Note that if some elements are emitted quicker than the timespan just before source
 completion, the last of these elements will be emitted along with the onComplete
 signal.

 <p>
 <img class="marble" src="doc-files/marbles/sampleAtRegularInterval.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are not part of the sampling.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timespan</code> - the duration of the window after which to emit the latest observed item</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sampled to the last item seen over each periodic window</dd>
</dl>
</li>
</ul>
<a name="sample-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sample</h4>
<pre>public final&nbsp;&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;sample(org.reactivestreams.Publisher&lt;U&gt;&nbsp;sampler)</pre>
<div class="block">Sample this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by emitting an item corresponding to that <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 latest emitted value whenever a companion sampler <code>Publisher</code> signals a value.
 <p>
 Termination of either <code>Publisher</code> will result in termination for the <code>Subscriber</code>
 as well.
 Note that if some elements are emitted just before source completion and before a
 last sampler can trigger, the last of these elements will be emitted along with the
 onComplete signal.
 <p>
 Both <code>Publisher</code> will run in unbounded mode because the backpressure
 would interfere with the sampling precision.

 <p>
 <img class="marble" src="doc-files/marbles/sampleWithSampler.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are not part of the sampling.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the type of the sampler sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sampler</code> - the sampler companion <code>Publisher</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sampled to the last item observed each time the sampler <code>Publisher</code> signals</dd>
</dl>
</li>
</ul>
<a name="sampleFirst-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sampleFirst</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;sampleFirst(java.time.Duration&nbsp;timespan)</pre>
<div class="block">Repeatedly take a value from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> then skip the values that follow
 within a given duration.

 <p>
 <img class="marble" src="doc-files/marbles/sampleFirstAtRegularInterval.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are not part of the sampling.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timespan</code> - the duration during which to skip values after each sample</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sampled to the first item of each duration-based window</dd>
</dl>
</li>
</ul>
<a name="sampleFirst-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sampleFirst</h4>
<pre>public final&nbsp;&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;sampleFirst(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;U&gt;&gt;&nbsp;samplerFactory)</pre>
<div class="block">Repeatedly take a value from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> then skip the values that follow
 before the next signal from a companion sampler <code>Publisher</code>.

 <p>
 <img class="marble" src="doc-files/marbles/sampleFirstWithSamplerFactory.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are not part of the sampling.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the companion reified type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>samplerFactory</code> - supply a companion sampler <code>Publisher</code> which signals the end of the skip window</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sampled to the first item observed in each window closed by the sampler signals</dd>
</dl>
</li>
</ul>
<a name="sampleTimeout-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sampleTimeout</h4>
<pre>public final&nbsp;&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;sampleTimeout(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;U&gt;&gt;&nbsp;throttlerFactory)</pre>
<div class="block">Emit the latest value from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> only if there were no new values emitted
 during the window defined by a companion <code>Publisher</code> derived from that particular
 value.
 <p>
 Note that this means that the last value in the sequence is always emitted.

 <p>
 <img class="marble" src="doc-files/marbles/sampleTimeoutWithThrottlerFactory.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are not part of the sampling.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the companion reified type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>throttlerFactory</code> - supply a companion sampler <code>Publisher</code> which signals
 the end of the window during which no new emission should occur. If it is the case,
 the original value triggering the window is emitted.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sampled to items not followed by any other item within a window
 defined by a companion <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="sampleTimeout-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sampleTimeout</h4>
<pre>public final&nbsp;&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;sampleTimeout(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;U&gt;&gt;&nbsp;throttlerFactory,
                                       int&nbsp;maxConcurrency)</pre>
<div class="block">Emit the latest value from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> only if there were no new values emitted
 during the window defined by a companion <code>Publisher</code> derived from that particular
 value.
 <p>The provided maxConcurrency will keep a bounded maximum of concurrent timeouts and drop any new
 items until at least one timeout terminates.
 <p>
 Note that this means that the last value in the sequence is always emitted.

 <p>
 <img class="marble" src="doc-files/marbles/sampleTimeoutWithThrottlerFactoryAndMaxConcurrency.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are not part of the sampling.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the throttling type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>throttlerFactory</code> - supply a companion sampler <code>Publisher</code> which signals
 the end of the window during which no new emission should occur. If it is the case,
 the original value triggering the window is emitted.</dd>
<dd><code>maxConcurrency</code> - the maximum number of concurrent timeouts</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sampled to items not followed by any other item within a window
 defined by a companion <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="scan-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scan</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;scan(java.util.function.BiFunction&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;accumulator)</pre>
<div class="block">Reduce this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> values with an accumulator <code>BiFunction</code> and
 also emit the intermediate results of this function.
 <p>
 Unlike <a href="../../../reactor/core/publisher/Flux.html#scan-A-java.util.function.BiFunction-"><code>scan(Object, BiFunction)</code></a>, this operator doesn't take an initial value
 but treats the first <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> value as initial value.
 <br>
 The accumulation works as follows:
 <pre><code>
 result[0] = source[0]
 result[1] = accumulator(result[0], source[1])
 result[2] = accumulator(result[1], source[2])
 result[3] = accumulator(result[2], source[3])
 ...
 </code></pre>

 <p>
 <img class="marble" src="doc-files/marbles/scanWithSameReturnType.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>accumulator</code> - the accumulating <code>BiFunction</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an accumulating <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="scan-java.lang.Object-java.util.function.BiFunction-">
<!--   -->
</a><a name="scan-A-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scan</h4>
<pre>public final&nbsp;&lt;A&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;A&gt;&nbsp;scan(A&nbsp;initial,
                              java.util.function.BiFunction&lt;A,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,A&gt;&nbsp;accumulator)</pre>
<div class="block">Reduce this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> values with an accumulator <code>BiFunction</code> and
 also emit the intermediate results of this function.
 <p>
 The accumulation works as follows:
 <pre><code>
 result[0] = initialValue;
 result[1] = accumulator(result[0], source[0])
 result[2] = accumulator(result[1], source[1])
 result[3] = accumulator(result[2], source[2])
 ...
 </code></pre>

 <p>
 <img class="marble" src="doc-files/marbles/scan.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>A</code> - the accumulated type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>initial</code> - the initial leftmost argument to pass to the reduce function</dd>
<dd><code>accumulator</code> - the accumulating <code>BiFunction</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an accumulating <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> starting with initial state</dd>
</dl>
</li>
</ul>
<a name="scanWith-java.util.function.Supplier-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>scanWith</h4>
<pre>public final&nbsp;&lt;A&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;A&gt;&nbsp;scanWith(java.util.function.Supplier&lt;A&gt;&nbsp;initial,
                                  java.util.function.BiFunction&lt;A,? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,A&gt;&nbsp;accumulator)</pre>
<div class="block">Reduce this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> values with the help of an accumulator <code>BiFunction</code>
 and also emits the intermediate results. A seed value is lazily provided by a
 <code>Supplier</code> invoked for each <code>Subscriber</code>.
 <p>
 The accumulation works as follows:
 <pre><code>
 result[0] = initialValue;
 result[1] = accumulator(result[0], source[0])
 result[2] = accumulator(result[1], source[1])
 result[3] = accumulator(result[2], source[2])
 ...
 </code></pre>

 <p>
 <img class="marble" src="doc-files/marbles/scanWith.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>A</code> - the accumulated type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>initial</code> - the supplier providing the seed, the leftmost parameter initially
 passed to the reduce function</dd>
<dd><code>accumulator</code> - the accumulating <code>BiFunction</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>an accumulating <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> starting with initial state</dd>
</dl>
</li>
</ul>
<a name="share--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>share</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;share()</pre>
<div class="block">Returns a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that multicasts (shares) the original <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.
 As long as there is at least one <code>Subscriber</code> this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> will be subscribed and
 emitting data.
 When all subscribers have cancelled it will cancel the source
 <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.
 <p>This is an alias for <a href="../../../reactor/core/publisher/Flux.html#publish--"><code>publish()</code></a>.<a href="../../../reactor/core/publisher/ConnectableFlux.html#refCount--"><code>ConnectableFlux.refCount()</code></a>.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that upon first subscribe causes the source <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 to subscribe once, late subscribers might therefore miss items.</dd>
</dl>
</li>
</ul>
<a name="shareNext--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>shareNext</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;shareNext()</pre>
<div class="block">Prepare a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> which shares this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence and dispatches the
 first observed item to subscribers.
 This will effectively turn any type of sequence into a hot sequence when the first
 <code>Subscriber</code> subscribes.
 <p>
 <img class="marble" src="doc-files/marbles/shareNext.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a></dd>
</dl>
</li>
</ul>
<a name="single--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>single</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;single()</pre>
<div class="block">Expect and emit a single item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> source or signal
 <code>NoSuchElementException</code> for an empty source, or
 <code>IndexOutOfBoundsException</code> for a source with more than one element.

 <p>
 <img class="marble" src="doc-files/marbles/singleForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> with the single item or an error signal</dd>
</dl>
</li>
</ul>
<a name="single-java.lang.Object-">
<!--   -->
</a><a name="single-T-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>single</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;single(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&nbsp;defaultValue)</pre>
<div class="block">Expect and emit a single item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> source and emit a default
 value for an empty source, but signal an <code>IndexOutOfBoundsException</code> for a
 source with more than one element.

 <p>
 <img class="marble" src="doc-files/marbles/singleWithDefault.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>defaultValue</code> - a single fallback item if this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is empty</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> with the expected single item, the supplied default value or
 an error signal</dd>
</dl>
</li>
</ul>
<a name="singleOrEmpty--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>singleOrEmpty</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;singleOrEmpty()</pre>
<div class="block">Expect and emit a single item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> source, and accept an empty
 source but signal an <code>IndexOutOfBoundsException</code> for a source with more than
 one element.
 <p>
 <img class="marble" src="doc-files/marbles/singleOrEmpty.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> with the expected single item, no item or an error</dd>
</dl>
</li>
</ul>
<a name="skip-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skip</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;skip(long&nbsp;skipped)</pre>
<div class="block">Skip the specified number of elements from the beginning of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> then
 emit the remaining elements.

 <p>
 <img class="marble" src="doc-files/marbles/skip.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are skipped.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>skipped</code> - the number of elements to drop</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a dropping <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the specified number of elements skipped at
 the beginning</dd>
</dl>
</li>
</ul>
<a name="skip-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skip</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;skip(java.time.Duration&nbsp;timespan)</pre>
<div class="block">Skip elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitted within the specified initial duration.

 <p>
 <img class="marble" src="doc-files/marbles/skipWithTimespan.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are skipped.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timespan</code> - the initial time window during which to drop elements</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> dropping at the beginning until the end of the given duration</dd>
</dl>
</li>
</ul>
<a name="skip-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skip</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;skip(java.time.Duration&nbsp;timespan,
                          <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Skip elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitted within the specified initial duration,
 as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/skipWithTimespan.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are skipped.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timespan</code> - the initial time window during which to drop elements</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to measure the time window on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> dropping at the beginning for the given duration</dd>
</dl>
</li>
</ul>
<a name="skipLast-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skipLast</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;skipLast(int&nbsp;n)</pre>
<div class="block">Skip a specified number of elements at the end of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence.

 <p>
 <img class="marble" src="doc-files/marbles/skipLast.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are skipped.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>n</code> - the number of elements to drop before completion</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> dropping the specified number of elements at the end of the
 sequence</dd>
</dl>
</li>
</ul>
<a name="skipUntil-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skipUntil</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;skipUntil(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;untilPredicate)</pre>
<div class="block">Skips values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until a <code>Predicate</code> returns true for the
 value. The resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> will include and emit the matching value.

 <p>
 <img class="marble" src="doc-files/marbles/skipUntil.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are skipped.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>untilPredicate</code> - the <code>Predicate</code> evaluated to stop skipping.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> dropping until the <code>Predicate</code> matches</dd>
</dl>
</li>
</ul>
<a name="skipUntilOther-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skipUntilOther</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;skipUntilOther(org.reactivestreams.Publisher&lt;?&gt;&nbsp;other)</pre>
<div class="block">Skip values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until a specified <code>Publisher</code> signals
 an onNext or onComplete.

 <p>
 <img class="marble" src="doc-files/marbles/skipUntilOther.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are skipped.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the companion <code>Publisher</code> to coordinate with to stop skipping</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> dropping until the other <code>Publisher</code> emits</dd>
</dl>
</li>
</ul>
<a name="skipWhile-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skipWhile</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;skipWhile(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;skipPredicate)</pre>
<div class="block">Skips values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> while a <code>Predicate</code> returns true for the value.

 <p>
 <img class="marble" src="doc-files/marbles/skipWhile.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements that are skipped.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>skipPredicate</code> - the <code>Predicate</code> that causes skipping while evaluating to true.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> dropping while the <code>Predicate</code> matches</dd>
</dl>
</li>
</ul>
<a name="sort--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sort</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;sort()</pre>
<div class="block">Sort elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> by collecting and sorting them in the background
 then emitting the sorted sequence once this sequence completes.
 Each item emitted by the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> must implement <code>Comparable</code> with
 respect to all other items in the sequence.

 <p>Note that calling <code>sort</code> with long, non-terminating or infinite sources
 might cause <code>OutOfMemoryError</code>. Use sequence splitting like <a href="../../../reactor/core/publisher/Flux.html#window-int-"><code>window(int)</code></a> to sort batches in that case.
 <p>
 <img class="marble" src="doc-files/marbles/sort.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a sorted <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="throwsLabel">抛出:</span></dt>
<dd><code>java.lang.ClassCastException</code> - if any item emitted by the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> does not implement
 <code>Comparable</code> with respect to all other items emitted by the <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="sort-java.util.Comparator-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sort</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;sort(java.util.Comparator&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;sortFunction)</pre>
<div class="block">Sort elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> using a <code>Comparator</code> function, by
 collecting and sorting elements in the background then emitting the sorted sequence
 once this sequence completes.

 <p>Note that calling <code>sort</code> with long, non-terminating or infinite sources
 might cause <code>OutOfMemoryError</code>
 <p>
 <img class="marble" src="doc-files/marbles/sort.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>sortFunction</code> - a function that compares two items emitted by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 to indicate their sort order</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a sorted <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="startWith-java.lang.Iterable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startWith</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;startWith(java.lang.Iterable&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;iterable)</pre>
<div class="block">Prepend the given <code>Iterable</code> before this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence.

 <p>
 <img class="marble" src="doc-files/marbles/startWithIterable.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>iterable</code> - the sequence of values to start the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> prefixed with elements from an <code>Iterable</code></dd>
</dl>
</li>
</ul>
<a name="startWith-java.lang.Object:A-">
<!--   -->
</a><a name="startWith-T...-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startWith</h4>
<pre>@SafeVarargs
public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;startWith(<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>...&nbsp;values)</pre>
<div class="block">Prepend the given values before this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence.

 <p>
 <img class="marble" src="doc-files/marbles/startWithValues.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>values</code> - the array of values to start the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> prefixed with the given elements</dd>
</dl>
</li>
</ul>
<a name="startWith-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>startWith</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;startWith(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;publisher)</pre>
<div class="block">Prepend the given <code>Publisher</code> sequence to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence.

 <p>
 <img class="marble" src="doc-files/marbles/startWithPublisher.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>publisher</code> - the Publisher whose values to prepend</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> prefixed with the given <code>Publisher</code> sequence</dd>
</dl>
</li>
</ul>
<a name="subscribe--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a>&nbsp;subscribe()</pre>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and request unbounded demand.
 <p>
 This version doesn't specify any consumption behavior for the events from the
 chain, especially no error handling, so other variants should usually be preferred.

 <p>
 <img class="marble" src="doc-files/marbles/subscribeIgoringAllSignalsForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口"><code>Disposable</code></a> that can be used to cancel the underlying <code>Subscription</code></dd>
</dl>
</li>
</ul>
<a name="subscribe-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a>&nbsp;subscribe(java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;consumer)</pre>
<div class="block">Subscribe a <code>Consumer</code> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will consume all the
 elements in the  sequence. It will request an unbounded demand (<code>Long.MAX_VALUE</code>).
 <p>
 For a passive version that observe and forward incoming data see <a href="../../../reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-"><code>doOnNext(java.util.function.Consumer)</code></a>.
 <p>
 For a version that gives you more control over backpressure and the request, see
 <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscribe(Subscriber)</code></a> with a <a href="../../../reactor/core/publisher/BaseSubscriber.html" title="reactor.core.publisher中的类"><code>BaseSubscriber</code></a>.
 <p>
 Keep in mind that since the sequence can be asynchronous, this will immediately
 return control to the calling thread. This can give the impression the consumer is
 not invoked when executing in a main thread or a unit test for instance.

 <p>
 <img class="marble" src="doc-files/marbles/subscribeWithOnNextForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>consumer</code> - the consumer to invoke on each value (onNext signal)</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口"><code>Disposable</code></a> that can be used to cancel the underlying <code>Subscription</code></dd>
</dl>
</li>
</ul>
<a name="subscribe-java.util.function.Consumer-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a>&nbsp;subscribe(<a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                  java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;consumer,
                                  java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;errorConsumer)</pre>
<div class="block">Subscribe to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with a <code>Consumer</code> that will consume all the
 elements in the sequence, as well as a <code>Consumer</code> that will handle errors.
 The subscription will request an unbounded demand (<code>Long.MAX_VALUE</code>).
 <p>
 For a passive version that observe and forward incoming data see
 <a href="../../../reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-"><code>doOnNext(java.util.function.Consumer)</code></a> and <a href="../../../reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-"><code>doOnError(java.util.function.Consumer)</code></a>.
 <p>For a version that gives you more control over backpressure and the request, see
 <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscribe(Subscriber)</code></a> with a <a href="../../../reactor/core/publisher/BaseSubscriber.html" title="reactor.core.publisher中的类"><code>BaseSubscriber</code></a>.
 <p>
 Keep in mind that since the sequence can be asynchronous, this will immediately
 return control to the calling thread. This can give the impression the consumers are
 not invoked when executing in a main thread or a unit test for instance.

 <p>
 <img class="marble" src="doc-files/marbles/subscribeWithOnNextAndOnErrorForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>consumer</code> - the consumer to invoke on each next signal</dd>
<dd><code>errorConsumer</code> - the consumer to invoke on error signal</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口"><code>Disposable</code></a> that can be used to cancel the underlying <code>Subscription</code></dd>
</dl>
</li>
</ul>
<a name="subscribe-java.util.function.Consumer-java.util.function.Consumer-java.lang.Runnable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a>&nbsp;subscribe(<a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                  java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;consumer,
                                  <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                  java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;errorConsumer,
                                  <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                  java.lang.Runnable&nbsp;completeConsumer)</pre>
<div class="block">Subscribe <code>Consumer</code> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will respectively consume all the
 elements in the sequence, handle errors and react to completion. The subscription
 will request unbounded demand (<code>Long.MAX_VALUE</code>).
 <p>
 For a passive version that observe and forward incoming data see <a href="../../../reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-"><code>doOnNext(java.util.function.Consumer)</code></a>,
 <a href="../../../reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-"><code>doOnError(java.util.function.Consumer)</code></a> and <a href="../../../reactor/core/publisher/Flux.html#doOnComplete-java.lang.Runnable-"><code>doOnComplete(Runnable)</code></a>.
 <p>For a version that gives you more control over backpressure and the request, see
 <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscribe(Subscriber)</code></a> with a <a href="../../../reactor/core/publisher/BaseSubscriber.html" title="reactor.core.publisher中的类"><code>BaseSubscriber</code></a>.
 <p>
 Keep in mind that since the sequence can be asynchronous, this will immediately
 return control to the calling thread. This can give the impression the consumer is
 not invoked when executing in a main thread or a unit test for instance.

 <p>
 <img class="marble" src="doc-files/marbles/subscribeWithOnNextAndOnErrorAndOnCompleteForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>consumer</code> - the consumer to invoke on each value</dd>
<dd><code>errorConsumer</code> - the consumer to invoke on error signal</dd>
<dd><code>completeConsumer</code> - the consumer to invoke on complete signal</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口"><code>Disposable</code></a> that can be used to cancel the underlying <code>Subscription</code></dd>
</dl>
</li>
</ul>
<a name="subscribe-java.util.function.Consumer-java.util.function.Consumer-java.lang.Runnable-java.util.function.Consumer-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre>@Deprecated
public final&nbsp;<a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a>&nbsp;subscribe(<a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                               java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;consumer,
                                               <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                               java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;errorConsumer,
                                               <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                               java.lang.Runnable&nbsp;completeConsumer,
                                               <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                               java.util.function.Consumer&lt;? super org.reactivestreams.Subscription&gt;&nbsp;subscriptionConsumer)</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">Because users tend to forget to <code>request</code> the subsciption. If
 the behavior is really needed, consider using <a href="../../../reactor/core/publisher/Flux.html#subscribeWith-E-"><code>subscribeWith(Subscriber)</code></a>. To be removed in 3.5.</span></div>
<div class="block">Subscribe <code>Consumer</code> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will respectively consume all the
 elements in the sequence, handle errors, react to completion, and request upon subscription.
 It will let the provided <code>subscriptionConsumer</code>
 request the adequate amount of data, or request unbounded demand
 <code>Long.MAX_VALUE</code> if no such consumer is provided.
 <p>
 For a passive version that observe and forward incoming data see <a href="../../../reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-"><code>doOnNext(java.util.function.Consumer)</code></a>,
 <a href="../../../reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-"><code>doOnError(java.util.function.Consumer)</code></a>, <a href="../../../reactor/core/publisher/Flux.html#doOnComplete-java.lang.Runnable-"><code>doOnComplete(Runnable)</code></a>
 and <a href="../../../reactor/core/publisher/Flux.html#doOnSubscribe-java.util.function.Consumer-"><code>doOnSubscribe(Consumer)</code></a>.
 <p>For a version that gives you more control over backpressure and the request, see
 <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscribe(Subscriber)</code></a> with a <a href="../../../reactor/core/publisher/BaseSubscriber.html" title="reactor.core.publisher中的类"><code>BaseSubscriber</code></a>.
 <p>
 Keep in mind that since the sequence can be asynchronous, this will immediately
 return control to the calling thread. This can give the impression the consumer is
 not invoked when executing in a main thread or a unit test for instance.

 <p>
 <img class="marble" src="doc-files/marbles/subscribeForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>consumer</code> - the consumer to invoke on each value</dd>
<dd><code>errorConsumer</code> - the consumer to invoke on error signal</dd>
<dd><code>completeConsumer</code> - the consumer to invoke on complete signal</dd>
<dd><code>subscriptionConsumer</code> - the consumer to invoke on subscribe signal, to be used
 for the initial <code>request</code>, or null for max request</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口"><code>Disposable</code></a> that can be used to cancel the underlying <code>Subscription</code></dd>
</dl>
</li>
</ul>
<a name="subscribe-java.util.function.Consumer-java.util.function.Consumer-java.lang.Runnable-reactor.util.context.Context-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口">Disposable</a>&nbsp;subscribe(<a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                  java.util.function.Consumer&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;consumer,
                                  <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                  java.util.function.Consumer&lt;? super java.lang.Throwable&gt;&nbsp;errorConsumer,
                                  <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                  java.lang.Runnable&nbsp;completeConsumer,
                                  <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                  <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口">Context</a>&nbsp;initialContext)</pre>
<div class="block">Subscribe <code>Consumer</code> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will respectively consume all the
 elements in the sequence, handle errors and react to completion. Additionally, a <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a>
 is tied to the subscription. At subscription, an unbounded request is implicitly made.
 <p>
 For a passive version that observe and forward incoming data see <a href="../../../reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-"><code>doOnNext(java.util.function.Consumer)</code></a>,
 <a href="../../../reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-"><code>doOnError(java.util.function.Consumer)</code></a>, <a href="../../../reactor/core/publisher/Flux.html#doOnComplete-java.lang.Runnable-"><code>doOnComplete(Runnable)</code></a>
 and <a href="../../../reactor/core/publisher/Flux.html#doOnSubscribe-java.util.function.Consumer-"><code>doOnSubscribe(Consumer)</code></a>.
 <p>For a version that gives you more control over backpressure and the request, see
 <a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscribe(Subscriber)</code></a> with a <a href="../../../reactor/core/publisher/BaseSubscriber.html" title="reactor.core.publisher中的类"><code>BaseSubscriber</code></a>.
 <p>
 Keep in mind that since the sequence can be asynchronous, this will immediately
 return control to the calling thread. This can give the impression the consumer is
 not invoked when executing in a main thread or a unit test for instance.

 <p>
 <img class="marble" src="doc-files/marbles/subscribeForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>consumer</code> - the consumer to invoke on each value</dd>
<dd><code>errorConsumer</code> - the consumer to invoke on error signal</dd>
<dd><code>completeConsumer</code> - the consumer to invoke on complete signal</dd>
<dd><code>initialContext</code> - the base <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> tied to the subscription that will
 be visible to operators upstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/Disposable.html" title="reactor.core中的接口"><code>Disposable</code></a> that can be used to cancel the underlying <code>Subscription</code></dd>
</dl>
</li>
</ul>
<a name="subscribe-org.reactivestreams.Subscriber-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre>public final&nbsp;void&nbsp;subscribe(org.reactivestreams.Subscriber&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;actual)</pre>
<dl>
<dt><span class="overrideSpecifyLabel">指定者:</span></dt>
<dd><code>subscribe</code>&nbsp;在接口中&nbsp;<code>org.reactivestreams.Publisher&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></dd>
</dl>
</li>
</ul>
<a name="subscribe-reactor.core.CoreSubscriber-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribe</h4>
<pre>public abstract&nbsp;void&nbsp;subscribe(<a href="../../../reactor/core/CoreSubscriber.html" title="reactor.core中的接口">CoreSubscriber</a>&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;actual)</pre>
<div class="block">An internal <code>Publisher.subscribe(Subscriber)</code> that will bypass
 <a href="../../../reactor/core/publisher/Hooks.html#onLastOperator-java.util.function.Function-"><code>Hooks.onLastOperator(Function)</code></a> pointcut.
 <p>
 In addition to behave as expected by <code>Publisher.subscribe(Subscriber)</code>
 in a controlled manner, it supports direct subscribe-time <a href="../../../reactor/util/context/Context.html" title="reactor.util.context中的接口"><code>Context</code></a> passing.</div>
<dl>
<dt><span class="overrideSpecifyLabel">指定者:</span></dt>
<dd><code><a href="../../../reactor/core/CorePublisher.html#subscribe-reactor.core.CoreSubscriber-">subscribe</a></code>&nbsp;在接口中&nbsp;<code><a href="../../../reactor/core/CorePublisher.html" title="reactor.core中的接口">CorePublisher</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>actual</code> - the <code>Subscriber</code> interested into the published sequence</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#subscribe-org.reactivestreams.Subscriber-"><code>subscribe(Subscriber)</code></a></dd>
</dl>
</li>
</ul>
<a name="subscribeOn-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeOn</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;subscribeOn(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</pre>
<div class="block">Run subscribe, onSubscribe and request on a specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>'s <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a>.
 As such, placing this operator anywhere in the chain will also impact the execution
 context of onNext/onError/onComplete signals from the beginning of the chain up to
 the next occurrence of a <a href="../../../reactor/core/publisher/Flux.html#publishOn-reactor.core.scheduler.Scheduler-"><code>publishOn</code></a>.
 <p>
 Note that if you are using an eager or blocking
 <a href="../../../reactor/core/publisher/Flux.html#create-java.util.function.Consumer-reactor.core.publisher.FluxSink.OverflowStrategy-"><code>create(Consumer, FluxSink.OverflowStrategy)</code></a>
 as the source, it can lead to deadlocks due to requests piling up behind the emitter.
 In such case, you should call <a href="../../../reactor/core/publisher/Flux.html#subscribeOn-reactor.core.scheduler.Scheduler-boolean-"><code>subscribeOn(scheduler, false)</code></a>
 instead.
 <p>
 <img class="marble" src="doc-files/marbles/subscribeOnForFlux.svg" alt="">
 <p>
 Typically used for slow publisher e.g., blocking IO, fast consumer(s) scenarios.

 <blockquote><pre>
 <code> flux.subscribeOn(Schedulers.single()).subscribe() </code>
 </pre></blockquote>

 <p>
     Note that <a href="../../../reactor/core/scheduler/Scheduler.Worker.html#schedule-java.lang.Runnable-"><code>Scheduler.Worker.schedule(Runnable)</code></a> raising
     <code>RejectedExecutionException</code> on late
     <code>Subscription.request(long)</code> will be propagated to the request caller.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>scheduler</code> - a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> providing the <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> where to subscribe</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> requesting asynchronously</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#publishOn-reactor.core.scheduler.Scheduler-"><code>publishOn(Scheduler)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#subscribeOn-reactor.core.scheduler.Scheduler-boolean-"><code>subscribeOn(Scheduler, boolean)</code></a></dd>
</dl>
</li>
</ul>
<a name="subscribeOn-reactor.core.scheduler.Scheduler-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeOn</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;subscribeOn(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler,
                                 boolean&nbsp;requestOnSeparateThread)</pre>
<div class="block">Run subscribe and onSubscribe on a specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>'s <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a>.
 Request will be run on that worker too depending on the <code>requestOnSeparateThread</code>
 parameter (which defaults to true in the <a href="../../../reactor/core/publisher/Flux.html#subscribeOn-reactor.core.scheduler.Scheduler-"><code>subscribeOn(Scheduler)</code></a> version).
 As such, placing this operator anywhere in the chain will also impact the execution
 context of onNext/onError/onComplete signals from the beginning of the chain up to
 the next occurrence of a <a href="../../../reactor/core/publisher/Flux.html#publishOn-reactor.core.scheduler.Scheduler-"><code>publishOn</code></a>.
 <p>
 Note that if you are using an eager or blocking
 <a href="../../../reactor/core/publisher/Flux.html#create-java.util.function.Consumer-reactor.core.publisher.FluxSink.OverflowStrategy-"><code>create(Consumer, FluxSink.OverflowStrategy)</code></a>
 as the source, it can lead to deadlocks due to requests piling up behind the emitter.
 Thus this operator has a <code>requestOnSeparateThread</code> parameter, which should be
 set to <code>false</code> in this case.
 <p>
 <img class="marble" src="doc-files/marbles/subscribeOnForFlux.svg" alt="">
 <p>
 Typically used for slow publisher e.g., blocking IO, fast consumer(s) scenarios.

 <blockquote><pre>
 <code> flux.subscribeOn(Schedulers.single()).subscribe() </code>
 </pre></blockquote>

 <p>
     Note that <a href="../../../reactor/core/scheduler/Scheduler.Worker.html#schedule-java.lang.Runnable-"><code>Scheduler.Worker.schedule(Runnable)</code></a> raising
     <code>RejectedExecutionException</code> on late
     <code>Subscription.request(long)</code> will be propagated to the request caller.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>scheduler</code> - a <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> providing the <a href="../../../reactor/core/scheduler/Scheduler.Worker.html" title="reactor.core.scheduler中的接口"><code>Scheduler.Worker</code></a> where to subscribe</dd>
<dd><code>requestOnSeparateThread</code> - whether or not to also perform requests on the worker.
 <code>true</code> to behave like <a href="../../../reactor/core/publisher/Flux.html#subscribeOn-reactor.core.scheduler.Scheduler-"><code>subscribeOn(Scheduler)</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> requesting asynchronously</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#publishOn-reactor.core.scheduler.Scheduler-"><code>publishOn(Scheduler)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#subscribeOn-reactor.core.scheduler.Scheduler-"><code>subscribeOn(Scheduler)</code></a></dd>
</dl>
</li>
</ul>
<a name="subscribeWith-org.reactivestreams.Subscriber-">
<!--   -->
</a><a name="subscribeWith-E-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>subscribeWith</h4>
<pre>public final&nbsp;&lt;E extends org.reactivestreams.Subscriber&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;E&nbsp;subscribeWith(E&nbsp;subscriber)</pre>
<div class="block">Subscribe a provided instance of a subclass of <code>Subscriber</code> to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 and return said instance for further chaining calls. This is similar to <a href="../../../reactor/core/publisher/Flux.html#as-java.util.function.Function-"><code>as(Function)</code></a>,
 except a subscription is explicitly performed by this method.
 <p>
 If you need more control over backpressure and the request, use a <a href="../../../reactor/core/publisher/BaseSubscriber.html" title="reactor.core.publisher中的类"><code>BaseSubscriber</code></a>.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>E</code> - the reified type from the input/output subscriber</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>subscriber</code> - the <code>Subscriber</code> to subscribe with and return</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the passed <code>Subscriber</code></dd>
</dl>
</li>
</ul>
<a name="switchOnFirst-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>switchOnFirst</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;switchOnFirst(java.util.function.BiFunction&lt;<a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口">Signal</a>&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;transformer)</pre>
<div class="block">Transform the current <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> once it emits its first element, making a
 conditional transformation possible. This operator first requests one element
 from the source then applies a transformation derived from the first <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a>
 and the source. The whole source (including the first signal) is passed as second
 argument to the <code>BiFunction</code> and it is very strongly advised to always build
 upon with operators (see below).
 <p>
 Note that the source might complete or error immediately instead of emitting,
 in which case the <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a> would be onComplete or onError. It is NOT
 necessarily an onNext Signal, and must be checked accordingly.
 <p>
 For example, this operator could be used to define a dynamic transformation that depends
 on the first element (which could contain routing metadata for instance):

 <blockquote><pre>
 <code>
  fluxOfIntegers.switchOnFirst((signal, flux) -&gt; {
      if (signal.hasValue()) {
          ColoredShape firstColor = signal.get();
          return flux.filter(v -&gt; !v.hasSameColorAs(firstColor))
      }
      return flux; //either early complete or error, this forwards the termination in any case
      //`return flux.onErrorResume(t -&gt; Mono.empty());` instead would suppress an early error
      //`return Flux.just(1,2,3);` instead would suppress an early error and return 1, 2, 3.
      //It would also only cancel the original `flux` at the completion of `just`.
  })
 </code>
 </pre></blockquote>
 <p>
 <img class="marble" src="doc-files/marbles/switchOnFirst.svg" alt="">
 <p>
 It is advised to return a <code>Publisher</code> derived from the original <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 in all cases, as not doing so would keep the original <code>Publisher</code> open and
 hanging with a single request until the inner <code>Publisher</code> terminates or
 the whole <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is cancelled.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the item type in the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>transformer</code> - A <code>BiFunction</code> executed once the first signal is
 available and used to transform the source conditionally. The whole source (including
 first signal) is passed as second argument to the BiFunction.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that transform the upstream once a signal is available</dd>
</dl>
</li>
</ul>
<a name="switchOnFirst-java.util.function.BiFunction-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>switchOnFirst</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;switchOnFirst(java.util.function.BiFunction&lt;<a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口">Signal</a>&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;transformer,
                                       boolean&nbsp;cancelSourceOnComplete)</pre>
<div class="block">Transform the current <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> once it emits its first element, making a
 conditional transformation possible. This operator first requests one element
 from the source then applies a transformation derived from the first <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a>
 and the source. The whole source (including the first signal) is passed as second
 argument to the <code>BiFunction</code> and it is very strongly advised to always build
 upon with operators (see below).
 <p>
 Note that the source might complete or error immediately instead of emitting,
 in which case the <a href="../../../reactor/core/publisher/Signal.html" title="reactor.core.publisher中的接口"><code>Signal</code></a> would be onComplete or onError. It is NOT
 necessarily an onNext Signal, and must be checked accordingly.
 <p>
 For example, this operator could be used to define a dynamic transformation that depends
 on the first element (which could contain routing metadata for instance):

 <blockquote><pre>
 <code>
  fluxOfIntegers.switchOnFirst((signal, flux) -&gt; {
      if (signal.hasValue()) {
          ColoredShape firstColor = signal.get();
          return flux.filter(v -&gt; !v.hasSameColorAs(firstColor))
      }
      return flux; //either early complete or error, this forwards the termination in any case
      //`return flux.onErrorResume(t -&gt; Mono.empty());` instead would suppress an early error
      //`return Flux.just(1,2,3);` instead would suppress an early error and return 1, 2, 3.
      //It would also only cancel the original `flux` at the completion of `just`.
  })
 </code>
 </pre></blockquote>
 <p>
 <img class="marble" src="doc-files/marbles/switchOnFirst.svg" alt="">
 <p>
 It is advised to return a <code>Publisher</code> derived from the original <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 in all cases, as not doing so would keep the original <code>Publisher</code> open and
 hanging with a single request. In case the value of the <code>cancelSourceOnComplete</code> parameter is <code>true</code> the original publisher until the inner <code>Publisher</code> terminates or
 the whole <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> is cancelled. Otherwise the original publisher will hang forever.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the item type in the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>transformer</code> - A <code>BiFunction</code> executed once the first signal is
 available and used to transform the source conditionally. The whole source (including
 first signal) is passed as second argument to the BiFunction.</dd>
<dd><code>cancelSourceOnComplete</code> - specify whether original publisher should be cancelled on <code>onComplete</code> from the derived one</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that transform the upstream once a signal is available</dd>
</dl>
</li>
</ul>
<a name="switchIfEmpty-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>switchIfEmpty</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;switchIfEmpty(org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;alternate)</pre>
<div class="block">Switch to an alternative <code>Publisher</code> if this sequence is completed without any data.
 <p>
 <img class="marble" src="doc-files/marbles/switchIfEmptyForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>alternate</code> - the alternative <code>Publisher</code> if this sequence is empty</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that falls back on a <code>Publisher</code> if source is empty</dd>
</dl>
</li>
</ul>
<a name="switchMap-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>switchMap</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;switchMap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;fn)</pre>
<div class="block">Switch to a new <code>Publisher</code> generated via a <code>Function</code> whenever
 this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> produces an item. As such, the elements from each generated
 Publisher are emitted in the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/switchMap.svg" alt="">
 <p>
 This operator requests the source for an unbounded amount, but doesn't
 request each generated <code>Publisher</code> unless the downstream has made
 a corresponding request (no prefetch of inner publishers).</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the type of the return value of the transformation function</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>fn</code> - the <code>Function</code> to generate a <code>Publisher</code> for each source value</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits values from an alternative <code>Publisher</code>
 for each source onNext</dd>
</dl>
</li>
</ul>
<a name="switchMap-java.util.function.Function-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>switchMap</h4>
<pre>@Deprecated
public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;switchMap(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,org.reactivestreams.Publisher&lt;? extends V&gt;&gt;&nbsp;fn,
                                                int&nbsp;prefetch)</pre>
<div class="block"><span class="deprecatedLabel">已过时。</span>&nbsp;<span class="deprecationComment">to be removed in 3.6.0 at the earliest. In 3.5.0, you should replace
 calls with prefetch=0 with calls to switchMap(fn), as the default behavior of the
 single-parameter variant will then change to prefetch=0.</span></div>
<div class="block">Switch to a new <code>Publisher</code> generated via a <code>Function</code> whenever
 this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> produces an item. As such, the elements from each generated
 Publisher are emitted in the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/switchMap.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the type of the return value of the transformation function</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>fn</code> - the <code>Function</code> to generate a <code>Publisher</code> for each source value</dd>
<dd><code>prefetch</code> - the produced demand for inner sources</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits values from an alternative <code>Publisher</code>
 for each source onNext</dd>
</dl>
</li>
</ul>
<a name="tag-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tag</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;tag(java.lang.String&nbsp;key,
                         java.lang.String&nbsp;value)</pre>
<div class="block">Tag this flux with a key/value pair. These can be retrieved as a <code>Set</code> of
 all tags throughout the publisher chain by using <a href="../../../reactor/core/Scannable.html#tags--"><code>Scannable.tags()</code></a> (as
 traversed by <a href="../../../reactor/core/Scannable.html#parents--"><code>Scannable.parents()</code></a>).
 <p>
 The name is typically visible at assembly time by the <a href="../../../reactor/core/publisher/Flux.html#tap-reactor.core.observability.SignalListenerFactory-"><code>tap(SignalListenerFactory)</code></a> operator,
 which could for example be configured with a metrics listener applying the tag(s) to its meters.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>key</code> - a tag key</dd>
<dd><code>value</code> - a tag value</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>the same sequence, but bearing tags</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#name-java.lang.String-"><code>name(String)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#metrics--"><code>metrics()</code></a></dd>
</dl>
</li>
</ul>
<a name="take-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>take</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;take(long&nbsp;n)</pre>
<div class="block">Take only the first N values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, if available.
 If n is zero, the source isn't even subscribed to and the operator completes immediately upon subscription.
 <p>
 <img class="marble" src="doc-files/marbles/takeLimitRequestTrue.svg" alt="">
 <p>
 This ensures that the total amount requested upstream is capped at <code>n</code>, although smaller
 requests can be made if the downstream makes requests &lt; n. In any case, this operator never lets
 the upstream produce more elements than the cap, and it can be used to more strictly adhere to backpressure.
 <p>
 This mode is typically useful for cases where a race between request and cancellation can lead
 the upstream to producing a lot of extraneous data, and such a production is undesirable (e.g.
 a source that would send the extraneous data over the network).
 It is equivalent to <a href="../../../reactor/core/publisher/Flux.html#take-long-boolean-"><code>take(long, boolean)</code></a> with <code>limitRequest == true</code>,
 If there is a requirement for unbounded upstream request (eg. for performance reasons),
 use <a href="../../../reactor/core/publisher/Flux.html#take-long-boolean-"><code>take(long, boolean)</code></a> with <code>limitRequest=false</code> instead.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>n</code> - the maximum number of items to request from upstream and emit from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> limited to size N</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#take-long-boolean-"><code>take(long, boolean)</code></a></dd>
</dl>
</li>
</ul>
<a name="take-long-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>take</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;take(long&nbsp;n,
                          boolean&nbsp;limitRequest)</pre>
<div class="block">Take only the first N values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>, if available.
 <p>
 <img class="marble" src="doc-files/marbles/takeLimitRequestTrue.svg" alt="">
 <p>
 If <code>limitRequest == true</code>, ensure that the total amount requested upstream is capped
 at <code>n</code>. In that configuration, this operator never let the upstream produce more elements
 than the cap, and it can be used to more strictly adhere to backpressure.
 If n is zero, the source isn't even subscribed to and the operator completes immediately
 upon subscription (the behavior inherited from <a href="../../../reactor/core/publisher/Flux.html#take-long-"><code>take(long)</code></a>).
 <p>
 This mode is typically useful for cases where a race between request and cancellation can lead
 the upstream to producing a lot of extraneous data, and such a production is undesirable (e.g.
 a source that would send the extraneous data over the network).
 <p>
 <img class="marble" src="doc-files/marbles/takeLimitRequestFalse.svg" alt="takeLimitRequestFalse">
 <p>
 If <code>limitRequest == false</code> this operator doesn't propagate the backpressure requested amount.
 Rather, it makes an unbounded request and cancels once N elements have been emitted.
 If n is zero, the source is subscribed to but immediately cancelled, then the operator completes.
 <p>
 In this mode, the source could produce a lot of extraneous elements despite cancellation.
 If that behavior is undesirable and you do not own the request from downstream
 (e.g. prefetching operators), consider using <code>limitRequest = true</code> instead.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>n</code> - the number of items to emit from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dd><code>limitRequest</code> - <code>true</code> to follow the downstream request more closely and limit the upstream request
 to <code>n</code>. <code>false</code> to request an unbounded amount from upstream.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> limited to size N</dd>
</dl>
</li>
</ul>
<a name="take-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>take</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;take(java.time.Duration&nbsp;timespan)</pre>
<div class="block">Relay values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until the specified <code>Duration</code> elapses.
 <p>
 If the duration is zero, the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes as soon as this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 signals its first value (which is not relayed, though).

 <p>
 <img class="marble" src="doc-files/marbles/takeWithTimespanForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timespan</code> - the <code>Duration</code> of the time window during which to emit elements
 from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> limited to elements emitted within a specific duration</dd>
</dl>
</li>
</ul>
<a name="take-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>take</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;take(java.time.Duration&nbsp;timespan,
                          <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Relay values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until the specified <code>Duration</code> elapses,
 as measured on the specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.
 <p>
 If the duration is zero, the resulting <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes as soon as this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 signals its first value (which is not relayed, though).

 <p>
 <img class="marble" src="doc-files/marbles/takeWithTimespanForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timespan</code> - the <code>Duration</code> of the time window during which to emit elements
 from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> limited to elements emitted within a specific duration</dd>
</dl>
</li>
</ul>
<a name="takeLast-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeLast</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;takeLast(int&nbsp;n)</pre>
<div class="block">Emit the last N values this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> emitted before its completion.

 <p>
 <img class="marble" src="doc-files/marbles/takeLast.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>n</code> - the number of items from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> to retain and emit on onComplete</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a terminating <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sub-sequence</dd>
</dl>
</li>
</ul>
<a name="takeUntil-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeUntil</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;takeUntil(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;predicate)</pre>
<div class="block">Relay values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until the given <code>Predicate</code> matches.
 This includes the matching data (unlike <a href="../../../reactor/core/publisher/Flux.html#takeWhile-java.util.function.Predicate-"><code>takeWhile(java.util.function.Predicate&lt;? super T&gt;)</code></a>).

 <p>
 <img class="marble" src="doc-files/marbles/takeUntil.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>predicate</code> - the <code>Predicate</code> that stops the taking of values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 when returning true.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> limited by the predicate</dd>
</dl>
</li>
</ul>
<a name="takeUntilOther-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeUntilOther</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;takeUntilOther(org.reactivestreams.Publisher&lt;?&gt;&nbsp;other)</pre>
<div class="block">Relay values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until the given <code>Publisher</code> emits.

 <p>
 <img class="marble" src="doc-files/marbles/takeUntilOtherForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the companion <code>Publisher</code> that signals when to stop taking values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> limited by a companion <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="takeWhile-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>takeWhile</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;takeWhile(java.util.function.Predicate&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;continuePredicate)</pre>
<div class="block">Relay values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> while a predicate returns TRUE
 for the values (checked before each value is delivered).
 This only includes the matching data (unlike <a href="../../../reactor/core/publisher/Flux.html#takeUntil-java.util.function.Predicate-"><code>takeUntil(java.util.function.Predicate&lt;? super T&gt;)</code></a>).

 <p>
 <img class="marble" src="doc-files/marbles/takeWhile.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>continuePredicate</code> - the <code>Predicate</code> invoked each onNext returning TRUE
 to relay a value or FALSE to terminate</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> taking values from the source while the predicate matches</dd>
</dl>
</li>
</ul>
<a name="tap-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tap</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;tap(java.util.function.Supplier&lt;<a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口">SignalListener</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;simpleListenerGenerator)</pre>
<div class="block">Tap into Reactive Streams signals emitted or received by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and notify a stateful per-<code>Subscriber</code>
 <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a>.
 <p>
 Any exception thrown by the <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> methods causes the subscription to be cancelled
 and the subscriber to be terminated with an <code>onError signal</code> of that
 exception. Note that <a href="../../../reactor/core/observability/SignalListener.html#doFinally-reactor.core.publisher.SignalType-"><code>SignalListener.doFinally(SignalType)</code></a>, <a href="../../../reactor/core/observability/SignalListener.html#doAfterComplete--"><code>SignalListener.doAfterComplete()</code></a> and
 <a href="../../../reactor/core/observability/SignalListener.html#doAfterError-java.lang.Throwable-"><code>SignalListener.doAfterError(Throwable)</code></a> instead just <a href="../../../reactor/core/publisher/Operators.html#onErrorDropped-java.lang.Throwable-reactor.util.context.Context-"><code>drop</code></a>
 the exception.
 <p>
 This simplified variant assumes the state is purely initialized within the <code>Supplier</code>,
 as it is called for each incoming <code>Subscriber</code> without additional context.
 <p>
 When the <a href="https://github.com/micrometer-metrics/context-propagation">context-propagation library</a>
 is available at runtime and the downstream <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a> is not empty, this operator implicitly uses the library
 to restore thread locals around all invocations of <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> methods. Typically, this would be done
 in conjunction with the use of <a href="../../../reactor/core/publisher/Flux.html#contextCapture--"><code>contextCapture()</code></a> operator down the chain.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>simpleListenerGenerator</code> - the <code>Supplier</code> to create a new <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> on each subscription</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with side effects defined by generated <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#tap-java.util.function.Function-"><code>tap(Function)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#tap-reactor.core.observability.SignalListenerFactory-"><code>tap(SignalListenerFactory)</code></a></dd>
</dl>
</li>
</ul>
<a name="tap-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tap</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;tap(java.util.function.Function&lt;<a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口">ContextView</a>,<a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口">SignalListener</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;listenerGenerator)</pre>
<div class="block">Tap into Reactive Streams signals emitted or received by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and notify a stateful per-<code>Subscriber</code>
 <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a>.
 <p>
 Any exception thrown by the <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> methods causes the subscription to be cancelled
 and the subscriber to be terminated with an <code>onError signal</code> of that
 exception. Note that <a href="../../../reactor/core/observability/SignalListener.html#doFinally-reactor.core.publisher.SignalType-"><code>SignalListener.doFinally(SignalType)</code></a>, <a href="../../../reactor/core/observability/SignalListener.html#doAfterComplete--"><code>SignalListener.doAfterComplete()</code></a> and
 <a href="../../../reactor/core/observability/SignalListener.html#doAfterError-java.lang.Throwable-"><code>SignalListener.doAfterError(Throwable)</code></a> instead just <a href="../../../reactor/core/publisher/Operators.html#onErrorDropped-java.lang.Throwable-reactor.util.context.Context-"><code>drop</code></a>
 the exception.
 <p>
 This simplified variant allows the <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> to be constructed for each subscription
 with access to the incoming <code>Subscriber</code>'s <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a>.
 <p>
 When the <a href="https://github.com/micrometer-metrics/context-propagation">context-propagation library</a>
 is available at runtime and the <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a> is not empty, this operator implicitly uses the library
 to restore thread locals around all invocations of <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> methods. Typically, this would be done
 in conjunction with the use of <a href="../../../reactor/core/publisher/Flux.html#contextCapture--"><code>contextCapture()</code></a> operator down the chain.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>listenerGenerator</code> - the <code>Function</code> to create a new <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> on each subscription</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with side effects defined by generated <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#tap-java.util.function.Supplier-"><code>tap(Supplier)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#tap-reactor.core.observability.SignalListenerFactory-"><code>tap(SignalListenerFactory)</code></a></dd>
</dl>
</li>
</ul>
<a name="tap-reactor.core.observability.SignalListenerFactory-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>tap</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;tap(<a href="../../../reactor/core/observability/SignalListenerFactory.html" title="reactor.core.observability中的接口">SignalListenerFactory</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,?&gt;&nbsp;listenerFactory)</pre>
<div class="block">Tap into Reactive Streams signals emitted or received by this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and notify a stateful per-<code>Subscriber</code>
 <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> created by the provided <a href="../../../reactor/core/observability/SignalListenerFactory.html" title="reactor.core.observability中的接口"><code>SignalListenerFactory</code></a>.
 <p>
 The factory will initialize a <a href="../../../reactor/core/observability/SignalListenerFactory.html#initializePublisherState-org.reactivestreams.Publisher-"><code>state object</code></a> for
 each <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> or <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> instance it is used with, and that state will be cached and exposed for each
 incoming <code>Subscriber</code> in order to generate the associated <a href="../../../reactor/core/observability/SignalListenerFactory.html#createListener-org.reactivestreams.Publisher-reactor.util.context.ContextView-STATE-"><code>listener</code></a>.
 <p>
 Any exception thrown by the <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> methods causes the subscription to be cancelled
 and the subscriber to be terminated with an <code>onError signal</code> of that
 exception. Note that <a href="../../../reactor/core/observability/SignalListener.html#doFinally-reactor.core.publisher.SignalType-"><code>SignalListener.doFinally(SignalType)</code></a>, <a href="../../../reactor/core/observability/SignalListener.html#doAfterComplete--"><code>SignalListener.doAfterComplete()</code></a> and
 <a href="../../../reactor/core/observability/SignalListener.html#doAfterError-java.lang.Throwable-"><code>SignalListener.doAfterError(Throwable)</code></a> instead just <a href="../../../reactor/core/publisher/Operators.html#onErrorDropped-java.lang.Throwable-reactor.util.context.Context-"><code>drop</code></a>
 the exception.
 <p>
 When the <a href="https://github.com/micrometer-metrics/context-propagation">context-propagation library</a>
 is available at runtime and the downstream <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a> is not empty, this operator implicitly uses the library
 to restore thread locals around all invocations of <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> methods. Typically, this would be done
 in conjunction with the use of <a href="../../../reactor/core/publisher/Flux.html#contextCapture--"><code>contextCapture()</code></a> operator down the chain.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>listenerFactory</code> - the <a href="../../../reactor/core/observability/SignalListenerFactory.html" title="reactor.core.observability中的接口"><code>SignalListenerFactory</code></a> to create a new <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a> on each subscription</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with side effects defined by generated <a href="../../../reactor/core/observability/SignalListener.html" title="reactor.core.observability中的接口"><code>SignalListener</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#tap-java.util.function.Supplier-"><code>tap(Supplier)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#tap-java.util.function.Function-"><code>tap(Function)</code></a></dd>
</dl>
</li>
</ul>
<a name="then--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>then</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Void&gt;&nbsp;then()</pre>
<div class="block">Return a <code>Mono&lt;Void&gt;</code> that completes when this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> completes.
 This will actively ignore the sequence and only replay completion or error signals.
 <p>
 <img class="marble" src="doc-files/marbles/thenForFlux.svg" alt="">
 <p>

 <p><strong>Discard Support:</strong> This operator discards elements from the source.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> representing the termination of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="then-reactor.core.publisher.Mono-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>then</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;V&gt;&nbsp;then(<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;V&gt;&nbsp;other)</pre>
<div class="block">Let this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> complete then play signals from a provided <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a>.
 <p>
 In other words ignore element from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and transform its completion signal into the
 emission and completion signal of a provided <code>Mono&lt;V&gt;</code>. Error signal is
 replayed in the resulting <code>Mono&lt;V&gt;</code>.

 <p>
 <img class="marble" src="doc-files/marbles/thenWithMonoForFlux.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements from the source.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the element type of the supplied Mono</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - a <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> to emit from after termination</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that wait for source completion then emits from the supplied <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a></dd>
</dl>
</li>
</ul>
<a name="thenEmpty-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>thenEmpty</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类">Mono</a>&lt;java.lang.Void&gt;&nbsp;thenEmpty(org.reactivestreams.Publisher&lt;java.lang.Void&gt;&nbsp;other)</pre>
<div class="block">Return a <code>Mono&lt;Void&gt;</code> that waits for this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> to complete then
 for a supplied <code>Publisher&lt;Void&gt;</code> to also complete. The
 second completion signal is replayed, or any error signal that occurs instead.
 <p>
 <img class="marble" src="doc-files/marbles/thenEmptyForFlux.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements from the source.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - a <code>Publisher</code> to wait for after this Flux's termination</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Mono.html" title="reactor.core.publisher中的类"><code>Mono</code></a> completing when both publishers have completed in
 sequence</dd>
</dl>
</li>
</ul>
<a name="thenMany-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>thenMany</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;thenMany(org.reactivestreams.Publisher&lt;V&gt;&nbsp;other)</pre>
<div class="block">Let this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> complete then play another <code>Publisher</code>.
 <p>
 In other words ignore element from this flux and transform the completion signal into a
 <code>Publisher&lt;V&gt;</code> that will emit elements from the provided <code>Publisher</code>.
 <p>
 <img class="marble" src="doc-files/marbles/thenManyForFlux.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards elements from the source.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the element type of the supplied Publisher</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - a <code>Publisher</code> to emit from after termination</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that emits from the supplied <code>Publisher</code> after
 this Flux completes.</dd>
</dl>
</li>
</ul>
<a name="timed--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timed</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Timed.html" title="reactor.core.publisher中的接口">Timed</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;timed()</pre>
<div class="block">Times <code>Subscriber.onNext(Object)</code> events, encapsulated into a <a href="../../../reactor/core/publisher/Timed.html" title="reactor.core.publisher中的接口"><code>Timed</code></a> object
 that lets downstream consumer look at various time information gathered with nanosecond
 resolution using the default clock (<a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>Schedulers.parallel()</code></a>):
 <ul>
     <li><a href="../../../reactor/core/publisher/Timed.html#elapsed--"><code>Timed.elapsed()</code></a>: the time in nanoseconds since last event, as a <code>Duration</code>.
     For the first onNext, "last event" is the subscription. Otherwise it is the previous onNext.
     This is functionally equivalent to <a href="../../../reactor/core/publisher/Flux.html#elapsed--"><code>elapsed()</code></a>, with a more expressive and precise
     representation than a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a> with a long.</li>
     <li><a href="../../../reactor/core/publisher/Timed.html#timestamp--"><code>Timed.timestamp()</code></a>: the timestamp of this onNext, as an <code>Instant</code>
     (with nanoseconds part). This is functionally equivalent to <a href="../../../reactor/core/publisher/Flux.html#timestamp--"><code>timestamp()</code></a>, with a more
     expressive and precise representation than a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a> with a long.</li>
     <li><a href="../../../reactor/core/publisher/Timed.html#elapsedSinceSubscription--"><code>Timed.elapsedSinceSubscription()</code></a>: the time in nanoseconds since subscription,
     as a <code>Duration</code>.</li>
 </ul>
 <p>
 The <a href="../../../reactor/core/publisher/Timed.html" title="reactor.core.publisher中的接口"><code>Timed</code></a> object instances are safe to store and use later, as they are created as an
 immutable wrapper around the <code>&lt;T&gt;</code> value and immediately passed downstream.
 <p>
 <img class="marble" src="doc-files/marbles/timedForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a timed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#elapsed--"><code>elapsed()</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#timestamp--"><code>timestamp()</code></a></dd>
</dl>
</li>
</ul>
<a name="timed-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timed</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Timed.html" title="reactor.core.publisher中的接口">Timed</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;timed(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;clock)</pre>
<div class="block">Times <code>Subscriber.onNext(Object)</code> events, encapsulated into a <a href="../../../reactor/core/publisher/Timed.html" title="reactor.core.publisher中的接口"><code>Timed</code></a> object
 that lets downstream consumer look at various time information gathered with nanosecond
 resolution using the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> as a clock:
 <ul>
     <li><a href="../../../reactor/core/publisher/Timed.html#elapsed--"><code>Timed.elapsed()</code></a>: the time in nanoseconds since last event, as a <code>Duration</code>.
     For the first onNext, "last event" is the subscription. Otherwise it is the previous onNext.
     This is functionally equivalent to <a href="../../../reactor/core/publisher/Flux.html#elapsed--"><code>elapsed()</code></a>, with a more expressive and precise
     representation than a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a> with a long.</li>
     <li><a href="../../../reactor/core/publisher/Timed.html#timestamp--"><code>Timed.timestamp()</code></a>: the timestamp of this onNext, as an <code>Instant</code>
     (with nanoseconds part). This is functionally equivalent to <a href="../../../reactor/core/publisher/Flux.html#timestamp--"><code>timestamp()</code></a>, with a more
     expressive and precise representation than a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a> with a long.</li>
     <li><a href="../../../reactor/core/publisher/Timed.html#elapsedSinceSubscription--"><code>Timed.elapsedSinceSubscription()</code></a>: the time in nanoseconds since subscription,
     as a <code>Duration</code>.</li>
 </ul>
 <p>
 The <a href="../../../reactor/core/publisher/Timed.html" title="reactor.core.publisher中的接口"><code>Timed</code></a> object instances are safe to store and use later, as they are created as an
 immutable wrapper around the <code>&lt;T&gt;</code> value and immediately passed downstream.
 <p>
 <img class="marble" src="doc-files/marbles/timedForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a timed <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#elapsed-reactor.core.scheduler.Scheduler-"><code>elapsed(Scheduler)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#timestamp-reactor.core.scheduler.Scheduler-"><code>timestamp(Scheduler)</code></a></dd>
</dl>
</li>
</ul>
<a name="timeout-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;timeout(java.time.Duration&nbsp;timeout)</pre>
<div class="block">Propagate a <code>TimeoutException</code> as soon as no item is emitted within the
 given <code>Duration</code> from the previous emission (or the subscription for the first item).

 <p>
 <img class="marble" src="doc-files/marbles/timeoutForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timeout</code> - the timeout between two signals from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that can time out on a per-item basis</dd>
</dl>
</li>
</ul>
<a name="timeout-java.time.Duration-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;timeout(java.time.Duration&nbsp;timeout,
                             <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                             org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;fallback)</pre>
<div class="block">Switch to a fallback <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> as soon as no item is emitted within the
 given <code>Duration</code> from the previous emission (or the subscription for the first item).
 <p>
 If the given <code>Publisher</code> is null, signal a <code>TimeoutException</code> instead.

 <p>
 <img class="marble" src="doc-files/marbles/timeoutFallbackForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timeout</code> - the timeout between two signals from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dd><code>fallback</code> - the fallback <code>Publisher</code> to subscribe when a timeout occurs</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will fallback to a different <code>Publisher</code> in case of a per-item timeout</dd>
</dl>
</li>
</ul>
<a name="timeout-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;timeout(java.time.Duration&nbsp;timeout,
                             <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Propagate a <code>TimeoutException</code> as soon as no item is emitted within the
 given <code>Duration</code> from the previous emission (or the subscription for the first
 item), as measured by the specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/timeoutForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timeout</code> - the timeout <code>Duration</code> between two signals from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that can time out on a per-item basis</dd>
</dl>
</li>
</ul>
<a name="timeout-java.time.Duration-org.reactivestreams.Publisher-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;timeout(java.time.Duration&nbsp;timeout,
                             <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                             org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;fallback,
                             <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Switch to a fallback <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> as soon as no item is emitted within the
 given <code>Duration</code> from the previous emission (or the subscription for the
 first item), as measured on the specified <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.
 <p>
 If the given <code>Publisher</code> is null, signal a <code>TimeoutException</code> instead.

 <p>
 <img class="marble" src="doc-files/marbles/timeoutFallbackForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>timeout</code> - the timeout <code>Duration</code> between two signals from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dd><code>fallback</code> - the fallback <code>Publisher</code> to subscribe when a timeout occurs</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that will fallback to a different <code>Publisher</code> in case of a per-item timeout</dd>
</dl>
</li>
</ul>
<a name="timeout-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre>public final&nbsp;&lt;U&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;timeout(org.reactivestreams.Publisher&lt;U&gt;&nbsp;firstTimeout)</pre>
<div class="block">Signal a <code>TimeoutException</code> in case the first item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> has
 not been emitted before the given <code>Publisher</code> emits.

 <p>
 <img class="marble" src="doc-files/marbles/timeoutPublisher.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the type of the timeout Publisher</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>firstTimeout</code> - the companion <code>Publisher</code> that will trigger a timeout if
 emitting before the first signal from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that can time out if the first item does not come before
 a signal from a companion <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="timeout-org.reactivestreams.Publisher-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre>public final&nbsp;&lt;U,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;timeout(org.reactivestreams.Publisher&lt;U&gt;&nbsp;firstTimeout,
                                   java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;nextTimeoutFactory)</pre>
<div class="block">Signal a <code>TimeoutException</code> in case the first item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> has
 not been emitted before the <code>firstTimeout</code> <code>Publisher</code> emits, and whenever
 each subsequent elements is not emitted before a <code>Publisher</code> generated from
 the latest element signals.

 <p>
 <img class="marble" src="doc-files/marbles/timeoutPublisherFunctionForFlux.svg" alt="">

 <p><strong>Discard Support:</strong> This operator discards an element if it comes right after the timeout.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the type of the elements of the first timeout Publisher</dd>
<dd><code>V</code> - the type of the elements of the subsequent timeout Publishers</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>firstTimeout</code> - the timeout <code>Publisher</code> that must not emit before the first signal from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dd><code>nextTimeoutFactory</code> - the timeout <code>Publisher</code> factory for each next item</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that can time out if each element does not come before
 a signal from a per-item companion <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="timeout-org.reactivestreams.Publisher-java.util.function.Function-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre>public final&nbsp;&lt;U,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;timeout(org.reactivestreams.Publisher&lt;U&gt;&nbsp;firstTimeout,
                                   java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;nextTimeoutFactory,
                                   org.reactivestreams.Publisher&lt;? extends <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;fallback)</pre>
<div class="block">Switch to a fallback <code>Publisher</code> in case the first item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> has
 not been emitted before the <code>firstTimeout</code> <code>Publisher</code> emits, and whenever
 each subsequent elements is not emitted before a <code>Publisher</code> generated from
 the latest element signals.

 <p>
 <img class="marble" src="doc-files/marbles/timeoutPublisherFunctionAndFallbackForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the type of the elements of the first timeout Publisher</dd>
<dd><code>V</code> - the type of the elements of the subsequent timeout Publishers</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>firstTimeout</code> - the timeout <code>Publisher</code> that must not emit before the first signal from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dd><code>nextTimeoutFactory</code> - the timeout <code>Publisher</code> factory for each next item</dd>
<dd><code>fallback</code> - the fallback <code>Publisher</code> to subscribe when a timeout occurs</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> that can time out if each element does not come before
 a signal from a per-item companion <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="timestamp--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timestamp</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;java.lang.Long,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;timestamp()</pre>
<div class="block">Emit a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a> pair of T1 the current clock time in
 millis (as a <code>Long</code> measured by the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel</code></a>
 Scheduler) and T2 the emitted data (as a <code>T</code>), for each item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/timestampForFlux.svg" alt=""></div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a timestamped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#timed--"><code>timed()</code></a>, 
<a href="../../../reactor/core/publisher/Timed.html#timestamp--"><code>Timed.timestamp()</code></a></dd>
</dl>
</li>
</ul>
<a name="timestamp-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timestamp</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;java.lang.Long,<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;timestamp(<a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;scheduler)</pre>
<div class="block">Emit a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a> pair of T1 the current clock time in
 millis (as a <code>Long</code> measured by the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>) and T2
 the emitted data (as a <code>T</code>), for each item from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.

 <p>The provider <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> will be asked to <a href="../../../reactor/core/scheduler/Scheduler.html#now-java.util.concurrent.TimeUnit-"><code>provide time</code></a>
 with a granularity of <code>TimeUnit.MILLISECONDS</code>. In order for this operator to work as advertised, the
 provided Scheduler should thus return results that can be interpreted as unix timestamps.</p>
 <p>

 <img class="marble" src="doc-files/marbles/timestampForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>scheduler</code> - the <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> to read time from</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a timestamped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/scheduler/Scheduler.html#now-java.util.concurrent.TimeUnit-"><code>Scheduler.now(TimeUnit)</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#timed-reactor.core.scheduler.Scheduler-"><code>timed(Scheduler)</code></a>, 
<a href="../../../reactor/core/publisher/Timed.html#timestamp--"><code>Timed.timestamp()</code></a></dd>
</dl>
</li>
</ul>
<a name="toIterable--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toIterable</h4>
<pre>public final&nbsp;java.lang.Iterable&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;toIterable()</pre>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a lazy <code>Iterable</code> blocking on
 <code>Iterator.next()</code> calls.

 <p>
 <img class="marble" src="doc-files/marbles/toIterable.svg" alt="">
 <p>
 Note that iterating from within threads marked as "non-blocking only" is illegal and will
 cause an <code>IllegalStateException</code> to be thrown, but obtaining the <code>Iterable</code>
 itself within these threads is ok.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a blocking <code>Iterable</code></dd>
</dl>
</li>
</ul>
<a name="toIterable-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toIterable</h4>
<pre>public final&nbsp;java.lang.Iterable&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;toIterable(int&nbsp;batchSize)</pre>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a lazy <code>Iterable</code> blocking on
 <code>Iterator.next()</code> calls.
 <p>
 <img class="marble" src="doc-files/marbles/toIterableWithBatchSize.svg" alt="">
 <p>
 Note that iterating from within threads marked as "non-blocking only" is illegal and will
 cause an <code>IllegalStateException</code> to be thrown, but obtaining the <code>Iterable</code>
 itself within these threads is ok.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>batchSize</code> - the bounded capacity to prefetch from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> or
 <code>Integer.MAX_VALUE</code> for unbounded demand</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a blocking <code>Iterable</code></dd>
</dl>
</li>
</ul>
<a name="toIterable-int-java.util.function.Supplier-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toIterable</h4>
<pre>public final&nbsp;java.lang.Iterable&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;toIterable(int&nbsp;batchSize,
                                              <a href="../../../reactor/util/annotation/Nullable.html" title="reactor.util.annotation中的注释">@Nullable</a>
                                              java.util.function.Supplier&lt;java.util.Queue&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;queueProvider)</pre>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a lazy <code>Iterable</code> blocking on
 <code>Iterator.next()</code> calls.

 <p>
 <img class="marble" src="doc-files/marbles/toIterableWithBatchSize.svg" alt="">
 <p>
 Note that iterating from within threads marked as "non-blocking only" is illegal and will
 cause an <code>IllegalStateException</code> to be thrown, but obtaining the <code>Iterable</code>
 itself within these threads is ok.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>batchSize</code> - the bounded capacity to prefetch from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> or
 <code>Integer.MAX_VALUE</code> for unbounded demand</dd>
<dd><code>queueProvider</code> - the supplier of the queue implementation to be used for storing
 elements emitted faster than the iteration</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a blocking <code>Iterable</code></dd>
</dl>
</li>
</ul>
<a name="toStream--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toStream</h4>
<pre>public final&nbsp;java.util.stream.Stream&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;toStream()</pre>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a lazy <code>Stream</code> blocking for each source
 <code>onNext</code> call.

 <p>
 <img class="marble" src="doc-files/marbles/toStream.svg" alt="">
 <p>
 Note that iterating from within threads marked as "non-blocking only" is illegal and will
 cause an <code>IllegalStateException</code> to be thrown, but obtaining the <code>Stream</code>
 itself or applying lazy intermediate operation on the stream within these threads is ok.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <code>Stream</code> of unknown size with onClose attached to <code>Subscription.cancel()</code></dd>
</dl>
</li>
</ul>
<a name="toStream-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toStream</h4>
<pre>public final&nbsp;java.util.stream.Stream&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;toStream(int&nbsp;batchSize)</pre>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a lazy <code>Stream</code> blocking for each source
 <code>onNext</code> call.
 <p>
 <img class="marble" src="doc-files/marbles/toStreamWithBatchSize.svg" alt="">
 <p>
 Note that iterating from within threads marked as "non-blocking only" is illegal and will
 cause an <code>IllegalStateException</code> to be thrown, but obtaining the <code>Stream</code>
 itself or applying lazy intermediate operation on the stream within these threads is ok.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>batchSize</code> - the bounded capacity to prefetch from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> or
 <code>Integer.MAX_VALUE</code> for unbounded demand</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <code>Stream</code> of unknown size with onClose attached to <code>Subscription.cancel()</code></dd>
</dl>
</li>
</ul>
<a name="transform-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transform</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;transform(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;transformer)</pre>
<div class="block">Transform this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> in order to generate a target <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>. Unlike <a href="../../../reactor/core/publisher/Flux.html#transformDeferred-java.util.function.Function-"><code>transformDeferred(Function)</code></a>, the
 provided function is executed as part of assembly.
 <blockquote><pre>
 Function<Flux, Flux> applySchedulers = flux -> flux.subscribeOn(Schedulers.boundedElastic())
                                                    .publishOn(Schedulers.parallel());
 flux.transform(applySchedulers).map(v -> v * v).subscribe();
 </pre></blockquote>
 <p>
 <img class="marble" src="doc-files/marbles/transformForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the item type in the returned <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>transformer</code> - the <code>Function</code> to immediately map this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a target <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 instance.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#transformDeferred-java.util.function.Function-"><code>transformDeferred(Function) for deferred composition of Flux for each @link Subscriber</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#as-java.util.function.Function-"><code>as(Function) for a loose conversion to an arbitrary type</code></a></dd>
</dl>
</li>
</ul>
<a name="transformDeferred-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transformDeferred</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;transformDeferred(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;transformer)</pre>
<div class="block">Defer the transformation of this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> in order to generate a target <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> type.
 A transformation will occur for each <code>Subscriber</code>. For instance:
 <blockquote><pre>
 flux.transformDeferred(original -> original.log());
 </pre></blockquote>
 <p>
 <img class="marble" src="doc-files/marbles/transformDeferredForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the item type in the returned <code>Publisher</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>transformer</code> - the <code>Function</code> to lazily map this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a target <code>Publisher</code>
 instance for each new subscriber</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#transform-java.util.function.Function-"><code>transform(Function) for immmediate transformation of Flux</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#transformDeferredContextual-java.util.function.BiFunction-"><code>transformDeferredContextual(BiFunction) for a similarly deferred transformation of Flux reading the ContextView</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#as-java.util.function.Function-"><code>as(Function) for a loose conversion to an arbitrary type</code></a></dd>
</dl>
</li>
</ul>
<a name="transformDeferredContextual-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transformDeferredContextual</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;transformDeferredContextual(java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;,? super <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口">ContextView</a>,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;transformer)</pre>
<div class="block">Defer the given transformation to this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> in order to generate a
 target <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> type. A transformation will occur for each
 <code>Subscriber</code>. In addition, the transforming <code>BiFunction</code> exposes
 the <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a> of each <code>Subscriber</code>. For instance:

 <blockquote><pre>
 Flux&lt;T> fluxLogged = flux.transformDeferredContextual((original, ctx) -> original.log("for RequestID" + ctx.get("RequestID"))
 //...later subscribe. Each subscriber has its Context with a RequestID entry
 fluxLogged.contextWrite(Context.of("RequestID", "requestA").subscribe();
 fluxLogged.contextWrite(Context.of("RequestID", "requestB").subscribe();
 </pre></blockquote>
 <p>
 <img class="marble" src="doc-files/marbles/transformDeferredForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>V</code> - the item type in the returned <code>Publisher</code></dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>transformer</code> - the <code>BiFunction</code> to lazily map this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> into a target <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>
 instance upon subscription, with access to <a href="../../../reactor/util/context/ContextView.html" title="reactor.util.context中的接口"><code>ContextView</code></a></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../reactor/core/publisher/Flux.html#transform-java.util.function.Function-"><code>transform(Function) for immmediate transformation of Flux</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#transformDeferred-java.util.function.Function-"><code>transformDeferred(Function) for a similarly deferred transformation of Flux without the ContextView</code></a>, 
<a href="../../../reactor/core/publisher/Flux.html#as-java.util.function.Function-"><code>as(Function) for a loose conversion to an arbitrary type</code></a></dd>
</dl>
</li>
</ul>
<a name="window-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>window</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;window(int&nbsp;maxSize)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows containing
 <code>maxSize</code> elements (or less for the final window) and starting from the first item.
 Each <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> window will onComplete after <code>maxSize</code> items have been routed.

 <p>
 <img class="marble" src="doc-files/marbles/windowWithMaxSize.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the maximum number of items to emit in the window before closing it</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows based on element count</dd>
</dl>
</li>
</ul>
<a name="window-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>window</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;window(int&nbsp;maxSize,
                                  int&nbsp;skip)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows of size
 <code>maxSize</code>, that each open every <code>skip</code> elements in the source.

 <p>
 When maxSize < skip : dropping windows
 <p>
 <img class="marble" src="doc-files/marbles/windowWithMaxSizeLessThanSkipSize.svg" alt="">
 <p>
 When maxSize > skip : overlapping windows
 <p>
 <img class="marble" src="doc-files/marbles/windowWithMaxSizeGreaterThanSkipSize.svg" alt="">
 <p>
 When maxSize == skip : exact windows
 <p>
 <img class="marble" src="doc-files/marbles/windowWithMaxSizeEqualsSkipSize.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> The overlapping variant DOES NOT discard elements, as they might be part of another still valid window.
 The exact window and dropping window variants bot discard elements they internally queued for backpressure
 upon cancellation or error triggered by a data signal. The dropping window variant also discards elements in between windows.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the maximum number of items to emit in the window before closing it</dd>
<dd><code>skip</code> - the number of items to count before opening and emitting a new window</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows based on element count and opened every skipCount</dd>
</dl>
</li>
</ul>
<a name="window-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>window</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;window(org.reactivestreams.Publisher&lt;?&gt;&nbsp;boundary)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into continuous, non-overlapping windows
 where the window boundary is signalled by another <code>Publisher</code>

 <p>
 <img class="marble" src="doc-files/marbles/windowWithBoundary.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors and those emitted by the <code>boundary</code> delivered to the window
 <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>boundary</code> - a <code>Publisher</code> to emit any item for a split signal and complete to terminate</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows delimited by a given <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="window-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>window</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;window(java.time.Duration&nbsp;windowingTimespan)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into continuous, non-overlapping windows that open
 for a <code>windowingTimespan</code> <code>Duration</code> (as measured on the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel</code></a>
 Scheduler).

 <p>
 <img class="marble" src="doc-files/marbles/windowWithTimespan.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>windowingTimespan</code> - the <code>Duration</code> to delimit <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows continuously opened for a given <code>Duration</code></dd>
</dl>
</li>
</ul>
<a name="window-java.time.Duration-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>window</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;window(java.time.Duration&nbsp;windowingTimespan,
                                  java.time.Duration&nbsp;openWindowEvery)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows that open
 for a given <code>windowingTimespan</code> <code>Duration</code>, after which it closes with onComplete.
 Each window is opened at a regular <code>timeShift</code> interval, starting from the
 first item.
 Both durations are measured on the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel</code></a> Scheduler.

 <p>
 When windowingTimespan < openWindowEvery : dropping windows
 <p>
 <img class="marble" src="doc-files/marbles/windowWithTimespanLessThanOpenWindowEvery.svg" alt="">
 <p>
 When windowingTimespan > openWindowEvery : overlapping windows
 <p>
 <img class="marble" src="doc-files/marbles/windowWithTimespanGreaterThanOpenWindowEvery.svg" alt="">
 <p>
 When windowingTimespan == openWindowEvery : exact windows
 <p>
 <img class="marble" src="doc-files/marbles/windowWithTimespanEqualsOpenWindowEvery.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> The overlapping variant DOES NOT discard elements, as they might be part of another still valid window.
 The exact window and dropping window variants bot discard elements they internally queued for backpressure
 upon cancellation or error triggered by a data signal. The dropping window variant also discards elements in between windows.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>windowingTimespan</code> - the maximum <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> window <code>Duration</code></dd>
<dd><code>openWindowEvery</code> - the period of time at which to create new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows opened at regular intervals and
 closed after a <code>Duration</code></dd>
</dl>
</li>
</ul>
<a name="window-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>window</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;window(java.time.Duration&nbsp;windowingTimespan,
                                  <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into continuous, non-overlapping windows that open
 for a <code>windowingTimespan</code> <code>Duration</code> (as measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>).

 <p>
 <img class="marble" src="doc-files/marbles/windowWithTimespan.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>windowingTimespan</code> - the <code>Duration</code> to delimit <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows continuously opened for a given <code>Duration</code></dd>
</dl>
</li>
</ul>
<a name="window-java.time.Duration-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>window</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;window(java.time.Duration&nbsp;windowingTimespan,
                                  java.time.Duration&nbsp;openWindowEvery,
                                  <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows that open
 for a given <code>windowingTimespan</code> <code>Duration</code>, after which it closes with onComplete.
 Each window is opened at a regular <code>timeShift</code> interval, starting from the
 first item.
 Both durations are measured on the provided <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>.

 <p>
 When windowingTimespan < openWindowEvery : dropping windows
 <p>
 <img class="marble" src="doc-files/marbles/windowWithTimespanLessThanOpenWindowEvery.svg" alt="">
 <p>
 When windowingTimespan > openWindowEvery : overlapping windows
 <p>
 <img class="marble" src="doc-files/marbles/windowWithTimespanGreaterThanOpenWindowEvery.svg" alt="">
 <p>
 When openWindowEvery == openWindowEvery : exact windows
 <p>
 <img class="marble" src="doc-files/marbles/windowWithTimespanEqualsOpenWindowEvery.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> The overlapping variant DOES NOT discard elements, as they might be part of another still valid window.
 The exact window and dropping window variants bot discard elements they internally queued for backpressure
 upon cancellation or error triggered by a data signal. The dropping window variant also discards elements in between windows.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>windowingTimespan</code> - the maximum <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> window <code>Duration</code></dd>
<dd><code>openWindowEvery</code> - the period of time at which to create new <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows opened at regular intervals and
 closed after a <code>Duration</code></dd>
</dl>
</li>
</ul>
<a name="windowTimeout-int-java.time.Duration-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowTimeout</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowTimeout(int&nbsp;maxSize,
                                         java.time.Duration&nbsp;maxTime)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows containing
 <code>maxSize</code> elements (or less for the final window) and starting from the first item.
 Each <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> window will onComplete once it contains <code>maxSize</code> elements
 OR it has been open for the given <code>Duration</code> (as measured on the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel</code></a>
 Scheduler).

 <p>
 <img class="marble" src="doc-files/marbles/windowTimeout.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the maximum number of items to emit in the window before closing it</dd>
<dd><code>maxTime</code> - the maximum <code>Duration</code> since the window was opened before closing it</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows based on element count and duration</dd>
</dl>
</li>
</ul>
<a name="windowTimeout-int-java.time.Duration-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowTimeout</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowTimeout(int&nbsp;maxSize,
                                         java.time.Duration&nbsp;maxTime,
                                         boolean&nbsp;fairBackpressure)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows containing
 <code>maxSize</code> elements (or less for the final window) and starting from the first item.
 Each <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> window will onComplete once it contains <code>maxSize</code> elements
 OR it has been open for the given <code>Duration</code> (as measured on the <a href="../../../reactor/core/scheduler/Schedulers.html#parallel--"><code>parallel</code></a>
 Scheduler).

 <p>
 <img class="marble" src="doc-files/marbles/windowTimeout.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the maximum number of items to emit in the window before closing it</dd>
<dd><code>maxTime</code> - the maximum <code>Duration</code> since the window was opened before closing it</dd>
<dd><code>fairBackpressure</code> - define whether operator request unbounded demand or
                            prefetch by maxSize</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows based on element count and duration</dd>
</dl>
</li>
</ul>
<a name="windowTimeout-int-java.time.Duration-reactor.core.scheduler.Scheduler-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowTimeout</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowTimeout(int&nbsp;maxSize,
                                         java.time.Duration&nbsp;maxTime,
                                         <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows containing
 <code>maxSize</code> elements (or less for the final window) and starting from the first item.
 Each <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> window will onComplete once it contains <code>maxSize</code> elements
 OR it has been open for the given <code>Duration</code> (as measured on the provided
 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>).

 <p>
 <img class="marble" src="doc-files/marbles/windowTimeout.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the maximum number of items to emit in the window before closing it</dd>
<dd><code>maxTime</code> - the maximum <code>Duration</code> since the window was opened before closing it</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows based on element count and duration</dd>
</dl>
</li>
</ul>
<a name="windowTimeout-int-java.time.Duration-reactor.core.scheduler.Scheduler-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowTimeout</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowTimeout(int&nbsp;maxSize,
                                         java.time.Duration&nbsp;maxTime,
                                         <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口">Scheduler</a>&nbsp;timer,
                                         boolean&nbsp;fairBackpressure)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows containing
 <code>maxSize</code> elements (or less for the final window) and starting from the first item.
 Each <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> window will onComplete once it contains <code>maxSize</code> elements
 OR it has been open for the given <code>Duration</code> (as measured on the provided
 <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a>).

 <p>
 <img class="marble" src="doc-files/marbles/windowTimeout.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>maxSize</code> - the maximum number of items to emit in the window before closing it</dd>
<dd><code>maxTime</code> - the maximum <code>Duration</code> since the window was opened before closing it</dd>
<dd><code>timer</code> - a time-capable <a href="../../../reactor/core/scheduler/Scheduler.html" title="reactor.core.scheduler中的接口"><code>Scheduler</code></a> instance to run on</dd>
<dd><code>fairBackpressure</code> - define whether operator request unbounded demand or
                            prefetch by maxSize</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows based on element count and duration</dd>
</dl>
</li>
</ul>
<a name="windowUntil-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowUntil</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowUntil(java.util.function.Predicate&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;boundaryTrigger)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows delimited by the
 given predicate. A new window is opened each time the predicate returns true, at which
 point the previous window will receive the triggering element then onComplete.
 <p>
 Windows are lazily made available downstream at the point where they receive their
 first event (an element is pushed, the window errors). This variant shouldn't
 expose empty windows, as the separators are emitted into
 the windows they close.

 <p>
 <img class="marble" src="doc-files/marbles/windowUntil.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal. Upon cancellation of the current window,
 it also discards the remaining elements that were bound for it until the main sequence completes
 or creation of a new window is triggered.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>boundaryTrigger</code> - a predicate that triggers the next window when it becomes true.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows, bounded depending
 on the predicate.</dd>
</dl>
</li>
</ul>
<a name="windowUntil-java.util.function.Predicate-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowUntil</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowUntil(java.util.function.Predicate&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;boundaryTrigger,
                                       boolean&nbsp;cutBefore)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows delimited by the
 given predicate. A new window is opened each time the predicate returns true.
 <p>
 Windows are lazily made available downstream at the point where they receive their
 first event (an element is pushed, the window completes or errors).
 <p>
 If <code>cutBefore</code> is true, the old window will onComplete and the triggering
 element will be emitted in the new window, which becomes immediately available.
 This variant can emit an empty window if the sequence starts with a separator.
 <p>
 Otherwise, the triggering element will be emitted in the old window before it does
 onComplete, similar to <a href="../../../reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-"><code>windowUntil(Predicate)</code></a>. This variant shouldn't
 expose empty windows, as the separators are emitted into the windows they close.
 <p>
 <img class="marble" src="doc-files/marbles/windowUntilWithCutBefore.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal. Upon cancellation of the current window,
 it also discards the remaining elements that were bound for it until the main sequence completes
 or creation of a new window is triggered.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>boundaryTrigger</code> - a predicate that triggers the next window when it becomes true.</dd>
<dd><code>cutBefore</code> - set to true to include the triggering element in the new window rather than the old.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows, bounded depending
 on the predicate.</dd>
</dl>
</li>
</ul>
<a name="windowUntil-java.util.function.Predicate-boolean-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowUntil</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowUntil(java.util.function.Predicate&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;boundaryTrigger,
                                       boolean&nbsp;cutBefore,
                                       int&nbsp;prefetch)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows delimited by the given
 predicate and using a prefetch. A new window is opened each time the predicate
 returns true.
 <p>
 Windows are lazily made available downstream at the point where they receive their
 first event (an element is pushed, the window completes or errors).
 <p>
 If <code>cutBefore</code> is true, the old window will onComplete and the triggering
 element will be emitted in the new window. This variant can emit an empty window
 if the sequence starts with a separator.
 <p>
 Otherwise, the triggering element will be emitted in the old window before it does
 onComplete, similar to <a href="../../../reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-"><code>windowUntil(Predicate)</code></a>. This variant shouldn't
 expose empty windows, as the separators are emitted into the windows they close.
 <p>
 <img class="marble" src="doc-files/marbles/windowUntilWithCutBefore.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal. Upon cancellation of the current window,
 it also discards the remaining elements that were bound for it until the main sequence completes
 or creation of a new window is triggered.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>boundaryTrigger</code> - a predicate that triggers the next window when it becomes true.</dd>
<dd><code>cutBefore</code> - set to true to include the triggering element in the new window rather than the old.</dd>
<dd><code>prefetch</code> - the request size to use for this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows, bounded depending
 on the predicate.</dd>
</dl>
</li>
</ul>
<a name="windowUntilChanged--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowUntilChanged</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowUntilChanged()</pre>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another) into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows.

 <p>
 <img class="marble" src="doc-files/marbles/windowUntilChanged.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal. Upon cancellation of the current window,
 it also discards the remaining elements that were bound for it until the main sequence completes
 or creation of a new window is triggered.</div>
<dl>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows.</dd>
</dl>
</li>
</ul>
<a name="windowUntilChanged-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowUntilChanged</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowUntilChanged(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super V&gt;&nbsp;keySelector)</pre>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another), as compared by a key extracted through the user provided <code>Function</code>, into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows.

 <p>
 <img class="marble" src="doc-files/marbles/windowUntilChangedWithKeySelector.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal. Upon cancellation of the current window,
 it also discards the remaining elements that were bound for it until the main sequence completes
 or creation of a new window is triggered.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keySelector</code> - function to compute comparison key for each element</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows.</dd>
</dl>
</li>
</ul>
<a name="windowUntilChanged-java.util.function.Function-java.util.function.BiPredicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowUntilChanged</h4>
<pre>public final&nbsp;&lt;V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowUntilChanged(java.util.function.Function&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? extends V&gt;&nbsp;keySelector,
                                                  java.util.function.BiPredicate&lt;? super V,? super V&gt;&nbsp;keyComparator)</pre>
<div class="block">Collect subsequent repetitions of an element (that is, if they arrive right after
 one another), as compared by a key extracted through the user provided <code>Function</code> and compared using a supplied <code>BiPredicate</code>, into multiple
 <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows.

 <p>
 <img class="marble" src="doc-files/marbles/windowUntilChangedWithKeySelector.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal. Upon cancellation of the current window,
 it also discards the remaining elements that were bound for it until the main sequence completes
 or creation of a new window is triggered.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>keySelector</code> - function to compute comparison key for each element</dd>
<dd><code>keyComparator</code> - predicate used to compare keys</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a microbatched <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows.</dd>
</dl>
</li>
</ul>
<a name="windowWhile-java.util.function.Predicate-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowWhile</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowWhile(java.util.function.Predicate&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;inclusionPredicate)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows that stay open
 while a given predicate matches the source elements. Once the predicate returns
 false, the window closes with an onComplete and the triggering element is discarded.
 <p>
 Windows are lazily made available downstream at the point where they receive their
 first event (an element is pushed, the window completes or errors). Empty windows
 can happen when a sequence starts with a separator or contains multiple separators,
 but a sequence that finishes with a separator won't cause a remainder empty window
 to be emitted.
 <p>
 <img class="marble" src="doc-files/marbles/windowWhile.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal, as well as the triggering element(s) (that doesn't match
 the predicate). Upon cancellation of the current window, it also discards the remaining elements
 that were bound for it until the main sequence completes or creation of a new window is triggered.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>inclusionPredicate</code> - a predicate that triggers the next window when it becomes false.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows, each containing
 subsequent elements that all passed a predicate.</dd>
</dl>
</li>
</ul>
<a name="windowWhile-java.util.function.Predicate-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowWhile</h4>
<pre>public final&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowWhile(java.util.function.Predicate&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&nbsp;inclusionPredicate,
                                       int&nbsp;prefetch)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into multiple <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows that stay open
 while a given predicate matches the source elements. Once the predicate returns
 false, the window closes with an onComplete and the triggering element is discarded.
 <p>
 Windows are lazily made available downstream at the point where they receive their
 first event (an element is pushed, the window completes or errors). Empty windows
 can happen when a sequence starts with a separator or contains multiple separators,
 but a sequence that finishes with a separator won't cause a remainder empty window
 to be emitted.
 <p>
 <img class="marble" src="doc-files/marbles/windowWhile.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator discards elements it internally queued for backpressure
 upon cancellation or error triggered by a data signal, as well as the triggering element(s) (that doesn't match
 the predicate). Upon cancellation of the current window, it also discards the remaining elements
 that were bound for it until the main sequence completes or creation of a new window is triggered.</div>
<dl>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>inclusionPredicate</code> - a predicate that triggers the next window when it becomes false.</dd>
<dd><code>prefetch</code> - the request size to use for this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows, each containing
 subsequent elements that all passed a predicate.</dd>
</dl>
</li>
</ul>
<a name="windowWhen-org.reactivestreams.Publisher-java.util.function.Function-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>windowWhen</h4>
<pre>public final&nbsp;&lt;U,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>&gt;&gt;&nbsp;windowWhen(org.reactivestreams.Publisher&lt;U&gt;&nbsp;bucketOpening,
                                            java.util.function.Function&lt;? super U,? extends org.reactivestreams.Publisher&lt;V&gt;&gt;&nbsp;closeSelector)</pre>
<div class="block">Split this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> sequence into potentially overlapping windows controlled by items of a
 start <code>Publisher</code> and end <code>Publisher</code> derived from the start values.

 <p>
 When Open signal is strictly not overlapping Close signal : dropping windows
 <p>
 When Open signal is strictly more frequent than Close signal : overlapping windows
 <p>
 When Open signal is exactly coordinated with Close signal : exact windows
 <p>
 <img class="marble" src="doc-files/marbles/windowWhen.svg" alt="">

 <p>
 Note that windows are a live view of part of the underlying source publisher,
 and as such their lifecycle is tied to that source. As a result, it is not possible
 to subscribe to a window more than once: they are unicast.
 This is most noticeable when trying to <a href="../../../reactor/core/publisher/Flux.html#retry--"><code>retry()</code></a> or <a href="../../../reactor/core/publisher/Flux.html#repeat--"><code>repeat()</code></a> a window,
 as these operators are based on re-subscription.

 <p>
 To distinguish errors emitted by the processing of individual windows, source
 sequence errors delivered to the window <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> are wrapped in
 <a href="../../../reactor/core/Exceptions.SourceException.html" title="reactor.core中的类"><code>Exceptions.SourceException</code></a>.

 <p><strong>Discard Support:</strong> This operator DOES NOT discard elements.</div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the type of the sequence opening windows</dd>
<dd><code>V</code> - the type of the sequence closing windows opened by the bucketOpening Publisher's elements</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>bucketOpening</code> - a <code>Publisher</code> that opens a new window when it emits any item</dd>
<dd><code>closeSelector</code> - a <code>Function</code> given an opening signal and returning a <code>Publisher</code> that
 will close the window when emitting</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> of <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> windows opened by signals from a first
 <code>Publisher</code> and lasting until a selected second <code>Publisher</code> emits</dd>
</dl>
</li>
</ul>
<a name="withLatestFrom-org.reactivestreams.Publisher-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>withLatestFrom</h4>
<pre>public final&nbsp;&lt;U,R&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;R&gt;&nbsp;withLatestFrom(org.reactivestreams.Publisher&lt;? extends U&gt;&nbsp;other,
                                          java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super U,? extends R&gt;&nbsp;resultSelector)</pre>
<div class="block">Combine the most recently emitted values from both this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and another
 <code>Publisher</code> through a <code>BiFunction</code> and emits the result.
 <p>
 The operator will drop values from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> until the other
 <code>Publisher</code> produces any value.
 <p>
 If the other <code>Publisher</code> completes without any value, the sequence is completed.

 <p>
 <img class="marble" src="doc-files/marbles/withLatestFrom.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>U</code> - the other <code>Publisher</code> sequence type</dd>
<dd><code>R</code> - the result type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>other</code> - the <code>Publisher</code> to combine with</dd>
<dd><code>resultSelector</code> - the bi-function called with each pair of source and other
 elements that should return a single value to be emitted</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a combined <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> gated by another <code>Publisher</code></dd>
</dl>
</li>
</ul>
<a name="zipWith-org.reactivestreams.Publisher-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWith</h4>
<pre>public final&nbsp;&lt;T2&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,T2&gt;&gt;&nbsp;zipWith(org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2)</pre>
<div class="block">Zip this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with another <code>Publisher</code> source, that is to say wait
 for both to emit one element and combine these elements once into a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a>.
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipWithOtherForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T2</code> - type of the value from source2</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source2</code> - The second source <code>Publisher</code> to zip with this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zipWith-org.reactivestreams.Publisher-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWith</h4>
<pre>public final&nbsp;&lt;T2,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;zipWith(org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                    java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super T2,? extends V&gt;&nbsp;combinator)</pre>
<div class="block">Zip this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with another <code>Publisher</code> source, that is to say wait
 for both to emit one element and combine these elements using a <code>combinator</code>
 <code>BiFunction</code>
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipWithOtherUsingZipperForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>V</code> - The produced output after transformation by the combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source2</code> - The second source <code>Publisher</code> to zip with this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</dd>
<dd><code>combinator</code> - The aggregate function that will receive a unique value from each
 source and return the value to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zipWith-org.reactivestreams.Publisher-int-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWith</h4>
<pre>public final&nbsp;&lt;T2,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;zipWith(org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                    int&nbsp;prefetch,
                                    java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super T2,? extends V&gt;&nbsp;combinator)</pre>
<div class="block">Zip this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with another <code>Publisher</code> source, that is to say wait
 for both to emit one element and combine these elements using a <code>combinator</code>
 <code>BiFunction</code>
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.
 <p>
 <img class="marble" src="doc-files/marbles/zipWithOtherUsingZipperForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T2</code> - type of the value from source2</dd>
<dd><code>V</code> - The produced output after transformation by the combinator</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source2</code> - The second source <code>Publisher</code> to zip with this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</dd>
<dd><code>prefetch</code> - the request size to use for this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and the other <code>Publisher</code></dd>
<dd><code>combinator</code> - The aggregate function that will receive a unique value from each
 source and return the value to signal downstream</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zipWith-org.reactivestreams.Publisher-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWith</h4>
<pre>public final&nbsp;&lt;T2&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,T2&gt;&gt;&nbsp;zipWith(org.reactivestreams.Publisher&lt;? extends T2&gt;&nbsp;source2,
                                             int&nbsp;prefetch)</pre>
<div class="block">Zip this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with another <code>Publisher</code> source, that is to say wait
 for both to emit one element and combine these elements once into a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a>.
 The operator will continue doing so until any of the sources completes.
 Errors will immediately be forwarded.
 This "Step-Merge" processing is especially useful in Scatter-Gather scenarios.

 <p>
 <img class="marble" src="doc-files/marbles/zipWithOtherForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T2</code> - type of the value from source2</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>source2</code> - The second source <code>Publisher</code> to zip with this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a>.</dd>
<dd><code>prefetch</code> - the request size to use for this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> and the other <code>Publisher</code></dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zipWithIterable-java.lang.Iterable-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWithIterable</h4>
<pre>public final&nbsp;&lt;T2&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;<a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类">Tuple2</a>&lt;<a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,T2&gt;&gt;&nbsp;zipWithIterable(java.lang.Iterable&lt;? extends T2&gt;&nbsp;iterable)</pre>
<div class="block">Zip elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the content of an <code>Iterable</code>, that is
 to say combine one element from each, pairwise, into a <a href="../../../reactor/util/function/Tuple2.html" title="reactor.util.function中的类"><code>Tuple2</code></a>.

 <p>
 <img class="marble" src="doc-files/marbles/zipWithIterableForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T2</code> - the value type of the other iterable sequence</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>iterable</code> - the <code>Iterable</code> to zip with</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="zipWithIterable-java.lang.Iterable-java.util.function.BiFunction-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>zipWithIterable</h4>
<pre>public final&nbsp;&lt;T2,V&gt;&nbsp;<a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类">Flux</a>&lt;V&gt;&nbsp;zipWithIterable(java.lang.Iterable&lt;? extends T2&gt;&nbsp;iterable,
                                            java.util.function.BiFunction&lt;? super <a href="../../../reactor/core/publisher/Flux.html" title="Flux中的类型参数">T</a>,? super T2,? extends V&gt;&nbsp;zipper)</pre>
<div class="block">Zip elements from this <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a> with the content of an <code>Iterable</code>, that is
 to say combine one element from each, pairwise, using the given zipper <code>BiFunction</code>.


 <p>
 <img class="marble" src="doc-files/marbles/zipWithIterableUsingZipperForFlux.svg" alt=""></div>
<dl>
<dt><span class="paramLabel">类型参数:</span></dt>
<dd><code>T2</code> - the value type of the other iterable sequence</dd>
<dd><code>V</code> - the result type</dd>
<dt><span class="paramLabel">参数:</span></dt>
<dd><code>iterable</code> - the <code>Iterable</code> to zip with</dd>
<dd><code>zipper</code> - the <code>BiFunction</code> pair combinator</dd>
<dt><span class="returnLabel">返回:</span></dt>
<dd>a zipped <a href="../../../reactor/core/publisher/Flux.html" title="reactor.core.publisher中的类"><code>Flux</code></a></dd>
</dl>
</li>
</ul>
<a name="toString--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<dl>
<dt><span class="overrideSpecifyLabel">覆盖:</span></dt>
<dd><code>toString</code>&nbsp;在类中&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/Flux.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../help-doc.html">帮助</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../reactor/core/publisher/EmitterProcessor.html" title="reactor.core.publisher中的类"><span class="typeNameLink">上一个类</span></a></li>
<li><a href="../../../reactor/core/publisher/FluxArrayTest.html" title="reactor.core.publisher中的类"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?reactor/core/publisher/Flux.html" target="_top">框架</a></li>
<li><a href="Flux.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>嵌套&nbsp;|&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">方法</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">构造器</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">方法</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
